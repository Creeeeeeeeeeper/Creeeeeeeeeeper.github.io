<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>wannacry勒索病毒分析</title>
    <url>/2024/10/02/wannacry/</url>
    <content><![CDATA[<p>分析基于2024龙信杯wcry乐锁病毒题目，<strong>本题目没有原始wannacry病毒的域名开关部分</strong></p>
<table>
<thead>
<tr>
<th align="center">序号</th>
<th align="center">题目</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">分析计算机检材，eduwcry压缩包文件的解压密码是什么？[标准格式：abcabc] 答案：yasuomima</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">分析计算机检材，接上题，请问恶意程序释放压缩包的md5值是多少。[标准格式：全小写]</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">分析计算机检材，接上题，请问恶意程序记录的洋葱浏览器下载地址是多少？[标准格式：<a href="http://xx.xx/xx/xx.zip]">http://xx.xx/xx/xx.zip]</a></td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">分析计算机检材，接上题，请问恶意程序解密了t.wnry后该dll的md5值是多少。[标准格式：全小写]</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">分析计算机检材，接上题，恶意程序运行起来后第一个循环调用了几次taskkill.exe。[标准格式：2]</td>
</tr>
<tr>
<td align="center">6</td>
<td align="center">分析计算机检材，接上题，请问@WanaDecryptor@.exe.lnk文件是通过什么函数创建的。[标准格式：Aabcdef]</td>
</tr>
<tr>
<td align="center">7</td>
<td align="center">分析计算机检材，接上题，恶意程序修改系统桌面壁纸是在哪个函数实现的[标准格式：sub_xxx]</td>
</tr>
</tbody></table>
<span id="more"></span>

<blockquote>
<p><strong>本文参考：</strong></p>
<p><a href="https://www.youtube.com/watch?v=Sv8yu12y5zM">Reversing WannaCry Part 1 - Finding the killswitch and unpacking the malware in #Ghidra - YouTube</a><br><a href="https://www.youtube.com/watch?v=Q90uZS3taG0">Reversing WannaCry Part 2 - Diving into the malware with #Ghidra - YouTube</a><br><a href="https://sayonara.gitbook.io/writeups/malware-analysis/wannacry-ransomware#extracting-the-wannacry-encryptor-binary">WannaCry 勒索软件 |WriteUps (gitbook.io)</a><br><a href="https://thewebchap.wordpress.com/2017/05/16/wannacry-detailed-analysis-part-2-of-3/">Wannacry ： 详细分析（第 2 部分，共 3 部分） – 网络章节 (wordpress.com)</a><br>[<a href="https://blog.csdn.net/anhui8496/article/details/102431403">病毒分析]WannaCry病毒分析(永恒之蓝)-CSDN博客</a></p>
</blockquote>
<div style="color: red; font-weight: 600;">
    <br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;木马母体为mssecsvc.exe，运行后会扫描随机IP的互联网机器，尝试感染，也会扫描局域网相同网段的机器进行感染传播，此外会释放敲诈者程序tasksche.exe，对磁盘文件进行加密勒索。
    <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;分析时须放到虚拟机里断网操作，关闭共享协议端口或物理隔离，并禁用共享文件夹<br>
<br>
<br>
<br>
<div style="display: flex; justify-content: center">
    <text style="color: red; font-weight: 600;">戈门，别真被乐锁了啊</text>
</div>
<br>
<br>
<br>
<br>
<div style="display: flex; justify-content: center">
    <text style="color: black">两个分析文件下载 ↓</text>
</div>
<br>
<div style="display: flex; justify-content: center">
    <a href="https://creeeeeeeeeeper.github.io/2024/10/02/wannacry/wncy.zip" alt="目录迁移.exe"><div style="display: flex; flex-direction:row; border: solid 1px #cccccc; height: 60px;">
        <image src="https://creeeeeeeeeeper.github.io/2024/10/02/wannacry/image-20241003150917202.png" style="scale: 0.8; margin-top: 10px"></image>
        <div style="display: flex; flex-direction: column; font-size: 12.5px; padding-right: 15px; margin-top: 10px">
            <text>wncy.zip</text>
            <text style="font-size: 8px; color: #cccccc">3.93MB</text>
        </div>
    </div></a></div>
<br>
</div>


<p>下面从第二题开始分析</p>
<h2 id="释放压缩包的md5"><a href="#释放压缩包的md5" class="headerlink" title="释放压缩包的md5"></a>释放压缩包的md5</h2><p>拿出pestudio看一下压缩包里的“下崽”程序wcry.exe，里面有一个PKZIP压缩包</p>
<p><img src="/2024/10/02/wannacry/image-20241002160552864.png" alt="image-20241002160552864"></p>
<p>直接使用pestudio还拿不出来，没法save to file</p>
<p><img src="/2024/10/02/wannacry/image-20241002160743992.png" alt="image-20241002160743992"></p>
<p>使用resource hacker</p>
<p><img src="/2024/10/02/wannacry/image-20241002161028449.png" alt="image-20241002161028449"></p>
<p>右键XIA，将资源保存到BIN文件，保存时，将后缀改成zip</p>
<p><img src="/2024/10/02/wannacry/image-20241002161127998.png" alt="image-20241002161127998"></p>
<p>这样就保存下来了</p>
<img src="/2024/10/02/wannacry/image-20241002161204939.png" alt="image-20241002161204939" style="zoom:50%;">

<img src="/2024/10/02/wannacry/image-20241002161423725.png" alt="image-20241002161423725" style="zoom:50%;">

<p>certutil一下</p>
<blockquote>
<p>b576ada3366908875e5ce4cb3da6153a</p>
</blockquote>
<div>
<br>
<br>
<br>
<br>
</div>

<h2 id="Tor下载地址"><a href="#Tor下载地址" class="headerlink" title="Tor下载地址"></a>Tor下载地址</h2><p>经过一番查看wcry下的崽，找到一个c.wnry，看一下这个文件里面有什么东西</p>
<p><img src="/2024/10/02/wannacry/image-20241002171753970.png" alt="image-20241002171753970"></p>
<p>发现里面放了程序中虚拟币的地址<img src="/2024/10/02/wannacry/image-20241002171819869.png" alt="image-20241002171819869" style="zoom:50%;"></p>
<p>还有一些以<code>.onion</code>结尾的东西，应该就跟Tor有关，还有最后一个链接<code>https://dist.torproject.org/torbrowser/6.5.1/tor-win32-0.2.9.10.zip</code></p>
<p>这个就应该是Tor的下载地址</p>
<blockquote>
<p><code>https://dist.torproject.org/torbrowser/6.5.1/tor-win32-0.2.9.10.zip</code></p>
</blockquote>
<div>
<br>
<br>
</div>


<h2 id="解密了t-wnry后该dll的md5值是多少"><a href="#解密了t-wnry后该dll的md5值是多少" class="headerlink" title="解密了t.wnry后该dll的md5值是多少"></a>解密了t.wnry后该dll的md5值是多少</h2><p>在虚拟机中分析的时候不要运行病毒，真服了，闲的没事儿就把我IDA的key和license加密了</p>
<p>首先对WinMain分析一下：</p>
<p><img src="/2024/10/02/wannacry/image-20241003103342937.png" alt="image-20241003103342937"></p>
<p>大体知道第一个wcry.exe怎么运行就好了，先不分析每个函数，用x32动态把dll拿出来</p>
<p><img src="/2024/10/02/wannacry/image-20241003120451211.png" alt="image-20241003120451211"><br><img src="/2024/10/02/wannacry/image-20241003120539642.png" alt="image-20241003120539642"></p>
<p>在上面这个函数中，判断完主要功能之后，要在内存中找到这块PE文件，直接在最后的<code>return v4</code>的地方按一下Tab，界面落在了<code>mov eax, ebx</code>的位置，所以这个函数返回的时候就是用的eax寄存器，使用x32跑到这里然后转到eax存的那个地址应该就是那个隐藏的dll文件了。</p>
<p><img src="/2024/10/02/wannacry/image-20241003120719251.png" alt="image-20241003120719251"></p>
<p><img src="/2024/10/02/wannacry/image-20241003120902189.png" alt="image-20241003120902189"></p>
<p>EAX是<code>00A83DE8</code>，在内存中转到，终于发现了这个MZ头</p>
<p><img src="/2024/10/02/wannacry/image-20241003121001396.png" alt="image-20241003121001396"></p>
<p>将这一大块属于这个dll的保存到文件</p>
<p><img src="/2024/10/02/wannacry/image-20241003121317994.png" alt="image-20241003121317994"></p>
<p>看看恁俩这个大小长得真像啊，就差0.2KB</p>
<img src="/2024/10/02/wannacry/image-20241003121712803.png" alt="image-20241003121712803" style="zoom:67%;">

<p><img src="/2024/10/02/wannacry/image-20241003121848526.png" alt="image-20241003121848526"></p>
<p>所以t.wnry解密后dll的md5应该是</p>
<blockquote>
<p>f351e1fcca0c4ea05fc44d15a17f8b36</p>
</blockquote>
<h2 id="第一个循环调用了几次taskkill-exe"><a href="#第一个循环调用了几次taskkill-exe" class="headerlink" title="第一个循环调用了几次taskkill.exe"></a>第一个循环调用了几次taskkill.exe</h2><p>wcry.exe中：</p>
<p><img src="/2024/10/02/wannacry/image-20241003123201124.png" alt="image-20241003123201124"></p>
<p>下面开始对dll中的TaskStart函数开始分析</p>
<p>将分出来的dll再扔到IDA中，找到TastStart函数</p>
<p><img src="/2024/10/02/wannacry/image-20241003123256110.png" alt="image-20241003123256110"></p>
<p>首先对着TaskStart一顿分析：</p>
<p><img src="/2024/10/02/wannacry/20241003131128.png" alt="20241003131128"><br><img src="/2024/10/02/wannacry/20241003131242.png" alt="20241003131242"><br><img src="/2024/10/02/wannacry/20241003131341.png" alt="20241003131341"></p>
<p>这一堆没有发现什么taskkill</p>
<p>最后那个函数里面还有好多东西，我标了一个Important，进来看看</p>
<p><img src="/2024/10/02/wannacry/20241003131901.png" alt="20241003131901"><br><img src="/2024/10/02/wannacry/20241003131943.png" alt="20241003131943"></p>
<p>到这里就不用往下看了，已经发现了Taskkill，Tab切换到代码视图</p>
<p><img src="/2024/10/02/wannacry/image-20241003132059380.png" alt="image-20241003132059380"></p>
<p>所以应该调用了5次taskkill.exe，不过我不是很懂题目中说的第一个循环是什么意思</p>
<p>不过……后来才发现，好像直接搜字符串也行</p>
<p><img src="/2024/10/02/wannacry/image-20241003133919573.png" alt="image-20241003133919573"></p>
<h2 id="WanaDecryptor-exe-lnk文件是通过什么函数创建"><a href="#WanaDecryptor-exe-lnk文件是通过什么函数创建" class="headerlink" title="@WanaDecryptor@.exe.lnk文件是通过什么函数创建"></a>@WanaDecryptor@.exe.lnk文件是通过什么函数创建</h2><p>首先要找到<code>@WanaDecryptor@.exe.lnk</code>这个东西</p>
<p>从上题的taskkill往下找，稍微翻一下就翻到了这个字符串所在的位置（也可以直接搜）：</p>
<p><img src="/2024/10/02/wannacry/image-20241003133128344.png" alt="image-20241003133128344"></p>
<p><img src="/2024/10/02/wannacry/image-20241003134435554.png" alt="image-20241003134435554"></p>
<p>不过这里的逻辑好像是跳过这三个文件，对其他的所有（他要加密）的后缀进行加密，所以这三个文件应该在之前就创建了，所以再往前找</p>
<p>由于对批处理脚本不熟悉，所以分析完上面的一堆函数才来分析这个批处理脚本</p>
<p>也不会这玩意，问一下ai</p>
<img src="/2024/10/02/wannacry/image-20241003135834048.png" alt="image-20241003135834048" style="zoom:63%;">

<img src="/2024/10/02/wannacry/image-20241003135942848.png" alt="image-20241003135942848" style="zoom:50%;">

<p>嗯……我觉得AI说得对！那就应该是CreateShortcut函数</p>
<h2 id="修改系统桌面壁纸是在哪个函数实现的"><a href="#修改系统桌面壁纸是在哪个函数实现的" class="headerlink" title="修改系统桌面壁纸是在哪个函数实现的"></a>修改系统桌面壁纸是在哪个函数实现的</h2><p>嗯，也不会，问问AI</p>
<p><img src="/2024/10/02/wannacry/image-20241003141310913.png" alt="image-20241003141310913"></p>
<p><img src="/2024/10/02/wannacry/image-20241003141356282.png" alt="image-20241003141356282"></p>
<p>不一会儿就翻出来了</p>
<p><img src="/2024/10/02/wannacry/image-20241003144903325.png" alt="image-20241003144903325"></p>
<p>答案让回答sub_xxxxx</p>
<blockquote>
<p>sub_10004F20</p>
</blockquote>
<div>
    <br>
答案都是自己做的，做了将近两天，已经头昏眼花了，不一定对，如有不对请大大大大大大佬指教一下
    <br>
</div>
]]></content>
  </entry>
  <entry>
    <title>清理C盘之数据迁移</title>
    <url>/2024/10/01/cleanC/</url>
    <content><![CDATA[<h2 id="清理C盘"><a href="#清理C盘" class="headerlink" title="清理C盘"></a>清理C盘</h2><p>每次取证C盘都要被火眼的hlnet填满……</p>
<p>清理一下爆满的C盘，其实也不是清理，就是数据转移</p>
<p><img src="/2024/10/01/cleanC/image-20241001142630593.png" alt="image-20241001142630593"></p>
<p>方法：使用mklink创建系统链接</p>
<span id="more"></span>

<h2 id="脚本实现"><a href="#脚本实现" class="headerlink" title="脚本实现"></a>脚本实现</h2><p>这么难得东西怎么能亲自动手呢？先写个脚本！ </p>
<div style="display:flex; justify-content: center; flex-direction: column; align-items: center">
    <text>脚本已制作成.exe，点击下方可下载。（本程序默认在D盘的AimportantDataLink文件夹下）</text>
    <br>
    <a href="https://creeeeeeeeeeper.github.io/2024/10/01/cleanC/目录迁移.exe" alt="目录迁移.exe"><div style="display: flex; flex-direction:row; border: solid 1px #cccccc; height: 60px;">
        <image src="https://creeeeeeeeeeper.github.io/2024/10/01/cleanC/bind.png" style="scale: 0.6; margin-top: 10px"></image>
        <div style="display: flex; flex-direction: column; font-size: 12.5px; padding-right: 15px; margin-top: 10px">
            <text>目录迁移.exe</text>
            <text style="font-size: 8px; color: #cccccc">11.1MB</text>
        </div>
    </div></a>
</div>


<div>
<div style="color: red; font-size: 18px">
（脚本需要在管理员权限下运行，否则无法创建链接）
</div>
<br>
<div style="color: green; font-size: 18px">
    &nbsp;&nbsp;&nbsp;>>>此脚本已验证可用<<<
</div>
</div>


<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> shutil</span><br><span class="line"></span><br><span class="line">original_catalogue_path = <span class="built_in">input</span>(<span class="string">&quot;需迁移目录路径: &quot;</span>)</span><br><span class="line">new_catalogue_path = <span class="string">&#x27;D:\\AimportantDataLink&#x27;</span> + <span class="string">&quot;\\&quot;</span> + original_catalogue_path.split(<span class="string">&quot;\\&quot;</span>)[-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">move_catalogue</span>(<span class="params">original_catalogue_path, new_catalogue_path</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(original_catalogue_path):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;原目录不存在!&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(new_catalogue_path):</span><br><span class="line">        os.makedirs(new_catalogue_path)</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> os.listdir(original_catalogue_path):</span><br><span class="line">        original_item_path = os.path.join(original_catalogue_path, item)</span><br><span class="line">        new_item_path = os.path.join(new_catalogue_path, item)</span><br><span class="line">        shutil.move(original_item_path, new_item_path)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;已移动: <span class="subst">&#123;original_item_path&#125;</span> -&gt; <span class="subst">&#123;new_item_path&#125;</span>&quot;</span>)</span><br><span class="line">    link_name = new_catalogue_path</span><br><span class="line">    command = <span class="string">f&#x27;mklink &quot;<span class="subst">&#123;original_catalogue_path&#125;</span>&quot; &quot;<span class="subst">&#123;link_name&#125;</span>&quot;&#x27;</span></span><br><span class="line">    shutil.rmtree(original_catalogue_path)</span><br><span class="line">    os.system(command)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;已创建链接: <span class="subst">&#123;link_name&#125;</span> -&gt; <span class="subst">&#123;new_catalogue_path&#125;</span>&quot;</span>)</span><br><span class="line">move_catalogue(original_catalogue_path, new_catalogue_path)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>脚本中的<code>D:\\AimportantDataLink</code>为转移数据的存放路径，脚本看不懂继续往下看，看完就懂了</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>拿Edge浏览器开刀 &#x3D;&gt; <code>C:\Users\ &lt;your_user_name&gt; \AppData\Local\Microsoft\Edge</code></p>
<img src="/2024/10/01/cleanC/image-20241001142958389.png" alt="image-20241001142958389" style="zoom:50%;">

<p>Edge浏览器占了大概3.5G，给他移到D盘去</p>
<h3 id="关掉Edge所有进程"><a href="#关掉Edge所有进程" class="headerlink" title="关掉Edge所有进程"></a>关掉Edge所有进程</h3><h3 id="找到需要移动的数据"><a href="#找到需要移动的数据" class="headerlink" title="找到需要移动的数据"></a>找到需要移动的数据</h3><img src="/2024/10/01/cleanC/image-20241001143148530.png" alt="image-20241001143148530" style="zoom:50%;">

<p>结束进程后改成Edge_old，做个备份</p>
<img src="/2024/10/01/cleanC/image-20241001143247110.png" alt="image-20241001143247110" style="zoom:50%;">

<h3 id="在D盘创建存放数据的文件夹"><a href="#在D盘创建存放数据的文件夹" class="headerlink" title="在D盘创建存放数据的文件夹"></a>在D盘创建存放数据的文件夹</h3><p><img src="/2024/10/01/cleanC/image-20241001143402251.png" alt="image-20241001143402251"></p>
<p>我创建了一个<code>D:\AimportantDataLink\EdgeDataLink</code>的文件夹来存放Edge的数据</p>
<h3 id="数据迁移"><a href="#数据迁移" class="headerlink" title="数据迁移"></a>数据迁移</h3><p>进入Edge中把User Data复制到EdgeDataLink中</p>
<p><img src="/2024/10/01/cleanC/image-20241001143531046.png" alt="image-20241001143531046"></p>
<h3 id="创建链接-出现的问题及解决方法"><a href="#创建链接-出现的问题及解决方法" class="headerlink" title="创建链接 &amp; 出现的问题及解决方法"></a>创建链接 &amp; 出现的问题及解决方法</h3><p>使用管理员打开cmd</p>
<p>输入<code>mklink C:\Users\ &lt;your_user_name&gt; \AppData\Local\Microsoft\Edge D:\AimportantDataLink\EdgeDataLink</code></p>
<p>输出：</p>
<p><img src="/2024/10/01/cleanC/image-20241001143904591.png" alt="image-20241001143904591"></p>
<p>创建链接时如果出现 “当文件已存在时，无法创建该链接”</p>
<p><img src="/2024/10/01/cleanC/image-20241001143832466.png" alt="image-20241001143832466"></p>
<p>说明你可能在将Edge文件夹命名成Edge_old之后又打开了Edge，Edge自动创建了一个Edge文件夹，这时候直接结束Edge进程，然后把C盘中的Edge文件夹删掉就可以了，保证自己备份的Edge_old的数据有就行。</p>
<p>创建链接成功之后，Microsoft文件夹下出现了一个<code>.symlink</code>的文件：</p>
<p><img src="/2024/10/01/cleanC/image-20241001144335144.png" alt="image-20241001144335144"></p>
<p>确保这个Edge链接跟最开始的Edge文件夹在同一目录(Mirosoft)下，并与原来的Edge文件夹名称相同，迁移其他数据时也是这样</p>
<p>此时检查一下Microsoft目录下没有Edge文件夹这时候就可以打开Edge了</p>
<p>打开后看到自己的东西还在就放心了</p>
<p><img src="/2024/10/01/cleanC/image-20241001144556123.png" alt="image-20241001144556123"></p>
<h3 id="移除Edge-old"><a href="#移除Edge-old" class="headerlink" title="移除Edge_old"></a>移除Edge_old</h3><p>不放心的话，先把C盘Edge_old目录剪切到D盘，再次打开Edge，如果正常运行，并且自己的东西还在的话，就可以直接把所有Edge_old删除了。</p>
<p style="display: flex; justify-content: center; flex-direction: row; align-items: center">
<img src="/2024/10/01/cleanC/image-20241001144908565.png" alt="image-20241001144908565" style="zoom:50%;"> <text> => </text>  <img src="/2024/10/01/cleanC/image-20241001152447425.png" alt="image-20241001152447425" style="zoom:50%;">
</p>
（因为又清空了一下回收站，所以空间又多了好多）

<p>脚本如果用着不放心，就先在桌面上创个文件夹，里面放两个txt，用脚本跑一下，如果成功了，继续迁移C盘就可以了</p>
<div>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
</div>
]]></content>
  </entry>
  <entry>
    <title>常见算法逆向</title>
    <url>/2024/09/25/algorithm/</url>
    <content><![CDATA[<h1 id="常见算法逆向"><a href="#常见算法逆向" class="headerlink" title="常见算法逆向"></a>常见算法逆向</h1><span id="more"></span>

<h2 id="Base64"><a href="#Base64" class="headerlink" title="Base64"></a>Base64</h2><h3 id="Base64编码规则"><a href="#Base64编码规则" class="headerlink" title="Base64编码规则"></a>Base64编码规则</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 将要加密的字符串变成二进制</span><br><span class="line">2. 二进制重新分组</span><br><span class="line">3. 分组后二进制转十进制</span><br><span class="line">4. 根据十进制查base64编码表</span><br></pre></td></tr></table></figure>

<img src="/2024/09/25/algorithm/image-20240925101744872.png" alt="image-20240925101744872" style="zoom:50%;">

<p>加密步骤</p>
<p><img src="/2024/09/25/algorithm/image-20240925101933086.png" alt="image-20240925101933086"></p>
<p>空缺时会有一个补零操作</p>
<p><img src="/2024/09/25/algorithm/image-20240925103600426.png" alt="image-20240925103600426"></p>
<h3 id="魔改"><a href="#魔改" class="headerlink" title="魔改"></a>魔改</h3><p>base64加密时一般会改base64编码表</p>
<p>比如本来的编码表：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">origin = <span class="string">&#x27;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&#x27;</span></span><br></pre></td></tr></table></figure>

<p>更改后的编码表：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">base = <span class="string">&#x27;aUiBDdopSQVOFlfLnTNrv4sj+MJW3g2Cy5IZk6APYt9RGwqm/8H7eKcx1EzbX0hu&#x27;</span></span><br></pre></td></tr></table></figure>

<p>使用更改的编码表进行解码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"></span><br><span class="line">origin = <span class="string">&#x27;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&#x27;</span></span><br><span class="line">base = <span class="string">&#x27;aUiBDdopSQVOFlfLnTNrv4sj+MJW3g2Cy5IZk6APYt9RGwqm/8H7eKcx1EzbX0hu&#x27;</span></span><br><span class="line">c = <span class="string">&#x27;r6lrnKTo27T5FsDxfB+ElZMIlBQZMAS/MB6AlB4klBnelZFeFrTACn==&#x27;</span></span><br><span class="line"></span><br><span class="line">table = <span class="built_in">str</span>.maketrans(base, origin)</span><br><span class="line">m = <span class="built_in">str</span>(base64.b64decode(c.translate(table)), encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(m)</span><br></pre></td></tr></table></figure>

<p>表一般会在程序运行的时候改掉，比如下面的例子</p>
<h3 id="base64改表"><a href="#base64改表" class="headerlink" title="base64改表"></a>base64改表</h3><p style="display: flex; justify-content: center">
<a href="https://gitee.com/zzzzzyg/exe/raw/master/easybase.exe"><img style="scale: 0.5" src="/2024/09/25/algorithm/image-20240925103838189.png" alt="点击下载easybase.exe"></a>
</p>
#### IDA 分析

<img src="/2024/09/25/algorithm/image-20240925104938767.png" alt="image-20240925104938767" style="zoom:67%;">

<p>找到main函数，分析程序逻辑</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 打印提示信息</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;plz_input_your_flag: &quot;</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 可能跟调试相关</span></span><br><span class="line">debug()</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//给字符串Str1加密</span></span><br><span class="line">Str1 = (<span class="type">char</span> *)base64_encode(v4, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断输入的字符串加密后是否与已知加密字符串相同</span></span><br><span class="line"><span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(Str1, <span class="string">&quot;r6lrnKTo27T5FsDxfB+ElZMIlBQZMAS/MB6AlB4klBnelZFeFrTACn==&quot;</span>) )</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Right!&quot;</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;try_again!&quot;</span>);</span><br></pre></td></tr></table></figure>

<img src="/2024/09/25/algorithm/image-20240925105452256.png" alt="image-20240925105452256" style="zoom:67%;">

<p>直接拿去解码是乱码，所以判断应该改了表</p>
<p>先进到base64_encode函数中查看加密逻辑：</p>
<img src="/2024/09/25/algorithm/image-20240925105540632.png" alt="image-20240925105540632" style="zoom:67%;">

<img src="/2024/09/25/algorithm/image-20240925105633185.png" alt="image-20240925105633185" style="zoom:67%;">

<p>在这里没有发现有什么改表操作，是一个常规的base64加密方法</p>
<p>那问题应该在<code>debug()</code>函数</p>
<img src="/2024/09/25/algorithm/image-20240925105753443.png" alt="image-20240925105753443" style="zoom:67%;">

<p>在<code>debug()</code>函数中，最后返回的时候有一个<code>random_shuffle()</code>函数，参数传进了base64编码表，应该是使用随机数种子打乱了编码表。如果程序正常执行不调试，那么随机数种子为0，如果程序在调试模式中运行，那么随机数种子会被设置成114514</p>
<p>所以动态调试的时候跳过<code>IsDebuggerPresent()</code>函数即可，使用随机数种子0获取到打乱后的表，在进行解密就可以了</p>
<h4 id="x64dbg动态调试"><a href="#x64dbg动态调试" class="headerlink" title="x64dbg动态调试"></a>x64dbg动态调试</h4><p>感觉x64dbg动态比IDA好用</p>
<p><img src="/2024/09/25/algorithm/image-20240925110900782.png" alt="image-20240925110900782"></p>
<p>可以使用IDA快速定位到<code>debug()</code>函数，（主要分析在右侧注释）</p>
<p>在第一个断点处，将ZF位标位1，跳过<code>Seed = 114514</code>，这样就得到了非调试模式下的base64表，表就应该在0x40F020这段内存中</p>
<p><img src="/2024/09/25/algorithm/image-20240925110954237.png" alt="image-20240925110954237"></p>
<img src="/2024/09/25/algorithm/image-20240925111048524.png" alt="image-20240925111048524" style="zoom:67%;">

<p>这一段就是修改后的base64编码表，编写一下一段py进行解码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"></span><br><span class="line">origin = <span class="string">&#x27;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&#x27;</span></span><br><span class="line">base = <span class="string">&#x27;aUiBDdopSQVOFlfLnTNrv4sj+MJW3g2Cy5IZk6APYt9RGwqm/8H7eKcx1EzbX0hu&#x27;</span></span><br><span class="line">c = <span class="string">&#x27;r6lrnKTo27T5FsDxfB+ElZMIlBQZMAS/MB6AlB4klBnelZFeFrTACn==&#x27;</span></span><br><span class="line"></span><br><span class="line">table = <span class="built_in">str</span>.maketrans(base, origin)</span><br><span class="line">m = <span class="built_in">str</span>(base64.b64decode(c.translate(table)), encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(m)</span><br></pre></td></tr></table></figure>

<p style="display: flex; justify-content: center;">
<text>解出：</text><img src="/2024/09/25/algorithm/image-20240925111238482.png" alt="image-20240925111238482" style="zoom:50%;">
</p>

<h2 id="RC4"><a href="#RC4" class="headerlink" title="RC4"></a>RC4</h2><h3 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h3>]]></content>
  </entry>
  <entry>
    <title>免杀</title>
    <url>/2024/09/21/ms/</url>
    <content><![CDATA[<h1 id="免杀"><a href="#免杀" class="headerlink" title="免杀"></a>免杀</h1><span id="more"></span>

<h2 id="C"><a href="#C" class="headerlink" title="C"></a>C</h2><p><strong>字符串隐藏</strong></p>
<p>在静态免杀中，如果字符串使用<code>const char* str = &quot;Hello World&quot;;</code>方式，或者放在全局变量区初始化，会在文件中直接看到</p>
<p><img src="/2024/09/21/ms/image-20240921192249823.png" alt="image-20240921192249823"></p>
<p>对免杀要隐藏字符串，使用<code>char str[] = &#123;&#39;h&#39;, &#39;e&#39;, &#39;l&#39;, &#39;l&#39;, &#39;o&#39;, 0&#125;;</code>初始化的字符串不会编译到文件里面，只有在程序开始运行的时候才会加载到栈中。</p>
<p>但是这种方法在exe中使用release版本编译还是可能被系统优化成一段完整的字符串，因此可以加入一些混淆代码，比如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">mian</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">6</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="type">int</span> b[<span class="number">5</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    a[<span class="number">0</span>] = <span class="string">&#x27;h&#x27;</span>;</span><br><span class="line">    b[<span class="number">0</span>] = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    a[<span class="number">1</span>] = <span class="string">&#x27;e&#x27;</span>;</span><br><span class="line">    b[<span class="number">1</span>] = <span class="string">&#x27;f&#x27;</span>;</span><br><span class="line">    a[<span class="number">2</span>] = <span class="string">&#x27;l&#x27;</span>;</span><br><span class="line">    b[<span class="number">2</span>] = <span class="string">&#x27;r&#x27;</span>;</span><br><span class="line">    a[<span class="number">3</span>] = <span class="string">&#x27;l&#x27;</span>;</span><br><span class="line">    b[<span class="number">3</span>] = <span class="string">&#x27;p&#x27;</span>;</span><br><span class="line">    a[<span class="number">4</span>] = <span class="string">&#x27;o&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样打印数组a就是hello，并且使用release生成也不会显示在PE文件中。</p>
<p><strong>命令行参数</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;argc = %d\n&quot;</span>, argc);</span><br><span class="line">    <span class="comment">// 循环打印argv数组中的内容</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; argc; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;argv[%d] = %s\n&quot;</span>, i, argv[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2024/09/21/ms/image-20240921194356442.png" alt="image-20240921194356442" style="zoom:50%;">

<p><strong>argc</strong>是输入的参数的个数加一，第一个参数是当前进程名，如果是在cmd中执行这个exe：</p>
<img src="/2024/09/21/ms/image-20240921194554141.png" alt="image-20240921194554141" style="zoom:50%;">

<p><strong>指针</strong></p>
]]></content>
  </entry>
  <entry>
    <title>一些没用的python脚本</title>
    <url>/2024/09/21/pythonScripts/</url>
    <content><![CDATA[<h2 id="pdf2docx"><a href="#pdf2docx" class="headerlink" title="pdf2docx"></a>pdf2docx</h2><span id="more"></span>

<h3 id="exe下载"><a href="#exe下载" class="headerlink" title="exe下载"></a>exe下载</h3><p><a href="https://wwuf.lanzouv.com/i5aIU2cqnwri">文件 (lanzouv.com)</a><br>密码:0000</p>
<h3 id="库"><a href="#库" class="headerlink" title="库"></a>库</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip install pdf2docx</span><br></pre></td></tr></table></figure>

<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pdf2docx <span class="keyword">import</span> Converter</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pdf_to_word</span>(<span class="params">pdf_file, word_file</span>):</span><br><span class="line">    cv = Converter(pdf_file)</span><br><span class="line">    cv.convert(word_file, start=<span class="number">0</span>, end=<span class="literal">None</span>)</span><br><span class="line">    cv.close()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;转换完成：<span class="subst">&#123;word_file&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    pdf_file = <span class="string">&#x27;input.pdf&#x27;</span>  <span class="comment"># 替换为 PDF 文件路径</span></span><br><span class="line">    word_file = <span class="string">&#x27;output.docx&#x27;</span>  <span class="comment"># 输出的 Word 文件路径</span></span><br><span class="line"></span><br><span class="line">pdf_to_word(pdf_file, word_file)</span><br></pre></td></tr></table></figure>



<h2 id="按日期整理图片视频"><a href="#按日期整理图片视频" class="headerlink" title="按日期整理图片视频"></a>按日期整理图片视频</h2><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> shutil</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_creation_date</span>(<span class="params">file_path</span>):</span><br><span class="line">    <span class="keyword">return</span> os.path.getmtime(file_path)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_file_size</span>(<span class="params">file_path</span>):</span><br><span class="line">    <span class="keyword">return</span> os.path.getsize(file_path)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">classify_files</span>(<span class="params">source_folder, target_folder</span>):</span><br><span class="line">    file_count = <span class="number">0</span></span><br><span class="line">    total_size = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> filename <span class="keyword">in</span> os.listdir(source_folder):</span><br><span class="line">        file_path = os.path.join(source_folder, filename)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> os.path.isfile(file_path):</span><br><span class="line">            creation_time = get_creation_date(file_path)</span><br><span class="line">            creation_date = datetime.fromtimestamp(creation_time)</span><br><span class="line"></span><br><span class="line">            year = creation_date.strftime(<span class="string">&#x27;%Y&#x27;</span>)</span><br><span class="line">            month = creation_date.strftime(<span class="string">&#x27;%m&#x27;</span>)</span><br><span class="line">            day = creation_date.strftime(<span class="string">&#x27;%d&#x27;</span>)</span><br><span class="line"></span><br><span class="line">            target_path = os.path.join(target_folder, year, month, day)</span><br><span class="line">            os.makedirs(target_path, exist_ok=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">            file_size = get_file_size(file_path)</span><br><span class="line">            total_size += file_size</span><br><span class="line">            </span><br><span class="line">            shutil.move(file_path, os.path.join(target_path, filename))</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&#x27;文件 <span class="subst">&#123;filename&#125;</span> 已移动到 <span class="subst">&#123;target_path&#125;</span>&#x27;</span>)</span><br><span class="line">            file_count += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> file_count, total_size</span><br><span class="line"></span><br><span class="line">source_folder = <span class="string">&#x27;D:/PHOTO&#x27;</span>  <span class="comment"># 替换为你的源文件夹路径</span></span><br><span class="line">target_folder = <span class="string">&#x27;D:/Xiaomi13Photo&#x27;</span>  <span class="comment"># 替换为你的目标文件夹路径</span></span><br><span class="line"></span><br><span class="line">start_time = time.time()</span><br><span class="line">processed_files, total_size = classify_files(source_folder, target_folder)</span><br><span class="line">end_time = time.time()</span><br><span class="line">elapsed_time = end_time - start_time</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;程序运行耗时: <span class="subst">&#123;elapsed_time:<span class="number">.2</span>f&#125;</span> 秒&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> total_size &gt; (<span class="number">1024</span> * <span class="number">1024</span> * <span class="number">1024</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;共处理了 <span class="subst">&#123;processed_files&#125;</span> 个文件，文件总大小: <span class="subst">&#123;total_size / (<span class="number">1024</span> * <span class="number">1024</span> * <span class="number">1024</span>):<span class="number">.2</span>f&#125;</span> GB&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;共处理了 <span class="subst">&#123;processed_files&#125;</span> 个文件，文件总大小: <span class="subst">&#123;total_size / (<span class="number">1024</span> * <span class="number">1024</span>):<span class="number">.2</span>f&#125;</span> MB&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>共5789张照片</p>
<p><img src="/2024/09/21/pythonScripts/image-20240921083656995.png" alt="image-20240921083656995"></p>
<p>​            <img src="/2024/09/21/pythonScripts/image-20240921084812939.png" alt="image-20240921084812939" style="zoom:50%;"> <img src="/2024/09/21/pythonScripts/image-20240921084859259.png" alt="image-20240921084859259" style="zoom: 50%;"></p>
<h2 id="迁移C盘自动链接脚本"><a href="#迁移C盘自动链接脚本" class="headerlink" title="迁移C盘自动链接脚本"></a>迁移C盘自动链接脚本</h2><p>如何使用请看：<a href="https://creeeeeeeeeeper.github.io/2024/10/01/cleanC/#more">清理C盘之数据迁移 | ZYG’s Notes (creeeeeeeeeeper.github.io)</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> shutil</span><br><span class="line"></span><br><span class="line">original_catalogue_path = <span class="built_in">input</span>(<span class="string">&quot;需迁移目录路径: &quot;</span>)</span><br><span class="line">new_catalogue_path = <span class="string">&#x27;D:\\AimportantDataLink&#x27;</span> + <span class="string">&quot;\\&quot;</span> + original_catalogue_path.split(<span class="string">&quot;\\&quot;</span>)[-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">move_catalogue</span>(<span class="params">original_catalogue_path, new_catalogue_path</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(original_catalogue_path):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;原目录不存在!&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(new_catalogue_path):</span><br><span class="line">        os.makedirs(new_catalogue_path)</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> os.listdir(original_catalogue_path):</span><br><span class="line">        original_item_path = os.path.join(original_catalogue_path, item)</span><br><span class="line">        new_item_path = os.path.join(new_catalogue_path, item)</span><br><span class="line">        shutil.move(original_item_path, new_item_path)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;已移动: <span class="subst">&#123;original_item_path&#125;</span> -&gt; <span class="subst">&#123;new_item_path&#125;</span>&quot;</span>)</span><br><span class="line">    link_name = new_catalogue_path</span><br><span class="line">    command = <span class="string">f&#x27;mklink &quot;<span class="subst">&#123;original_catalogue_path&#125;</span>&quot; &quot;<span class="subst">&#123;link_name&#125;</span>&quot;&#x27;</span></span><br><span class="line">    shutil.rmtree(original_catalogue_path)</span><br><span class="line">    os.system(command)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;已创建链接: <span class="subst">&#123;link_name&#125;</span> -&gt; <span class="subst">&#123;new_catalogue_path&#125;</span>&quot;</span>)</span><br><span class="line">move_catalogue(original_catalogue_path, new_catalogue_path)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>虚拟货币犯罪研究与实战</title>
    <url>/2024/08/05/Cryptocurrency/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="dc1d2f55adb2cdc23590e204339e6385b4df64bf33acb0f45801f5b4d4f49430">5ac3501da467fbcb7d06cc8c9d1e7334300e9672b0f9ee23fc34f7cf0404e47edd710b6cb3422c7356b7095ce39189cfe270f3bafc89ab9748cdb66ad00d9e8d5c613e6fbc9ecac91883310922cd2d6af28d2b3ec8224f455450ec99eb222cc69d334a50a9a80a1e554d6e55538bbf9ac224d418c9fae06c8d895c4cf5797ddebefb2cc0eb2340c259de4e113d8f81401bea533238b2f2d983fb3dd8f3ee02caa369a5d6b9a257f486b8a6d8e0b515ddaabb609536ad42de84dd398893a34ec8f94827a0371d8ec274b2a175db46b2e5c44a2c142a1c4b6241ba03dfa13871a3f6872614044c9f150358c23eee2a8ac2d9dc0aa1b48f322ca67c20590936774c33dd81288333163c3c305c3e96dd85bdbbb13056ba148268e1760f3e911cd78079949407813f18b66eaab05ec4816270ac39f948dc4ba77bf7053e772b8391b7bdb53f7a13ce332b835385cbe859978a14f23647c4d36a719b12c53a470a6b5085ee606fdd808688c35188eb447d0793515606f584a1bb3fcb68a36aa75f12ea6e55e899144c0eb265143831d121fd930bc3dad1a3c25bd556644c0b9574d61153c2964675c4d166fb641a2c6cb1c140522662a5796d699f7b706fb0cc8949975408b30ca88d788933b385a83ce1f82fb3ff3baa5052b6bf99de40c46c0a1104b58b465e32ddda635d46563257fd2e82e90c1b1a2b88e6439bca3fe8ad47f9a9618afc18d3b5e781ff712f5b2a04e671a72439efe221087c16de85060fdf83bdfc01e3dc0b96099bffd3a8afb8aced9064c1ce3bb9265b70aa4c76e188a6faf0cf3451d86cfa1eb6fe1956149862f3ec56b72cfcededd5bf2ea694100fc016a89349cc1980528c844b0f1739bb27b34559caf9bfa07c3c72b4eb58e231e32ff068628a12dfbc64a030c8cc4b89ea376954bf9317cd810e74647bf898b0f19da7f11386af56ad792fcddf203a5bc8c10a2c7238509a1f1e0c005d1113cdea251a33bab626d4e7a1447e433d890f8fb998b78a54d25b1f22536f3723cb6459f4f71014960465e50a9da9d4931c9a17169fe92dd420b730acfcbd20462cb6ddd0474af564e86743ec8e7e3a1a364192eed1b20762e6bd27d52408e61d9b10eec54e1d2e862abcc79e1aa8d88ff348094f1778fc988dabaeba104491fe010d15e1bd25628a838d95391686b1695dfa4db0b173546c95207bcd2940e1637060e22d0acbf8f209e42935d7cca4b1b473cc16b2a3ecba465d244b2c83c4e94b63cef7b43d67555beac89a6d0a7faf4253d03b149f3b62d35b248d367a7491cccdf1193c61b63c831af75cce18a7a6f71f682502459772a1fddf38ead8a756d65e1ad21a4497c42a84d1a21e2c2e2562ef2d9a1116e7f9a1071dca40509102edd58d5cd45be1d4e277abfd00e076296669762d747c24af2c62cbb93c23300e6b3129140a75b29836d4003962857e49657eacb3d6120403dca27b120d7e38a3030fb36b6a4eb1fdacac3d4f1c44e6209c6468ef57901ab315037c48fec6aa74b729a7ef9218c694113242d11205eb7e2e06910f0dfb76ff1463d4ec008156d1c7ff96a530ae33585a2771b916c6f4c774d677e5a5599695546cdcdb949306b8db00861aee05161f3e1d21ad50893122601960b1a6bfc1adcff99009cda49706cccaa1d474b738659918a3579c26c5e3f941097dbbba195c0debcce39be70d65db79d34f4b9e9dc4c9304d8925e5428a64c02fd8f0482c33a64254f4b79911b2d7d5ea2d1950cee57ab811b1ac103c7a1120757a622615bafd05368a26887b2ee2c4cc8b3f1829d7e641b851e23b963d322e0caf596ffc2578ad04fe57116d2b002dbfc041cd3fed996019fd98eaffc78ed0b2eabf16c08dfdc16a62eaf16286f711b6acc38d7c939a15358ddecdfaeb439b2ef9f094fe9c08e495f861f5a9571faf47fa73a2c5c3372d97603851afeee246de5ff6dc0c54285b051f3a4c7a568f296898a23dda88cd5f18842b573f027c97cfe7fc56c7a45dcdde469a94800ed354ad2266ecbf0ca1d2073537c6797480b0fa0b52f6110e67d18377c69f6dfd4fb488a7ef8a09c00b6b50f5220ea935f57d299d19641c1536c76d0de0ed43c8007dde3f2a7a6347a9602e5e2c93a7d09c01fc3d2b0d736ada5da7daa0b4d345a8d69170b0f3b3d9627777cf8a7658720499ef68aec29dde3b17fb0825268e891e7b1cb15d88497bbac49816539428d1a63f6937cb62e6a5f5709dd81693b9481b2b7dc76a10291fe625773dbca3764c68715af6673e59a73811e64a79460ec2360687e49e0aebbd9a087513a4f59606d3b3474f20243e1974acca60d16601e6ee516b28c29cb48ef666c38b6002ce8c83d5694cf77af29a3030c88635f54f6bb9ecc46f13d61be2e45a66e14d342a1230c8eefa1ddb1ba0d74a5731403a2d2687c910f4b5c8edd935ee9e086dc454edd30fc71808b547d4871b3e17406206a656ca5776b0a3eb3b568be0f335efd9c743498ba9820a1af8112d314ae149c6a54c8b3e0df937ae31f0c28574ecf3e5bf75469f93d9165fbeb66a3aa6b86b6551495038c96d507df9451d7f301ff08fcc25aa0a93682fe5a231ae098dd83a0fc565dfa02dafddec385a51484f1e17de2ede946b6b778baf74b86efd74beffd8dc825f9da4ccb2a2a7487d959aabd91d38ce308b1f50d18053c3d23f23f780ff700de8c8f56bb11c312cfa22fe33547b8e7c0bb9a500850f77b205988879918a16058055a9e1c2b0a61c907cd8cb11ed7df0c35292067c1f464e1d4d51ce61fee907ea00cf8b911488602c3d71b368cb3be363ef60a3e03e62e8ff03ea658fee6ef5ae8f76e9ecc24ff4346cf076cc99696c01dbf04c6ff2b6b8bdbfa6cf70530e0c27aacd0408cbd9810b759a4dbd8889568b7927f5b0cb9b899ccaf8a8693156bd012f1f44b91ed7175fbc68e49b094535d294b55b7f1a8912c2df1cfe4b7c21d77427064b34dc6c127cf6ed41cb2b194fe3b50c473d0fed91218abcb79ade98ad2f142f2fde48119907b0e1a316df97892f69abfdd5fb96c5b929a68e89b549406a7dc42b7b942a1a5d751ebe2e5909170905915bec1d853355883c7b4882024515ddc8fb90832ee253bb9dd36076b28214758483f793f993ad38bf45fcafc33d997fcf929557d81309968556d3726462323546759ae2dae0f26e7429da2c2daba3d704f873e9cab6e0a283f1c12d9e71bf6f41762956776a2ee8d70221eb737b57a52854fed4b6905ac56dc78e9c7daf6f4afe24ff8b4f67410a831094babb9e49dafef519f6a5b6a4b90ba9ffec95b7e20cc9ee3c7ed0462bd973ca95421c31a305d99c02ecff1328b644f7c959692a2316d56f44bbc5c3bce784204a98fed24f096fb51dbf335a921f3341d957b2c8e98f008c8c764a87c2a417a7ed2eca3cbbe459acb3fd1977a287dc50251eb3b9f0d732ac4cac9d1746ce850264e2b4b59118602222b4c5e20c3f3d346eefca2d745107b8e462dbc47b33a013a2174aa9689878a65a497a2cf2097613a99cf02d7872a2f9db95122b95694d9c85f401110535dfd8e8f1eb5402c9e576b06da079bc3d3667e35d6af346be7ca1b01b9f33eedb5a038954d9894f25255cfff078bf440522fdae9521cffc8d968a659876a92efe69248075bccca2aa6046196a0498b9b3d7de0b76bf543f09edb1e1d63b032691bb3a23bd80a37ee8f6d51655d7f1dca654090b286782c2df98dfb03ab979399984cb3d96b4527c90845df45e66b0c961f246df716f716ca055bb379b9b700587dab8c486627fb652a80b087d6521c7aa5d7a5a6c17d77a46d047e4d38b521ef1e0f6adaf969b4bde45f663c6c03fdc504405bed6b9e16497ff8986eb39c2fd3fbfb45af0b0a13e80453b369753654e2fb41dc6dbe9de45a9f4a26e71b54bd663085aa03fa83576b975fede7bad2e94c93d734761fc4fdfcf48cbe71255698d51c60d1a0831b20eed3e57192ec3337ccdc3bc4ac784591000f5bf97a0f2a2a21d2971d6c31054f33b48a51cfcc9945303d2b2081dc847d3fc373ab8f1bdac8f34aee7be5a5171f01b44f5a7b404df9fb40155008ca787f85d44a0f22765de9cd83e3fff7a92426f85c432bc836c58a0970e345e0f041d4c37430ee9e60351a601c9326af50f05147ee0852b110ce8ccf5576ac06a8759cd1947d3c2dfd28808615daf47e52754f01bb9ee58a983c8e45b2da41c2bdd0fb7f9dd4ba7d28c43de91667f98ecc30de15aa5c6b92a5887bb17deb84ab5a7ac918d5406c61326c8dc13110aa5aaeedfa2ba0cd5a0fdd9f11ced4b691c6dbded90633e60763cf615edc99a8a3825da58109a0fa5f674ed3c1f0b4a5b9553795346b0380cd115813bdaf8ecc0e854f3eee598777d6f1660b424d5e395ea011dacc24f3d839762614e2fd12bfcb74a22e30539591be1f6edabd82afd7c348bcab6544119f4df610f7f6570df8e12972204c722d758bca2157ee73c4048e0eb65e01c9825dc3f0bff8ec34fefe3b769f9e6b891201b42a19c9e54f827066df2fc491deedef30e4f8f1e309744c59c79779072696ed1464ac0d2a955058e6dbd8c61434d6e6bf02c4385703720d0dcab44f7faa6ef46e7975a8f4089a0563f1709f702b8ecd9cea6b79084d440d459624c2c16aa661606b2c7fcc92425aca93205ee072416e42d1d3b006b492e72e11b3fbea807de07f51d3aa43c6b4c09d7e3679c3610e091a1924eed0e944001b3569d643c10110db41a4fafd46328380557179bf9478c50b9faa24e482a38db6c237d977361b153761c97c1c0ee0a11a888dd4394ef970c04cf4b33b6a02a3db41ed1efb2762867620fe17b96bca9986918bd4d6384f4fb0bd935dec45d00b6d44ee5d0c1b5ff5d8a8afc970e527302cc77a2b7daab4b1c70cffc2c2fc0d20d5d03f56f4cd820bc84f04be6639fc9cc85f7a2df11d99fcad52f7774509a4a610d5790198b64527c1262723641d82bc9fc69bbeb721ce6cbb0655adffebac67bd911de0e2ec14a4b2e6479818c4c670c3696bcb02da05edb71ac55131551b8628c2b7e7895a117b3f708e0bdea5ada1327ead1b38064cb890386da27ace8947a73712f88bd851e11e6c3ebe87c372853c201dcbcd9ed311f505f45da7a135fe439e4a2040404c99fd37a5b8f057409dcbe89f62dc783a486d4881214e89ce31c391124edbb61e433543e22615dc37ab0bedb64ef9fbf8701e26daf7539d88188faae959fdcf9621ae6b3ae916f916d23ef49e5a05342ff003171d3856683f6874f17166117703e9370ca1f4f7b916edb53aff29f9621742aa915d6087f3d2feab6f5300d203ee561a330330b522890dc45a097eb0eaa79fe4bbdc3e2e48462ae6a2683b59f34791f89b371a66952a34708be3b23acfc945faea27ad821b72b7cc1d694f29a25e5cd74713aa8df1181a6ba18f65b28a52bb23efd92024e128735abc27cf207d41e38f0dc0442182c790e1be4060ec910f4e370297bd3cccb3ca33e93617b4e469d6c9a61ba78c018a1d9b88485cc025564ace119798512e91bcc732e9b3e811fa8ffbf867ad1bec235a209fd690c79fb147f99b137285cd9c9d2b1a0e67957f21165faaaa81e9264bf87d3fada2bd16d4ecf8edc42fe47839bb33695a1c7367691ca341ccb260979db8036abfa874f4e216a7c5022d7d9b9be1954e887992b5b89f0f6fe1842f65e790e0f33bffa880f0413b70b15ca01ed4595a77348c2dae256409dc72405cfe33ec5abeed4944a72df4e8f9ff10c72b8c88ae31b2445a89bb5422401006e69154415f540268a4bc57469821f699bae171c237f08ed1828150af5b24537a6463b6e3522a9dab8faf4705f9e085007be934ce9f2a684d2c76152a4af09b8f14639d927d2cf6c740e22a719476ccb4d83c68f370a73866f31aa02bd876d75ebf2cba72a4cdd9fa622a618b70541bc484932c17bd3db0cdaacb37182767f740989263637d87564f1a5b0caebe7226f59f303975f77e6e53b8d32b60f379c021ae571fcdced1f6392d42702388aa6712515eb7ffb84009a72f0c30af2114911ab647c26a4b1c1ff162016650a0a2f8478b3365ca82da3f8d44e702752fbb8d0f25291a9e9927c2f2d8293dff44c27d3dd725ed9f3a43b07df498530b8ddff7cea18b16dbbf8e5b1c2738fa2eb9fdaa69b71d7d7d89ade36236964392344423967a8dea220fbaf6b93d15768941a5e79585921bb1a59b7846b4560ebc11b08217f7911f1807204270d3163ac9f6377cf845f8373f736f1f74f0072440bc1c4f369b78737307f7afdfc3109fb8d3e481fad58198253756a834ad78fb4fb5a3a320cb1115dcac1ca0e48170190f6715e32045be34102615ae7e11224f686892ad22301f70fac097df7d0eea17fea1779b657c01a730060d592691f4e9a4c18ac0ccc3a3aaffb4f035c7e75bc245c2104624067aa49e3fdc5982c1b7742cf8092c5564a95007c9d2c8969a937ca5a6f3d18b726e15fc37f1a02b7988df7f39d81c2dddf61948e0b1cb333f165c4d3b725d028cb1ddcb2327a50c9d30eb6455e8cc1eef84a87b6770c6e4342377cede12a66046ba83dba083bba86c2a57c3b863258ae3c5fa0c14fb769b42d310f0cde7ca994a566eb648a460a5fab7f0e0aa0b18b0bca0bd208afd88b47ebf2d9b393c93a6e3e2469a57f6443ae892a639aca97cdf38aa9ed58369789db232c031599b9b39bb84b5ce2e0ecadec75ae2b19ef837a3f8c9fee84ab7b500e29f54f75ba8d105ebfa875bf8b0aae61561b81c44af004d323f5fe55a8e49da09e106c4846a40502c6d28e66b7a7f1e36747573de4a60416a74b0684330873dfb41f17831c8755b6c34c0a80be7fcf813754f4048594e35eaa2d8f7342e16f94287df51f088d312444bebee28ef558b1bf5dcb32d97cbfbdf6b324da1021ad79f285adfcf231417f2233fc91cfe739ae786f48c40fd7e52653b6eeb11fbecebfa837fa5f39a928b07c042d7869b834cf1ce512da72fd20cf1ed20983df6a0dd341be6bc7a77ffa817374fad0bcf977e9698f2e920d61d62316e5b1aaec8abee63a5a93198bba9022f854e27abec27411ea94139ec10ac22e09f4c6218202b9693a1d4671877ad3a63f790aaa51137ef13d98605a12916a49de7262f29116c3a50a06bc7a749c00966386c282fd25158a71d50fb4c36d056d6b8054dec351df6d709b7c66c423f70c209465d06eca5faebe564ddee077904705298a72d7d2980ab4b4e6848f5396a33c005dff227f5f00bb647c3dc0e2ce68aa31292b0d3d1886ae09c89082176f54362824908dc24ed8771f5bb37a6eae55208c074886eded56ffd08ef990259bace541a4eb39522cd33de0db3cea3288ed29b1d2bdafcae356fca4dbe75a97d4026a9fccf5eed961d50e6b2cc268edecb3f06170f4500acac0476cd08da7b6b2cbe2d00a8cfacab943c5b5a507ce6cd7c6595c6740b621ffdc862b26fa86e51ce4ec365e89ebcaf63eceacfa83cf55761066c77076e1aba6e6382d19f54a72c750b2960a440f4ad7b09ff999159b1d394fca61759d78744a55e955d5a58f585b19149f6428fab5b11a6c333b84edb34ae59a09917a9b4a0439a11e4a13d078c1f89230a2e3f259494c08ef869c13db7d027d3bef9c569dae7a4239198d21308588cb0e8894100a90fa2fdaa2d8ebbce89494aeabb267bedf0c32c4a07a659cddc74acc0d23c37b128e61bc2949ddbfa273bb41dd8a4731eecfe946f33844b1140bcb85b801504d6aeb4bfce801a9419b0cb173dfb2e50f9e778229b0ddaa96322003d108356a116d41f44964162623990af1a95517f93c48adf92088964cfb0e2441947afa5e03fff19fee021a4d73d339d7bc46656c66fb11cfb9757c21062880cbd3e14504454431064b417619309b1f4889d253e11419ffe0bdc53f75c5dd79c8822f64bdda2bc5518efd0506cc9f4eafff17529fef6d97ebcbc5587126a5f87e02e7c9d8b98fa05738bc2a771ec0a47e569234ea208016e0af176e6a6dfc72d430c6a7cedd82268cf9910e8eb6c27b4c0caf82654bdde2ed0842267d6b6db214832eee7d968d939349cc0361b3fa3cb2aacb57082949110db9fc479c5212eb5fb8e0174ac8e4c3a224530f910cf933aa472ecb6f5e815af71216502ddaa13b1dee7a7b8cf8a2c6147ef2bb0beca80395d18b2777e9ae849b39030b633a73d3edfda26fcbb8a663fbe9d0408334c9be271ad8ab9b51680936ae2748dc324c5e85c0130b6edfa549668bc9b770399de92913e8e58b191d4e2fbc2b5ab2b99a799f731575c135d44aff33ffbeacab7954255f18463c1fd0dcea938cbf9689a805dd155291184deca2ecad1195a413caf2bda1fc07a9a808ade20a2e9ec1ac0b04a1b037e2577893e72af8a617efb53afc6e10941b74b99820fb94c1d69309a66ac9efeed6e03cc561603c05dce67e0d57af7f878fab376ce441dd75469b45e98a39a4b35ebaeb8d9a6448dcc59c58ae929e6901348c9fa35d16e0852ee6701badb41803c1f69036a9d5c29e6e4de8d71eda19e9961d42fd6c759abcaa0aecb608db49fc547950dc67b2ec399abe73bc3838afda70d76dcbbb3364db2d0121e97d4ea237faac150052ba8e3fa7cc3b96f2e5e626752b4b29ea0656d31aba59a91e79acbee230fbbbb2456b581123efab7310748bb06d8a852de8eb9489975f38bd6b0943d2bab3aaddc5709058bbf104d52d9d6bd611a6563bfee47b2a47b5a628ba7b73b0c4cecb7bed020c71f439ad516462d00415d7c1816e5721a535eb27eb87af4cf472bc0df09712db4b540c3a90d7937fe1a7700b736983cb41167b7ae66b363b7052e15ddad5caace390c20480195d9bf436f6a45e0943e2e9b218d45bb3215c29f2968fd44668208cea3cf223c43ab7452a8d679e72323befeeacc760c29876e7497108fa1a3984935f54a14bf6eeab995cb10ebb3c0ec73ec96b74068af463c0ca6cce1426bf971d5741da2e40af0fccbbf659c5239fc15d5e6874f53d852cb8269823d9932233a577d68964d6b04911006d722ef5aa17926ad700d43916b096cc9675ed796ab87446d1b2739d26a1563d493ffb886c7e011767eacb402e742d30e8ff3a948f557fe1e4cc2d1101b9bb8b4c7974804eb9832f147fae3117004ee7afc03fb87b697c06ae62ec0960f93f011df9e3203e0ae7ab0e5763a4a85036a2da18e6f97e647619f25d5f429fe4c58b1b19c665c411e5a5d80f008cdd0e27f1415fb53cfdb503fb84c24d171c82322f115f8d95e7d772fcbec80a241a3fe59ed8e73ab5b3a9dd64e51d5f910c9470a77f7e78ae87f709d94d9821b272ffd16ebc56d7a3361b41c37bdc93ca2f7b19cf0afd478475383964d8b66d251eef50c34d2f92bc0a7811d8949b9d7ad1a3e1999df252b49754b40fa6e69af183e73c3959128bdf519342ff43f7087ebbdf28fa9bc1e4f293d5d07d665572317f1ad330da9cbebea53c0520e3aa65bcf80ca29d1d5eda1a5f4ae434cba0fe486f7370eedda1b601e46234067e061111faa14cccf4ad2ac7736b5b95584ec73e4bc68e51469cc05126d7d82de74eef3fdb2f15484126fc12094377c3a4579e4a41cb92c979583bb224132c343e459ff11cf27ebfb539082487c072851449aeb8f5f2a3318cb2178ebb4f1da13b1ba6e8ef1c1d0fd71a69294e5e57c20e85dea861a5ea2d6834690d627c2567ab13804d20b33b73cabcc62f9bdb2b00c9f15596cd78b913cddca5f34d4098f4c5f99d5dd94879e6b7924ab6f9303c14f18ea38ad07fe8c5fae8e5fdd129011cbd0b1e9759383dcd1f01289bcbcbfb2d0ecd5b38639a3f5d93eef508902fb8f6ae1f8347aaa02940632ae7676951c859e5f39399ac9c954f2415d8e93633f04df82d402e34acd22bb022bc5c6d2d4adc8a52d21ebc07c43fe26f79b7b3f5a097119fa6dd4bf3ebbc5e425f91b148262fdd8f77e2e998af7d7d2fbb87b5ff5b95fa8f2860ac256b40694c450f715848278b35188dae19b4b16dfdb65dfac304df51b7a9ccc137ab76ea19ca9d43c91b7f858fdb7d31261e9049b48bd93433aa502cf731146f93bc104f70c0ad9c122dad53eb6e4412d74fd4b8ff2d7187a5005434cf7ed7cd99cfce83ba34fb3ab14a86ceffa2bd271a23a4d1a2b5a60629f757f858115a382ac4d92b5e198dc6bc16f9f8347704302bb626cdeebc9a887816ee2c3a7bce4ff06151b46fb2c7f363b5f43c8f81ed0798ba8cf8c1faddb9f0a06cc26ecef0707c6fa4aa8ee086aebb8b058e41051a6ead15aa22415fc8b8182c8a7841b6d872b04dce261340d16924819b52213f9ae9c3bc26b87a5f6da0de8ea84a1745d3305311967875ea02ecf972a19527d7bf7ff9adc9cfd24358032c1801d4073395bf57db973e0ea7b0b8e674b29268e5516b80e3f23d23ec7c4bed6f3dad580ef2c25f4596722f4c4c21cded72213d4bbd1b27d8788a0c670b5fda15d24bfa6ec4baf4a42f0cfe2aa86128aac719fc75acdae9ac658268e25cf76c590c49450c7c0d60b8f3155ea8d9333139e866de7f934c15217d77d0f2667660a16d0f17f65a6899577acfa451ea1d78536b7e05512b1140776d34558337cece801cd7ecd742f69fab6fa4a2f275be5ed74a98a83219f89650a3b3d0b8668b5be6af49a87e39acaa710c3fefb82af1de7b15f24cec59b85c2de42d9a7d4a1f70f5002596681025a5e96ab700d286d29af9f8dbc498581529906606f666db43d3fa85c701a87af956b533a29cc55d35021ba4f5d9e4da0162d4488c8ecb5223620a3186804c080cb6975bdee65dfec3e9b768c00876e52ce8d35f43f49d5a5c569d8f4e4b907ed9d75f281e0003b6161438f29f0dc389611efe59f3e6084e49ec367392bb4ca84d858e8c51a66894ab7463073ce98c61ee45f014c88030bf826c014c2f6aa354eb91b4e9c707eca7f68b640438ed87f8e56ba3f6660456612acb186239f8be6a4bfa2ec9f5082b75775eb85b3c4f20119341f76a8a6f896638fd3449491ecfe93252bccf8c01d78da3525994aebedf8bbb941fa908c229aa4fd93d72189d8c12b8ff0a8e45774753bbaf02db11e0ad91e7d1ded2d533c8fdbfa3827c3d15056ab503abfa40f6bd06c001ee485ffbf5aa7cfb91bc70fb8341f2022ba16b0d1759037500de3a30a2338074cb970ccd47692a2ea7ebf3d46b34c3a0645561938e84d77f2041b87b66e92a590619872fc55e233a211ea0aba842d92a12482b2b79b703e436741bd2994bb161fd64516cb110b3f970821cba2c2151ba8a29102e0541527c117972037a176c1313d2746d11963c8466e31b29528f8fc7d547fa688f30564aba8c9ab9210423ca81789ae587c192589025941ed69e89cdba3015663081a91a0e7b6aa424ee9c62d7152297c458a1d1c54df1d432bc1011d6672678e67a0052a783bd3ab13776eef538db8ee3a74105ab3b572670302719c66571db27c892f8b7c9dd467fa5ec9d4b54841837e4336ecff4ac9c2b3bca3f9693db3c9e82a727f9b4c882d361e84c3ac31f7a43855b81d9b11c69b20af27c35b2c67d0b2e49dcfe07ba7d6194c00eb26322b4eeeccb76d38d67aa701abcd21fca9a5518c94e4cd57f7d2b274ce43f396a538d1389b6eafbe36f9d4b0eeccf502b89eaa1cdb36bf1623d30d18de5c2d96cc3a4f7aafc8fb192d0d3c8729b999f6adb769fbececa7a95604f7cd041e76928dfd430924c31259fece5aeac3f30724b7a022a7c004ddc52adbbcffb93223056cedd6a1dbdf9e5e2ee9f55fc2886dfbcb0d908c93d3bb81c35a0e3871e1fae4854a9350e4c2e83e267606a19c041b237b12951cc101ccdeaf4f8d1c181769b95321e2f54bf1b35354f7be65e9db36b24b73a97ed388c3e37546609a25f649c695be00c87ead053ab46581e232a4acee7554511c36662fe7e888755bdc4d2524cdeabf3d89fea9002a2277f27524df36652dbbfed823863b40e4af8501599987a656e2c72cbf2ead03c5af6c0592ee36c3e5d4087b72abff7215eb13084d0c0b1b6e494381e87b62b0d1d7cdc97e04449b2ecf588c768c43e1b1466bb9740d4a90adcaf9470f978b757eac1d99bdc17e019dcd00d6ec619772c3168419b60fbc0fe4409bd2d181756f1bd0c4c0c0c7a1987a164fc3d32682a9dd987f972ca81e6a508bd8b0aa5d3c8d18dc43e1cb8f434e0be1b53b4b070b179f49ba8f414f8aafc5a5487a379635f91974bbcfb487deb55db991bb7014889ccba43b029c1800c696a683b0ff2c72bbd50edf327c07e741984d2338ce5491a02543a5d243a3200fc0b3cc32b2f03e89e897cfdc11cad58d3aebd0c353f8dce1b1c5452cd9083933e64728d5e203efa8d0a396fbcf0451d908bd1155914cb117389607678f70246385a25db74ad1dd01576e5d5d92fedf63fbd3ba30b8adf885d5a891c4a6729fc2cf3514c4abdbff10a2aea6ad168ba07113b419177b0097946556ca2914455ce53c29ec28307c2043c3e8074111c5e94dc3237e660d04c7bd72348c83859e0bc1b038aa959f3980453ef0133060e312b6a76335033541458a35b37456c84cc8f119e1ceb5b9af09fa47f249aedbd1faaab17ed579c2303843767767a3f65593c2760167c1078e9cf2a6a38181f9bb880afae7cfca158fa3d4b9c8a3291e075a4de81bc0ba63985e5fe51a6cd5a882cace64e65848e27cc7628e2e81b5ecf1c0f9fde89d4dae8ea0e25bd1d629ac174176a6e56797880727936662a968442aea9b6497815d5063225b3a46ca6251f55fdc05140eec52b79eedfbaf90c20c3db405055d309a42f27d5bd233e80353bf60a3eab3b11db701c28cf45d3ee678855e6e3aeb636477c70c9dfb2db5d567c950f71fb9e5efa9605de92929a9b79efe4a16d35f37a6b7a99c2e9c24edf4f1085231ad7b74b8ab290f693c3b880191f510ac70d2f31b2cd14bc01041d77a305a595da3eed128c55a7bfd0b65cfc9f2428b102ba487d5cdd6133550b1ead1828ba45af3b113b8d8ee7e2d3722c0dc2581342fdab506a7b73e0a420970b7e85b298aedfb3190310c26b393593784decd75526a2dbe25e6c29f0c534b38adf7d53010ba08f36678ac6fca04ed20567780d304b64d4f7fdd0426982868b253f0bb5ec32e908986ce4aa6bf309b1ffed779b22a2a6dca5112a2b590725cf9a22e70ffbef6b2e5d27a184e5bc66c703698b98732322c3745d08f37a806248e9dd92876a14fa87be92808ac1474d7dacbff2d2bc13b0605634e022ce1d8fbb7c8f9e1476da19ae33eb40b5d84e5275702fb158c7db168ead85baf57cb3a96d85d07b528321855c604ab9a2f733ca44d58cae942b3a3ae80a29fc403c5f013f88fef955fd8cb64a33cc490168c1ad568e25385e4c7e32f4971849db7bc000e6eb5d08d3e60749a23cca66263c9a694312989a2727baf17b3e85e7feb5513ded99317e6eb458f485b7e97a2746dba143547d949824e9e97247723eb0f3d3c562069ab5e56ca64facdac3b6cbbcaaf5bbc034b6d372e98c8b26dc82624df6945e1dd4375b911c7ab29003ad747da8ad4bc81da1701f2f8d450ffe835bbf35d1b8197febc173ece488c76d3dd2395ed4699ec763d22e1f72a224133d6ec7c52eaf0a2197edb00d0ad39de00c3ccc4739d71cfc2a65d002543ffe7f956da874b0a927876eea0f642d38a10a388bbec761f0790bc8cfbc0275003621507dc95683ce8f58a11b5eee5077cb4b4d0c107ea975fa4aa8630de8f930640f14cbfe0f3889e138fe98c8011736ca207912f3bb738960678cf85645a651d4351b1df8f086e3272bc276f35118cfd6e08a867e9f03895231ce433421f888adc18559b328ee9986f89cbba3392503e7a5b3b52a0c1e9c9204d6efbd8fd91a249f13b0aa60d60ea46d9a76f5f9ac4bca580127b1e5eb55e0729e3aa65028b2cf8ab2f14c61e16a407d1fc54858fbaaa637105060f1794ea9d10ea6ff661990458be2dee943f4a37ae214ee319d771356d9f1d59c323098b632037b7e3b823ddd3cec02a8deb6676073e4623add14a04b97fc7c1d80d13b85e96b54791a2dca30cdecafbae861e7dd882cfec8b4ed3cae757b2bb5a3076a5673a144c385494262fcf02c4b5c9a09eb02289812a2ca0cc8106ba3cc2829cd57fb2b6233dc2dded794dbb02cacd6580c1972e420f27f20fc24bff36091d44132ea98022faaa85ec2d9cd910ccc51ace79accdcd104f8cb9657b6cae4b12f1fc9732f12c4dbbfef34487ef8622023b8c3e233bad8c3ec5237af2105142da686ad136da7b41c5b0b6d6d0a647fdab9e5c248368a919a65c598ce3dc945b725ae60bab26a3b7d54d698e87d22c472a148fb0bf6078cf1e1108ff028882507b6a2135662505b7da0db3b4164572f0413a8c6ecdcc97f9c2bcaa542843a2c7a05e5f86a9bb6cc421fa1b73aab24c6df476470f5eb8ba3a5e9e6c71f11f31517e139b3d3143f68bba3deb416a2845d86d23f98d484257edb7f626b5b3023cc086b037e56f6a7cc87a2e426e7dac9c656548f0a712e8e446b040f769c0908d428ef576723a2cc0999bc0028ee2492c171c2d7769455b08e8bcae651a6328678dff8cf2cef7bc52a244e9010d77ca980e4d1ec04f34a7286a2f2260c23bd71404cb5f2c8d527b59e7262c8ee00717e19a626609ad1738f9b15830294d52b0c038e381bcc542cd56633385f6f22e9746cae61a29bb338eb6f5b9dadc75714d6e6fc0954e9246267f549a30f461403bfe0bb92ba24e637c2111fb9f87db3491371b214d017201c55a4c737fb4c819f508cca4f04eca545c65d416d6b077dfe562de0ff1d5eec65d1c69c2d7553282ca24ab1cf85474bb52e7cc8c534fcea23f86692ac792be28ef686a9b0a67099c6585db0b00d68510392948dcbdff81186862801623fedbf9cc5935156f2aa1146e26ab295e4c8d1efdfefb86652ba7d5b0bf7d8996e8008abf4e3d0e564ce81260cd9dee3ad0d349026608abb5bbd356472a2b760e67d2963c3b6a6095ac1b03ac11fdf2b411cbad5c905976dc317a442f5cc7af462fab01a37f13350ba9cdad476e76cc8a71fae8a7298ee2ea8c8dde0167345072035aa46a54bd71084857cf57bbe0f68a438f91c8690dd35f278376756d9e05d83b0a28b3d0e8e6f114837125c56982b000dd10266795b3aa246c0f5f86ab37333e497333ed1883dcb3b1ebf962972c6f9a0a0ea53f3edcbec50c027760db4c892fed6b2af6d86c6ceaee7b771a79343d11fca42ae7243110f770b7250909c115e2a3180cb03ec43b1865037a54490cbb5aa4ceb5c68b402dd86cfbbcfd2c92c5ae61bd8d830f45ff04555587c580bea51f502781c7083ae7e82ae06aa3f7c5e1d17f38a7ecbb5ac30a9a254842deba1c636d695a7ebbf2bd87c4b3cd14f8c453a6903c8853eecd6434d6dff542e46371ab16e863396ee8bef270b997d1a1fb946b7cb492b1e616d87f8fa3ecb1a6f52bc1af626bb57814a670a3dd47bb49f22bf549bacdf91c9c48901fd4ab03293fa0665e8e0e3431d6887fb0a7592d56412eb9853e861ff7d57fc2cf56109d6a00b59094c4022356a4185a52091f916c95e91888a7f690fd11210cbdfc52001cebc06e0352f0ed984e9954e29561f027d77d749db5d9e8c401fa3a443a1810e5d5ae4904f58c1cc2bb4eefcd41ace4bb8b3cc942c71e417579f2b9e6b5a03238afe4873c49e0ed0a35667ff348924dfbce108649384c2b76309ada068693d6fc1d5617d086e30b580c2aca363ff21a6b08d8d11a1f82d572eee8f7b201aa4a4a2e6ae6474e61ab50bf5978d68a10f660d988aba1f390c384989855ba2ebbe624ea0c52fcdf892888861d5c6c82839ee52ffbc681ab9740387efd8d9b7ffc3bdcb8ec4bccf7f394eb2deef2c4ea00e5732c2b3d4c0814c54cdb59ba2788441e0484cfe3a860186a111746e022ed30f592911894c51fcd6b3ca23c5cd9a0596c760adf214442555f3819e8c00294e197150f3400b722c6e98a122c92ec0b838c31a374db83965eee1965da283028616bc87db64dea5db5914a286cbd2f6ca1a26d4f066149f8c5f7cc16f4cfc4a7cf213c8ddc45bc8e4b842c273a3d1914de1b5cab923482e8c1521384439f0a43359319f87f644f433ac228f033d8cfb07e3ba34cdd378d26fe598a4d0857a879b32ccd1383585c5bebabc1b55f90132f53b4b24b3d74d9c2eb122e67ecc99de80742ca4fbe485083f74026fca7046932e7907f67eadfa17f146a03875abf8b560183eadb89852a3c5f91b91599ec7f9356ebb374506fe7fad0abaa023aba9afd95714dda35d5a7f5504a3b03f33d6dd3af0354af6fa9a235b0226246520e2804012902ebf9dae313ac067f459de71288229ba54cac867646de2343877c4f0c75b2793bb898ccade207c9304da2e26444ee23ee7ba02632400da25687ebcd8467f8008b4fb1725d991f050d8f466264d3a8a499786c49adb96d760a7bf03111185eb8dcf128e0303b89b8d02bfbc446b6312c2a1cc5bcbd005ad75567260adc1759cc5298d3eeabdf2b41140677c2030a84285b6b2271a00364faad4bf1c2cc862923b471da24cdd140b88fb3815c5fb6fe81b287496dc2c093d6184cc8ef2247e2bc8f5425f29b2d8c65522d56988ffb866ec63ba09f4f7d9ff4405aae816ff0424faf0abd506b0dbae4d45ce21f7b13f09013edf3f3a85a15f293742cc41871b8b4b77c4aef82cf97f1b1b2e63f555f7909744bf01cf744bfb051c0aba694230606b45ce329206b5e7e30270ee7959ca79ad9e5fbde05a32d7f360b442c0b8a0228feac3ff422dcbf23a04ee0c9425d61fe04ef78ad112cbf4bce6f78493217f3bca7919f13339db1ae42baeeb81805a8d66d57c18268293fc88bc7cdcaea224b0e6eaf8cca63eb6b79a5af43f0bf5f7dd1d68f997bf88e99c1082a6c2ca2491076f04287ecf74122551ae34a45e8e8c4e9b852b4055e68493d39ec7b829fdbea98a8637c611d55c9cb61aa3ec00586fe3262eb77bf7070479eb838baf9a226e19fad56303c79e1c91d28a0d9b29ea1d42408892dbf96f5c152178ef0110641a82f131da1e140ac4e24272e73be9d4c6c5803729afcc7cc61ec767aee60f672a81ca3cb34150af77f556665a8d67a52476dc34e6d83868f5d45be25f50c09802c03c1833cc309e608bb9a68e783458b20daf9f67d8b3f53b9b23f54ad306044666d98bd473e18c109c2acbe4c25d07a226d753efac70aac5a06862dd221643a48e76458dd5ca587143a8ab490e9b05f60f82d4535e8b21b20c7f7eeb289bf8070372ff05cdc4e5128c7a5976c3e3bf3213d6d32bfbc2396a512f78f7b1cd32911ec5a7f2389b8bea0c272e19519bc55381be46ded79ea1095813ead5dfa67e32e31c2c93e6924eccbf44ae52e0ec5e847538ed3016a9e9c4f14d03cfa8d861ca84b5b66593a4a0d864f406eeb3aeda31d239f9576839e1b5f6f9dc5539ee8fe44dea67671ee81b49dbded16e2e0af3a77192019ffb163a1ca5356658e61f755f0bbde213438e2a29afdd54a8b1acfbe589f17cf63e344e0c2c8f6aa12ae978d8792e70eeb9734b0d2251f7019ea7461c1840c69a7c491bc0e9636a9d2be8a6011e94728cd14447dce57e86f68f7973ba0265db4b401e781e961934a7170993292a51d5e416dd143ba26be94f12cc10d5af11d0b531e9da0c4d3b6771289ff85621bda76adda63089a906a9fe1fc5b8c8de3c5610aa952799dbafd2903184a872da1351046094fb3f082f3da5ded31b7bf48af77329613928010fc90ef5241bc88ac1c1b43b3d1fad6406d4286a9cbcec062e13105d7a9e17e1ad0b1fdefe8ac7518f3c9c35fe3d7c08a3182cc21723d527681e6a468359f133eabc17bf6a90bf38ba21c81351db8119e056ea28f32b643af339934b1364e9040946114949980376f6b1aa05d78faf99122ab7d6599076e60bbb2f71af84f9398b00657fac587b77b833d07ea2375447d7fc15eb317fd797aa7056b04ff1b8aef2eccc22a41a322487284588ca34770dc4fc85df489339f58378702e8f749e8f398395837ed3b371b0ab8f216619e87dca45554056cf67f5c399126a45e561b4af15221b30194dac57ae910ce91d7dc90f40721930a691b2820dff3e0512257e346b24e75120dd2b93b01ae435f1111a260541bb69cf33d4d25f9048abc29b1d82283c157f13ba961650701c394ed3c71ee80ad875573cfd3b52d31633ecc0a97d3168e51621c1205ac6c2071888b5e721ae9681f4068bb1d267048b5319f6e8694c5e0265c0564795b0e4cd1bb3dc04430f635fbb0acd72209891a4dc57b9e4e67c184a87fc2456e181730c5f518ac300de6adbe61c26dc5ee3575948431ca2960ba0ad77eaa32271b0ec9c749d186f49cc8b9e7098be9f56c450362d9319fac8b30083c35b6a6bdab60b098da5b05c22e8ca8d3e2759681f5136df8f4cb8aaa4ddf81dc4157f94d21ff9135382e91bad56299d7a8461cae6700d704f5db506dab77ed58dd8a55b361bfa2d92df881508b32aaa034ffea516a552ae6dcfa2f4bb2cd838e344f5f7c736ab486c064f863f2bbc21bf431d5c22a8b7b1f85d89b7bd77053f12ed6aa8adb186947dec9bf99574e8a397dcc2269aefc24e4fbb495ca22c60bb01944b6cfdd2bfaac8e43d208771affdac756724d3092523fb2c4166a2ce1574de834e97374eaaa241bddfff079d0b186737f0ad4a6e07d167ced6d323bae98c06f11f633f8cc20208e1acd7e331b0c351c381aae04493bc5cd9496f384c416d761af11fe44ab6201ad44fec3c3b6e4418f141bc2f99ad7986bd430463d303b00f93404b3c465fa10ccb429597f82acc89baf436f2068273237e0517f3cae9a5b10c2eec9c6c4a35283e89c23e10d51745883bcb9dad7a91a28bfc87b416f0518ed97570a9ea9f5238cccead33f65d412fa509aa559a0d4e387ddcf2f8a028b8a08e08a0f015ea28acdc27a511b36eacbbfe6e6901719a0a86a0fb2fc816dbd4a973263905a61da88be16c229911b1fb361cb06d01cd5ed9b82e29951c9ee6affb79d3884037ba7b8c7e7f1cd585b35221ec3042ce6772ae632782a090de9c4066ed958df39ae0674e8b4cb76c54cc95c80141b224584f3316fae94fe50a0398d773b8761e7ac3351e156f4b4ea66fa7ab502f223d9490096251bd0822721f91c42cdda5a90c5c9174f881b130a91afad756b798466b0872b894477422f9ed1d330f587d04668de43666253d2e7a654a08cc4041fcdfcecf931bf32a58462a6fb71fd94dd6fd1625c0b46391fbad8a4a013d7b81acd52af4fa491e8633f0aeac19bee29ee4360792a9d9bb105343e94e7732ea5a283bb3605e7eb9f2c9c5d592d02afc911fc3506c3f16df1a58352a5fa8b600825d406c0b8a775f29dfab1c31ff4f8a0fa15b23772e7e4d87ad808ab360f30c1cb93137c9a5c228967e33117077fefda01e4355dba935ca5ecb63a0d1e3144459205338937cc32d97ee64e870765e972f8b67779a2c728a0530cb45170a75991523c59c2bc9be58d442932f42922131f0346893d5349bbfe499bdf6596e66abdc36d8b664eafa6679434a44ba1b59dd81115157bb6800913fddea2f36344b627914fba908d84b6d1efbd2aaf76bec4cad0e4cd53433d8b313404b39bcd7bb7101bff7088bdcd39077432aa506dcbf247abe46408162780559433eae01bcf87998da7b3f63de45635d59a6cbfddbe4b70c5f6116f4416c3057c9f093551202c47320a4bcacb2cb1f633719a9dd4cfe1a0e94588f4e923aa3f140095fb2b15c2481ca0dd4719b1014fdbf063a818fe58d152e5cca22d4502cdf0effced1f90b9147a45a7cf6ed2a038794040ab710cb001d638359683d91fe035e04239a0978d74ba4b39fbd7bc26abd9f0e51384cd4f179e98479d0ff6b29e2fb6bd4531c36a78d45fd4911c09edee2942f51b2ed316471edab1e01e3258318f72702e54794bceae7f443d9554afc8de97a7173a3a267edaefcaab13ffa0061cbccb23be429c70308e568d3a9e3e343eff42de34f34584f6920620cb1fcbbd088306cf3f4d2681b7a5086d82cb8eafca9bacb934a9d07de0dc56eea6a73dd7c2a54818b1d4cf59a27183f663248b1a571ebe765cb6d72c8ae3a9e4e5091154bbe28a9981ad4981225e79da01c51bab8c095d30eb580683055a3c91716ab1382a8bd185fe100db2f6a01c72d35fcb9420eb07832a039e8193284a23579e482879a5a69af03f20e00d1ba170c36eab8cceb1bcd620c1a5c758dca3e8ca063583c11dfbfff0b1bc71e243fdbaeab7e78c8c4bca4fe0b66df08b849c405eb948fd08683987da72b0627e2b8502909409c359cb9ac5e7bb44948d8ecd026fe3b150cd4e2bbd11874ef70262f80fbaa90a78a784c92a66aff2f571c6a80742908edbabf07623a2026160569319012c938e92ff5c4de17bfdac5e147b9a14cc50e2665cfd997ca5effe3e1aad3121c4ba5722774d4287ec99dd9684331af327af4b16c35e12ac1ea92fa235a3b3416881c473c24b4da90b5255732ca0f8a4e8b1587acbf0b106c949096aa97d662f1727a5a27239df96f7778ce474bb81549f80dd66e761f9abef482bebbd717a11d97c868fc0c969bf7ac4bc16b8ea12aa52d05e394632d35471d9f0044203ddc895bd8c9530e5e9cb0eeb6fd7f9514e1b2b077f8b7ca2993f2be822da5197c5924bd5f27cabf92ce69ae5c9a18a3f060abbbbeb8272bc47baa1d06b4afcc950f47438b1e46a9632280fbdd4070d3a10989a912c6bbedecad93c97cf108f1886f9f043b271ca47efd7bf54182015c7d5a0c46138ec20bc0cf3c826e64916965ac27533606342797720d2f17883425fdd50848a6f055aa2a5ff6c2c2ffb75a9a7e5b26c3d123dfb4da71fafd515de4027c53da7c8d2c07c94ca5fa002b916d850919bdac1a4a140ab205bbfa3d236ec046aaefb2962a60d566bbd4ca4c1890c5c1cfa35f4917f3b881232496964b2b6529d6bed9a52dd014ef801aa9325a9851c791d6c13e568e54920dfca1393e6f663e418905e3fd05d30cfd7f4a4fb8e917dc98b77ec74fce3db697a57b4e39fc41026103057d22423cd7ce95d2cfb7024da287aa2407aa9ff7808be25da33d4d5993db3d4bb85fd56f2ff893b21709845d6345863de8f1bb2effa2d09352085a2dc457224c5feb1f75197a8c3edb6d7d5b36a7fd21000981e3f0fc07035cef2b7adc6dea757d2afcffb517a40d81cb29a2bb990becde5d6644761fe5df1ee11940cc2dad8acd84ef47dca91d3210053d9752b9cf3824bb72e6e0c5f2bd16efacba60e0851cdb124bdba8e0a185e03be5b33ab268e7dd8226e08837e18f935194f6e7d134eb8cdaf8ba54a357c763de8a9be2e4d353b78a70cbfa778e0d9e44f811e33410fe72a5e9bb8f40fff39aaf87f7fc878c22985d37501c364043651eabf4f902312a38f9cac3082f9a00b2a7396aed2310f202b220218420a8d7089c6243cfb32058ce03947b4f566e74e1e34273d40b3206523a80698ffafff400c1320ac1b8e79a5767fb1ae78129bc957a70cddc7f0244dae4580c85b7c01b3cab2b7115aa00079b50f2f2582942361c929c8e70c570601c43425dc9568db45f8f3f651b6846d64db90a7d46b60deffdcd9b2eb7aed54a01ed7b8efd4e6d48d1372f947e9d511bef8adbce3e4a11cc5d74e9a0bf530ebdc51c550f8b074b0aba40ca4e55bbac5406e812cf2eeb19303ef8003243421a9700d038423715de1824e9870133c7623b8174b8cb45117516280a43472da13a3e7f9ed86d0972d046edf4dc36bcca88dd0225c27641dabfb6adbad3acd5fb718b41f49d7b70f46cbc284164b6493c2f83ae64e4e348670c178cb42759d4b79ea3145ba6a9f421236c6acb12fb30484d7fc9f8513d02b9dc8c10bcb04f423039ac5bf0c25d41f9e8843bc2cdcba42d631e3b678e762f2dbbcb31f6a71eb7f29ad772e031246fe7b0cce7e161737fdef34405127998df3669ad1b979b302d21b4194179e8c7cd5a66b394c2c2a98b9f44deb8e3b0ae8c843563d093dd76f9ffc60c90306308c9cb71f2cc003fc1f4e2edd94a747f4bc9c5f79e293e66a151ee54841b18d75dd2151579bdba65f87495fcbaf3c3e2b4bf4ed6aea50cf686b649e52e34894db76f33340426640a01ce0fd9772ee1888f2775cd2d5aeeb2ae6d9da623920d64458cfb6a5ae4d3c5e2e6ade867b8104af80313b8e339c41aad1af63a0ebe587a40142b2c82a9f8393bc815492b95799ad6cd596152ea9d6c91af6c4d4ebfe617783d4bd3a072a69327dbce1dcbff00476e19f82268cd63324406a0df4643632a67a3dc6104f6db18fea2d05104f9336f75192eadebeee16ad9536a7dfecb5ad8557151d2a6887e7640c549b21714db9635d1bd5bc8a5d040723779898e3b7fcda0ab30d4bf8221ccb8b5a5ba45607428f785df28ec7b4c2de59a0af3b211b9a97fcff99556426a051e240b3e641f895e6e8fb8b2676647d51410c4fd85abbc30efb9d33a642966094d9b7da203623bb5044db650dd10c24ea956656c8a6176f0c7cb8cad621b955668db1db7894befc33b1b643eeacc5d0ae27cefad3fff4120d96d654f4520d336db8664e06f5779898cabd11553d058d16c06004c576c90e03c868a7e18576015d68868780ae49ccfcac4be609a4ecae8ec9c78a5d65398f4414169df2122d7b15fb38d0044d3e8933021b8133cfd9c39d066a0b07308f815fd7c99ca9fd384cd3c89668547a7bfb48be4cad42b9835915b694a836edcad8159656b74dd5e0e8e947f35c10a92d914edfc8a36968e02875071562609e586838cd9c775e5fc3778500d8ade43bf6ccec8f04264bd6d813141253498cd436946d762908e03ae93f38b76342484f0f253a8bde132c186ea29ffe31de372c2558795c2494580cc4e42fae4f0872dd6e44091a79f3285fc7bb0d0b36a2be14f7b276fcd32ce8d74492aa534578389d25a29832e7a1832addecbc80d9a29952565c1c94d1e0db787ef8f5cb772bf46455b4d7858abb75d35fc63ed8db8a048fcf3ff1f16fb6bbe423dd0fcdd0f9ff4a161813061d7a2a2d75d08536a81699855002bb0bff3c44bf19a18eb950304391b752c843ed4dd5ebea1e401b505d67ec1401aa96bdfca6506cf68982fa807832de5d1d874aed19d33375831e3e074bc4a897342f7711b798ad1885a6cd23262fc5efd95e6937825e5db4a9535301eefd4d53de644f423a8765e3db47bef089a4a031dcd685e12e1886cbff86f126a97ffd2ef5a7cba8ecafc49325e8e83839abf5df3715f378715c2cf1e7aadda101484a096b94a510ef85ccc247be0337739806e2c6c6cb3ca2fdf9e5ec336323cb9e33cff65bc5244944062e51aa13a00dcb5ef8a7d17bfd7e0ad357256163c63b5436e1030c52eab8764f20882f05c9c9dc9e961211b5967e5933b2ee67e24fd53e3f2d9ac1dc8c5ad4fe96bb50c460728c1b7e97d5022fc779fe1bdc1316b9c5a06669b79f3eac0f270200db263ddae8c430b0c4d59fa564cbbcec6fd76e22a2fd905f841a9bbfff4efcaa16b76a67d22b3ced8b030017ed49ee8d9b6401aa4787c634727ca695b55cb572d6061dda5978401c8067e28b4c9556dd1eac24fe752e283048dd4f9c07b3c18643a6bb100cb17ea526ca5b8ca76d0f9c027c785428bb7ef09d485a28a7039dc0d8aaf73f4e38e8e3300a2799f1a9677b77c1c1180ffb507ae34171644024e4eb72202ec6c80de1f6a27620b4f726fd6d4be8d32cf496a43d2f6da4ba48d1dd9392b537c61eb152c75bdac926605a1044aef24a9df047e81c8caf297a587cf8bd7732afd5142e683441aab38b83d33933ce8825cff867a643553cbc710502193d29b6aad149fb8537fc4f7ec59805cbab25f123db6f28bf156458d22a974e2a0bae0c77e21ba0de7b6780b23c01416cb77a9811d198586fd59264c5c8939b078a43b9603c7983a04cdaf6621e36c618043e928d8deee68cdfde3a3bfb66ab58dcf3060cdf40c04703bce57df5e6ca9d38b7d34845baff398c95792de584084eae786663228f0fa8d7dfa77c4efc46dfb3d3ead474bc4b811a94802a6a592d614f5b56977a0df3a3aa40fba36cbe37310df0a8788800bc98150f696730c063bb39ab4ecc6e490f8f76a61089ce62719ce8f9c3879b62c97f7229bdcccfb267867c563f12c573135e65f29bdb52ee0647787a220439ec1d3029def94248fa5a2c0cfe0596eb2ee0d9e170659e9399f8c3e6629dd6541715d6e8d7d19f64e86d219524e85a0c95e60b4387ab7638fb8247970e9e4b25312f031b276e99c3a848b3f13bcc947a1d1e1ff63e11cbec2199966c567244ba13d4e97d3d7a55b7ce3123235ed05bbc1629aee9feec7398647895135ed419832d3e22d0139d346ac3c4fe1b2be78e4bdcaa2eee480f6c574003c1c4dafa87747f670d7650e7d0657ffdd2cbaa703e6544b355abe3e62e75887f23af61ab71fa0468147f7b7546f9554c14563d17ff91e6e48c5eb6e48857850252176756b32cfba2c06e121efdff92784922f933f3f940373957914837802268acd23a1555ceacfb7c8e169ec991ea6988f7847c69b720822b8b6678c81873bd2f51c191e9a8f156f55face719344c041c2cab3fc27d683bd1aa72319f1bdf8abd3a197d36676a4a03920fedd319537912336157aa26ae04122f6ebf6dfad56d655ba23ed9e9dde3ece685c9d2d528d82604ce86193f86cf81f98e948ab10362b7da82b7808fd78bb9d1d74a58b45615ef8ef06d527cf3097a243a93b0509f6203f77fd9974c57415d27affec8c050fb0d5f4b1c2ce4c792672b1165cf974198954f6de471358f77215f160422876ad9667e96a171bb7f0d8320c414a31ba087b3c7d511d5e40f0a8792bf61282d3f18ffc356499f4b63e650a8c5dfe1de6339e10cd4e5600b69486b999f660394973cb544a03f29687bc72eefa752ac3b72c8c4daa2d009d8e535ba366cf97192a5e666d5c6b4ad9a95986b385017502b827461961c37d3522f0ad97e7dde79435051447188981afb954c863995c7cc647d9bbdaf16819e1d74d3cf85efcd29ba74ab415f0d54df351f3beb471f675435899650c84cd13d4c1bfffbf4c59444f1f3a96adc60fb9a82c005db396c9b0614dd416e24ae5281e0b6a1a76fcb19540a4be84851f9e38efcaa20bc7b2e7a4eae53e10a022192d0318ba1138538f37c7125bf1a7f511e7e001d3cc8b44e44f7bd12a006abf2a2c216455d38a464d95ea7f49f77fe607636f1a8d3fd2fe3770026374cc2851c359b33536ef18697ae5582a2c3784a51e13c1e4ae450fc194f178d2e2a61adcb77e1344fea8364255e112e726b1751d6e9037150783fbde30a12c073f92f818abaf426679ecaf8ee71d987a7df75df7bb9d893a7559a2b11acf2376dc501f9f10f35da03feb678829754b19df7130d11f8fe622f00c8917c59d04f3cfe066e798b3964e7a6cdcc1a20183087b3085c23f374a9d253bf431402adc71e5a1ff4950841a0d45c78273a257ae1d4512050dccaef1e6a83654929897e7503be634a4f7596402871a1edbfb6dc384b8a3ff1a3e69a8678e2d0f86bb92cbb45dbbe7584da91aa9a80dc97f3810c8b7fd89592d7102688d25c453a3e0f2b25154780520c3272c5a37a440de91b1b1c3bfaca2e2975991c9f4322714c7498ff24b4923f00b61fea7aa72e5ce7dbb32be453060addae6ac5b101377c66dcd64ed7a2e09273fa07f3c36c19c619477a2f2c3e945293bed5338b0c4eec9a7ac86aeb289495555fed3720b25f27989d4a39f5f1b569861c0105f58c71f9a5f4b970aaa43b0074576f7967ff835edd168adcfec0fa5e9ebac8207398eaf3737fb5185b238816a6dd186b165bdf7ce9dc157db508131a6a88d85a56505a1ab7e58a46d324112cd35e9a18eabb2d0ba2bc71365090e0be2f44dccca0a5d50454c97da07814996e04e9e0fadda8d1aaedb688265cb58c42533a3214399adec20fabeef9b5d7d9e35fa0cd2c373598cccdf7f492fa755f92e6bf643b17c36f62b9ac4f19ad71083e0f23af972e979722fd6a5a5610ceb461e4d3febdfe801a9e16e772cf1dec86d08e673b184bfc3380361d7a68c039e01707f19b9fc7d70a335a93f0e8a791828eab1e6e984fdd870dcb97fc566eb3a211e948aa2f0ebd441e1d2bac4e9f9137dc29e3312c0a005c0e760bbd17b09c374aa9f4524fea5f68ef9fcfe1088b2b4ee534f1adaa7b0e14d3ee7e15a324f1102e36e0ff7e69ea7085a3b80e193c0c2d2cf5aff06a8ca723e57d99657a2fb2f91daeb83bfb9a3bede99b91c8fe13229011318aa37c744c1ae468196292cf822d7fa3aefc416abad505ea60a32e9034d407bee7fb2cdb8c23a3bff7f0ddcd0d16ac655162db108dc3b716737ffb210771406b63fb8451346d7bba116692e3c4077dc54b4d6b17ce3953988a510b376b0ea4b9668d9f81c717aa73aa7238dcf66794493d3c1c03da9c914675050cdc139ab4a1e9149e1f754d1d4de04ec4ae385756d1001a921bae583c21261bfddc64f2490b1c637a3bd1edfe42dd8abdc429c69558efcd5c9addc26b32ef73a4e0371fa3f4d76443b58d8e8be22ab3ad6ce5cae4f0c5567d9e0288cab8074cf666f748c421e09f7a5ec181cec83df7a412e3ffb33f34639ae4a71e72d265062973a6ed9471afd059fce64c962fa9341b601d72ae5fa9eec8b80aeddb3718b7a66e2ec73fa2f037cb2f446fa475190d95cb9fdbf94220fc41dd5d24676dcb091cb7c3b7ef0276f78f36b9490ca0cb5592b9de21e2e150339dadd0eb242783ad61ca36d60a1726509ab9e92aa7142f42ea02a023bd46d59040517912fb43ccfc0971d5a9f5e759cd734b5ce8665e8309f06d9327eb1cbbf1a8bb6d5904d2effb35411602881c4a715aca89a87040d2db8da9b6e06bb2e2bb6f054b57a1da5d995f4d842111e2ba5cd805715f7dbc53ffc93e7d9550550fcc103720061000763919f75b1e1f20b5946c2abb5db16a3f551c6366f72935a3ac92b4636c4363a6266c8097ea1602251a7cf1ea1ea4ee3deb1517ced4fa23a35bd39c43e6d01644f4d0a62e02fc5967864b620914e41d7947b16217a195dc61e923f115d2fecd67304dcdc80719287d54a2edc09ca252d5797be96f133a459eadd552448ad28d54c7ba47348744b9e59854dc73d37ce0c4c2b3df1b5234851aceb7364f4c59f33b46d2324005c7cfc3a5a0d4c120b5b1c595de14b8bd8bde93422af5513ac48a8430f6fc79d373a35ee99efc2c8f930e7a46c69f22de7bda0d38bd1a97b9b6c0e67a369957efd437b3a39bc1d5cdee7b62db1903ca39147b24c30eddac1cfa9653078438246c5cdd0f30f92c6a863172e0c3ecbee42bc41f3781a5f2c1f2126689978b50df3da931c5db5196cfcebfbe518b4d7bc7a738feb141e79e94475b5b65033c98d1dd8c26182168d333e0cae10b9b06ec756cc33745f63975e4dbaa9bf4242d8cff6dbfa690271f89ba1fa54c2e92aa9c1f680e73061ab535d8fc2e8011efcbc9129bf81eb61d6f80834c31c0bc0c584b58f51881a0c20f9965913c7d4630dffc6363faa98744172a84b2aec9964d2531217add9e77a7621a322e6afffa8887926b3e3402470ce8f8e5a37b9fb73f6057f63fc4e746ea8ffee9b25a8c5f87828c8dbb7397081f4e2d25c5ea65c872f0c64f7371b0d25709c42e6f2db0d556c6a5289d357129cf810dcd0dc05c1c5a5612a0ab121c61cfb87d4c399fd7d1b9de7a47d6723884078f503f00ab8fa0a69284a3ade22408d7912d1065fe2abcfd8bfdc81479c65b61b23dd5603a6039391a1171bd912f42d7a4c2c7be3628d0e1d85e2233bfc9c2a821e9be3db59f82063d221cc8639784b060cd24238f9cafffb0a967662f6460c83eb7aac493aae7490e6c561c3d1ab1bd9e2afcaf33908cd268ff045ace5ddda87029607ea56a3550029687f9b4082090ca7dc7946542f78ec4c66385e9683463d8de184ff801bdecfb5d110bcd3b47eb610235a7de50c0dbd8a25e15c644b41bb5916b1946ea4846c63f33922d1da2ff8da5ce07ce60adcab4b235accf97d2ff7b1f34c29512b7ef2c7b98a50d5ebfafcc73d2f08a7b9ea6f89e31f9c90c60cf07ab47df2245d4b3d6c99ffedea6ab635e8d972cb1137b4763192a414328354bb95eee1d6c4a00328066b88e45be72768d04243de1ab8ebd9f97d95dcc3c6a050d517a355364722bb85b8c3f483cd003e721865d79d5dce61a540a77bb552576f8d28393a5683254db4613d4862a7d2285c5c11fa27988d80fb03fe27164646cd4f74bc126870c1fef0b10dbdc5a10eb4e81076edb9fbb03847484b51eff7cb71a40dd5cda7cdacbbec1ed5852b109685688dfee76e79f3d14293c0d369e84ad272d896caa952ed39b3d7dad8133145dd1aa4a2c098186eb15f89dd0083ba79739d09aaf0b4bbf1f8cb95530a6c8360041de37516f8e63871c9d65297c8c78c0d9defd0ce398816044385b6d0bebc0ec0721da87dcf1588c09c01a3f6f78c90cc41dc1693f58e25f3b317e45181df057dccd02203c4d4ff72c4a5394be567c10b25a5a93e5887fd9a1b4c08593eda7bcb2ba907ab00438333ac1380912261fd096347de3424171ba5c145e31bf8f3c6a62a6d5fffbf76461e6aca335d7a0eb430dc37459747742b07680b06084962adf7e2553a69726de39843ac3bf0ff187c4edb45a62b40e20fe33d7d38c6c23fce3f65e91ae29eb24bcec39774bb8681b8587f9b5d9dc9a66425312080e6ae5970347a129e7d2ed419387a76e9079d28b252b6e7c78065067c16f302580c120907cc00fbce53fb98765ecefafbd60095725f9f010a4cb4fb49933a3b3758e4471b7fe777f713a3e6214ee0d81b51942e622a3df8696670217b5ff434ed6f9f1f0c830e49f0d246e7f176a56855d92ba4bbaae0bc41410ed7f9516f731b52e170031e6f009b1c2b25a19c9452657727f17433765185f97349093b84a482f5ddb7fd33507e15da1661d4dcdfa377b039c86b429bb19550afd06f53607ea2ce861b44bebe0018af5daf4223af73beab80c2563991347acf98eaba5f54d131288d95483d4a4690208ce65e1fd95f9c5914fb0696ee8826dd7a3b7c15e9e9f8ab4e0a12b96ced074f72cca0753731ade1a1d31bfdaaae2823db9f903f95715ca11ffcb78dd5d725fadc1552af087749a68b00600e4b30c23c5e1aa26021fb599707a4fc9d3f683d0dcb8c0e5cf8d26d2005fae18f6bcef52ae64d9abb55d8a65b86268408bd5e9e7aff4063eec7b6bdfd0bc37540853f455215acce03dae56355eaff3b60f3360e4fec61c37ec6d9583780d904f94d9e18e5591047b2997d6d27f71f001c9a0d82debb20c41842fa158c5ea87ca3bc06ea9ed1ca11c73ad8fa1fa6742f722ecaa238bb050d304fce9b99ddc6879978f419150cd7ae5cfcd8f9b1923468a868880e9f32a0a954c7e93e0c7eb390e2e25294545cb0cdc63d8f149e5ed41118fa9e56379b94af34d237d72e6cff0f758860661837f51c41f3d8d9dbd502a3bd5e41f3f0afe95c2e132ea7f662698a32040eb8f77fb21118e82ef705f084b49e4b2ab9608436f0979d67a21093eae4da004c35198debf96ab83aa52b4ba514260993853663cc343450d854514a3c5073d87e4739a5873419a13db644c9c227094c12db0475ba87bedff5c31d73adc5b7e1cd745db01738af4a2e42c4e9e692469f8cea77fcf9622cb3a03175e1c9dd6d87058d9bd5e1f4a46e50ea34b7912596f2d23754e52f830c1440520bc4bb70d713483e6a1a82fea814eb59dbb4bbca3a7bcd6a7676df309f01527d5ec23ab0ff8dd684cd3b52d52c7680aa12595f7524c5b166dfd815306c8edceaee046b27390ecfa757b5431b00fe4cfbb0de92bb3a5f61d3b7a37544b7075b9a2c1e67a524a567078d0da5993ba74f84b7240c55ffef62f849e4b0fffe97c949e0a60397b544030d627bee06b29f6c298d301ab8912d1558ac2a52285b6958b924afd254ae37b8e45f7d61f168651ae75cc5484bcc8af775eebba3e51487e89674f31ed5012da016f5f72cb3cbbab1e4fb294141145b026d7ef6bd52f72c498a0f4c7ee864475b8fad259aa3cccdb5fc56662ea9b62e5785ed0954ac47be23c68013515ce63d1a3fabbf6f66d3c4e4b8c7e37a1aba2cba628d269f184c416d8852bb6b5b54112a3f792ae4b1b2cfc058d8ce5701adcd649d5d3ed1d804f0af87bf50403f5271b0bded181a215cd54a630dbcd08f22a3a30f1c1e66b89f3caf9a6d98639654e8a9d1a3577b1ccc21662feed1625f6669fd00e42e91156ea332b93aa4d686808c8ac3b2c570b9840e7e3d13a268a48c951e854b9e694bbce92cb34feddd39410ec1f3b709f9738c248f33a46efe215ec7bc14c295fc0ef6908bce8ab1e69e43a89e07fb170e61d4f392099836deeabfa3da502fb5239d8b009c9b592c36f877e3b3b5d754317667359c12f7e4f77bf96f4210e00d5d59350f7e11a91e765329426a116ec350cb7da48dae4bfe9c88fc7e8b57163aeb5205cb4dff115d8e3a8aa0c4db71cbb2d0e28091a7ca0f6e38cf205c11eae7a7f38c6320a4663a53b968a3f2fafd79a555430a62f8edf58a5c6b308f6c70500c805bcbbb8d4b8245f9c3c94e5c3b0f1c44d69ebea990cbb6bdc2913ccd83407411d22a406c9a95ab9b56abbdd6b7b5e7c5c0d91dfbda9252b49750ad27618922e7924ce0be13019949fa1309099c415b01af29efa6bf6df4048c1a640937b9f0df3d40b3980bed7a7715a8b9916b948545bfeece135d6fceb9a768f1f6cb72c65687e4b36156e5e11d4ef313a95a0e94d6f2451e69fe1b39916e8cc9a7cffcd7a64acab86ad5f18ec9f3eb7c5f777b2413f0b2ba4f27c4b95dda73fa5389bdb54dd511edf2ffd4b07f50657f3ea1be0e739792cc0111cc9eb12315a2cba9f0b296ac848792dfd2572ceb261d846aae03b25f10b35a652c3edb8eeeee026d6074888179407a17147e13cb78c8830b9c912d3ad60ce5616358ab70a63d9f3026f22b57ae62c31f1c9cf7b6773265c369343b8154ed4c15727ac77255371d0d8edda6962551e09904fa3822ab517a1e46aad3af181483f9697ffb7f081d3837372e2b78ff69c397ca7c874dafe90fd8fa8520bec2d9ddb5dbe6c6266ef6bd3ba16e7d968adb9b2648f28443759cd15728247c2b39ee21508a48a832d4615c563fe2627a950b2f2e66d0f955796f33a7200468f46e7393c38e686525d894a697cebbbd0308af8b750f7273023312f46629906fa7c90730d9baeb79337796b5fd92338ea59e61b4d413fd8bccaebd4316b2320408165547b0a2b0de8f900d67e8f63bc88a26ea6bc5b6c40367c68a264bc928f6e715ca599aec507e55aad6b32845f5336a707c3021c3417628a4898cdfaac3aee7ef9ad6fb71ab7768da6099878cd035c146238ecc73e64f4930055a55edcc0dde17278e1d8db8f80a3f85cb93c19dae7c071f2b9434c40769271f832d9f8b4d090604a9f77e1e9f7aebb651287c38f8bb96122cae0c83ecb4862399271f010bdb4b36055053693fd1474c155aa30039b2b07730cc044ad817f3d2f6144ad125f65cf3889ed88ad292180ad3423f13670b925b4955e89edd84ad88dc6a6ea66d2a8967f904c2cbed9e32612d1c6bece5c128ecea81295a6a71381fda981a41cce198e4b23ed28bff5a195305aabdc7f5227795a5cdc00023016ce9e1095e05560802a4e8a1f00ddd38aab5e3c8e3fac7655089b6ad662c651328219360e0393341c979cc7104ea9dc1386826a13f797f8074d2112c195f2913a83f9ee5bf5933abbea22d46296e4d9594b28c10cac4c8b0a8d4639e8bc15c85b80e9ab5c6eec35870745737cc2ceca6d49d526b23282df112ecfffda5820d915e619c0fd91fbd4568a005c28224dd1f0950f2d3f4a409e02c9b26fe65dfef2cbb9d7a0d7bc79687999c293db7ac0b066d69016962b3a629f162ee77945079161170f7866cf56b53ae876a8b5601eb3fa94d33fb4cc028c2d54009cca76dd00f84fbc5e7923ddd1d5d3b4772dafea5e966597f108782ff89fcc28ac9fd1fd17b404697635485d947f4702d7e578dddde84d34affcc6d2e3ff3a6a3238ad83d0d75d714717ab2901e9133161322190bc15ff38afd78e38c99c25877a75ff14bb13e6322409da0dc9c139e4ad7488cf1103213ad853183774f11eb4a652004edfd0856b768e268d4fb9a8b1643e272bea61f2508a162a81d8f4ee15320b6344b6df036ed6025b51541ad671512beaebd209c7d67ce89751045eaa57695d247f3571231f1873a9f51d7b404b40cfe5cfa787fde19e1bc98e1bf752e074e11b2c070fa202fe1b4b6735f6ef5a724d5b0009545cf67b5145dd7791f0792b0b76006ada7f65741763ec5b04822352b2bcac310abcf6addb19c1b8c396b089de8b44da2af382f17153df3c26259bf55af4ebb688eaf5dd13eedbad3e5103ecd1d85efe34abbb65a6d9c8388d6df8357fe0ab8164dc1224c732ae45f3e4579edba1b9295bd31b8ea80cc73dde5d1e8ce64479cf1973d2c2027d2951ae137d83aa671861e0c3539bf297018c46617bee24f23866f861dece09643e83a5dd08f581dd94fe2a389852544af3a28b6e864c0450ed3f32ed54b2475044568b9b518b6cc376f537f29417306063875431e214bafe1ca11143e9626d51854dc55a7fd9dc70da76bee00e6c8d58c92cfc66c20bbd7037514e3017fa295a52544ab0b4ff7bc888b35dbf1511ff4cdb11cee4b28de7aeafffd4ea584fdd9d1c43c4d815c6193f9d5657031802c6a78f551564451f9388764af862b3b3bdf9eb7546c2534b02d8e989e7cd0c50ccb7385d0697cbbbd1558982e9200ba6889f7d5794eb59ab4a33caaf41bee80a0d5337a5c8c40dcb08ce0776fdba0e36a5136a6378a4467cd02712940a441d0afea999a4181b21d97da1c1fb8518df9e3c9a3ebc4863d2f8529d4944d823b29f86ea599cbfe1cb7f6625c68fbe9437bb1a801bc3b825d5e3ee2b00f2243c3098f34ac55f65147b680f4f0cceb7a814db744474f1cd054daae219657ec72794d341fe392264799e44ca06d092219a90b979a3e5c8922718fcff5e7a3a20cf6852f0418b28b1590b58c8e6e24b65eefc8ee4d066e38093f2d2d4612442f826e157eb6d6f81c921cdaffc3816b9a01c6c474b44c1d82fa3f90866144e0cb2bf0dc5d90c88631d29e9e5aac5dae1a11f745b14d0172b9704580835e13d2ff32e52a64f922ffa69978acd41e39496afcb4171f8d024501909b7edb259a12ca6b2c26f911103ccd9b604504eba2f69629e4c00ec54fa4001a5e0249aa51506797bb1ea4d815cf868b847cffda805ad5d56185152ba18f325013c20144cd629fa4ba1abc5a16d350957d66ffa5c3e429a9034ba973bf46435a6cf33affcbf7e97e2bb6ddf3a298521994820c593b846a0fdaed0ea06d3a157fcb4ca2c94cbc16bf5a6f1e2d932d484df790671b578de96e4cb876f17894a05f361345d02cfbbdd73efcaced721c718ac8c15451f5cf20ef62e118f9e6f9ba903a1859db6a068091f2a28725fbd3ea970bfb0c24d21326c7e62a31596ef7b1a53f57fce86f1f82ad88fb85668388d7091dc553609f6b37876f43a459d066e046a414ee317d4f492659d27d52dee2f6ae6ccd6786b1a4899d7b6bfa737b353c6ce8bdc4aeff3a88aa04765ab0debf9dbc33b96c558dc389745828cde4793668a3056141ee0ef7bfcc9f68738396828595e9427a95845a7b99b64ed8dcc16f62ecfab79777ca1d2ff455b3b48738cfd1e5f8d766e2f7158bcf2d0215f67989301a406a5d0063577e88280efb35da49d625add918630a16343d3c4b848baa4d34a2624f7b97d3e45bb66af2e5e0a9deb86229e0629190e386cbed82caef07d9f7e1740ecbd2ba73b7d7196afe0fc44b0b6c333eb93f1e55da0c73cf6dcb50076e5b69d174e189589cb1b0991b255d4305c8f32d39afa7ea8cb4172acc71076d400b37aa6d5cda411e1a3ed4d66acba0b1402f2c7f134ee74f0b67c0efb3a6aec0aac4f95a71d29519934b750c1b40d5b58338f1ae4553407ff979e280d3daee8bd1d652ff100f3e41b2a608fb7b7c15e58b028412f4ce687e85ee84d2fa607a887d6bf3142dc09abdcea03f3cda7566f6624544cfaa6216e755bacf74d95515e6a346088aa1515828d0b4c13af1aa65f16172cf5b2952ba6352d9e9d76bd3f284b0e43756cff949b6419d2a4972eef83f1b0e75515a1ba1c6568ebc96f7dcb873ac703f094065a8d565c70b4576fbee85898866498515c235c7bf90d1ab3a0c016c3bf43766c0230691a044ef4b9b9807477deb1c6588d98ffca467f5b0d673172c34bff0fc0a7049eeb949d8970f98a5aaea5d16176e35de87b5daf209fbb90873caff60c69954f6f3576a3beccb75de825ca74d3ddf2615d45c8e817939f679bcc638ba671bc4421759e6a08ae231532d8221dc5fc9c5871bef37f6d5fddcaf816c8e16b963812fce411b47a7d9fb532a0b877613e6d34e3b99b54b53f5fc16b342180942e54b8a74f5b2078323168c5f9634a96e85d9b649a84cadc402ffc60be57cd13e8a31003d0f211f345fcce42dc77d260fc7845ff7845b749a41dcc3a5aab0b2e6cd4512140c1625f4d9c18cfe6e9bea1210864600d568d818856dd1514f2ac06caab00c4c2ec688037d771ec00f0bfa79902799bf1323ae0cf61a4a37e866dbc03098d6eb4236c5dcf6059f23ebc12faba0426c11f02ec03a2d9f700dc820dc25271ef4ee32fa82338162f44cc6c09911c99d96f02439505459e631112045221e0a4716d533774d898981436927526fff9756eed26b756f8c7d565514be248a5a1f93420e6cd8e548a49496209dd615203932fcb029999e8a4696c1e59019a699134639bb073dcb7756e7d7a2efa231700a1946dcceff99cb91f19417115cf514faa25409431e2d2ee98a3b8b27bf07a3404e3b016df6dbeaa04a97a6b8fc84a0b6b9365ae15b73eecb70e89e5c3c748ee7ede433ae412558e8052e766525cb3b8f11c6a1253e1937cb5ad9a369e8ea5daaeecceb2db28fe9b33fae335f236d1e7faae99c20de7d2082102cb30045ed541190937fef43bf4464c6375b76fe41594fa1a3fd8f9f2d322a1d2c431463ab49b15aa48087766da1fdcc1757d5af284e564d6b7abb49ad1bc264acbac986eeb579ec3b79b3318ebee8dea72a37a610a5eea865506f4d76cfd00582bf78d9c51c3ab6f3e09f84e3a2cc0f576106ab82753e280bd47538866570d07eb23c60f28d8a6c5faf3ce6952ac0686626a54fbfad660bde239609a0157ff2bf2df725547b4b9e7d0d487e87a0dcb63bfb010195e82969f20c5cac48b290105829a75c52056fe00f14ce0a52fdd39d088620c0c69f58b10510ccc7208aa7d20dac447ce4b1ea865b14dada528e47cf3638e11cd16d0e222001febdfb5f5ce88691e388387710e15bc79b56e9fb3bedcb7bc6841250c93acd32ec9aa80fe9ed272995abc41d115da99323e7d44fb1c1abb92b956f119c02e4d44b051c6dea5110b29664f9844d42f5867ce17f50de5632467fc99a8c9e4c1ba43f8a0fb8171d5b69d159a99dec75c9e3093a15fa7e39101d5f006c3cd91ad31ad985d724df3d4a0e3ac52a5771d1fd173df913209ca040cd5eab5097dcb025723ff001c8bd2f355d50581bc043129fcc94c5b8599c8849e8fb2cea2dd3bca8f6eca16c07ef45539300807276058ca3f7627be8dca4bf2e05029175c2da7af2a4f01fe4ff7672d322bb403904754703c4c71862606d038f79d85533b80bb5d7301dd06b382de8f53ceaddabce6cb43a78b432ca66bae2b7c51bcff8283e53064c2bb2db250c6d4d9f66f440ef02653af48153c1e69d6d743b524fcb7c9595a307bae71169855358a058b265d0566a13e08ceb2dc2e98aa342ea6a4d83b1a4243f27f7b6b0f6dc48e58269681f396ec2b0e678f3e971f52c7d6e63d2b070e6c463e018ba286e7ddf35b01f5a10d2f29ad98099bdb7e5e26a4df15baeb2a0cb2f2401e01dcd9d9446213bd243fcca0578b5acc3ff3487e4e59b36011f19b3f67196c573f683839d76143c6b144f4268c9a8b03037ac279a732861ac57328e6540cfc35c8c20270ac5767b1879fe57d153b7adb1af99fdc0022b178a49f825b6b380051f6e1b27b4ebd8756fcbeb134c2ea25363456b3cc62edbe83b849d7262bc3bd1715b196aabfa6a141ef94a0f02edad477a3a861693feb5ad8a97d4f92bf2178db73a17e94adfe52f48b58a3f65af74a76f436cfb6d775e85361c3c94b2e8086aea4ea21da09b3deec8dd95725b45b27106837b9a5cfef5a68b8b847e93de0bacc23be9e8f846eb70d24c5af62115fdfb564e80d532ca5ad04f42bf47034357554b8759f45bc0bfe98e93ae40cb360c6a240e25a8705a336c10d5b8587340d2199276c035f9dbe7527d99a302d7fca09ff6616120aa9b5163f5e1112d6f699082d652f46be934680f9d170292b982acd403769363689ec8cc0654cfe140402d24ed4b50ee8e6c7dbcdacd66898949115d2532e6cc3931f1431d5e40823fab7cd0415d1b5f13c9951435c3025267c134491cec44cb07437682e18a409c2d3c650f3940cbd603d00c55f93de3a42266ec0525ea6aa505ee82fa875455533e4f9ab401fd26acb2d60e840eaba9ff9403aaff803b0ca013c73795fea546e14e3161b6c2d03e238dcaa6f0182f15476d50f73f0cde77761f62e073b478f7b004825e65d17c3c28d4dc6fc0eb65ae42f330be5e32ded92daf0e74066e78f701d843a1e9f1e7d44ed328036b98a0b787e784178806d7f0de7cdc7d94a3cd1d5af83d1f4fb6d5e700656f3e4db69eedd5d1df7826eb2689ee2fbcf9fa4582cea2e5703e653b344ace670dd0d615d42b89805be2132d635563747bf329908791fcffe19ce2f87b497c369f7b10dc7278a23820ffcd899f54d43fc5b1483bb0cf6468c166a5c53472dcf39c660f23a2bc35482b0c9a875b3669fdd4750d536f43645d09ee0c1c9405858d3fb6b3fe5d381df3661bf0dd419d52fd5649e2c5d2406106778c06c65b0fded29510121219ddf6d079a2e876aabd8808e2674d86371f1356941e56d477c51d61d0efe5c79e82cb11a77a85c5a53a183d44d896d306a160c3ea3351a6f97ef31f1b24dd7288d70fd619126986fa44b47f07b8208484e5956b7116ea8745a1437b3f41574cb06b4ded3070c0d25408b1389d5390fec735e951701190aaf0f57b522e4bc835407327a84a71b0ecea1f202a45b8ae4a82afd857fca06c8037e95e1c96bdeabf1ea8ca36987df94bf9ec3a3cf252c09e46c75e8e35f215a6c04de87a04a56b0aa804ae6db91a202e4a7cd09f1015ff467d803352c7eeafae87fe410520fe204085b6ba7de01d905a31c97b1efdd42de92221518bf99f89134cf70b42ca8f79d0efd0c984da3eabe6caef529651dc89b3f63f1c102776b050726b1172d96dba83d0c9b5c1068cbd570caf7e5f57010e7b158995820e6594bcd520caf1d938160c49f7157c1bd7603c68a8ca3838c73ddba9d64584e00ff8df10270ed18e99fae07993e39cc5aea7365cfc3f73b4e6300279563a711726396b409391c04b525d9fb0243fa3648c18553c9fca6cce6d50a9b68b082cc8898de9770b839237a3e4e314b9e6af0fc5986ab26e091893b467725fbba65a6332e545eb919d6fc385c155938ee1a0df9dff8b8e7fb08b0f296c77a9101f4afd313c67c36edda2cb9d93365595845cf80c3634b726df0e38ad55886351c05f5f5def9844508d4841ec15d78b64a0aabbb371b3403cabdad753e756aa1354838ab5fe5c49589f305b3228273b2bf4a3761fbd170f8f65875ae021a9d035364c12a2be8d4f473c2cd8eca8a0f63ebff9260f906b471df85d68083cd50631b147a4d93c4af53f52a1c5634e86bb26d5ea98443c44f71b6db29761b631b71de6effbf0f46857ea7aee4937ce1f6b3cc590b53fe6bd157cc06310238d932bf8f42c4eb2ebab15cbce7133893c86845facf8e012a4e1717bde15cb7294153f266b8a0335fa109bd08ab001ecbc38c2888d8f8d34da2c62b7d27083680cf4603a16e3b2d9203e472416485772ef367856810796345b57105fb3c4a5eeac3af20bb2f961d79643793d2f9e9b6b0266aabd4edb35d8323230d92487ab63cbf8b26d5a11dfde5e27d1592362f1ddad5a1231ec0c03ec9206b08dfb3653e184a161cdbaaa608b7aefb121b8864c6bb870abbbf39e560869d505a1adef922490277cf1757e51f9d523f60c48b3d889ef5a8a7cbb3a2b6af6c74ac8ced8f2a3e6603718a42b72c0e0c82c2332c852e42504f49af81e60989f9faba787dd2c30b16306e1f4d8fef069fcd7c85ec5c8a8445cc492e95a81f1e520b1eb9973a79ca468f80312d734c61d0176a9be3844647f53591f5e457eee699155686a01fb6bee9fd9463f2013efb3449c78c6af8c4f1e11b56727c2737a92f81121866c46360a37a8aeca67490fb163887be35c6b6260e30700941fc16b31262d5b1f12e3a380df7f0d397ea7a2277391d895abf137d3e1b3f2122afc1573a7a70bfbdd4646960a395675cca43fc27ae538e0b69fe383997db5daae8500316eae115fe27ef09bdef79229d4108ba8ed89671d9688aadbc97cedb8feb143ed752738766b5afe40e05c4c14a0f0851ae5ce46b8c0a7a398d664d9692611d9647619454ebfc1da78cd4c2ece7138a7829d422a92c11cdccb707e5e98a13cf7bd98fab4a32e984c188c0a67394069b5d0075a4d160a113084b4d712131cd7800eb3e30f73468fc901b56d58c320ce2734dfaa32fb1073006688fd833395e44b2e7470991ed8a3aca6609d128775cfaca572a8c12aad52dcb33bafe3533920f7d3cc26754b4b976fd8df9b29b5150326c818a9a5223a69d4022c49a9eae1fd03496e63d35a5b0817708798609de28a5182af66b7e46090b0bab69dddf3510d60035b0a327b50a82854cee7a27381bb476e57680c14505f192527328fc5e09c0f857b894c53fbfec508f1837a88450347bd0e980e8ad7e0d5f5269b1fe03de6dfdf9310d4e693c94a281d7cd987f20f4813b178c623be9817512238756325019845a0cfcb0610f4a054c4d4fdfe4172234200a2b8cd6c3d573e594adb9bdb5ceee337644e3c4e8428b790097eb35236228a21db7879a22ee685ace174a253e64682e03b1b0f5f44f1f7adc0c2d957ca6525903cba667ec2b298d5ab36af49e2d795efff70833eb067fb71bb01f8deb56fe414a1c11d18be20788c1cf8239f2eb831f7c5d3816eba15d6d8126ae740b4600d75dde55e566189aa0d6f1f8545a7d88c641ecc4c85637fae363abaa1c5db4609d927fcffc03b204a969ba74c8594149df00e9f38e6782cbafd72db671afffff56893ff7f44f4ce96039435b656ec1c82234b7a416190edc0d0230cf706c56bf3aabdaade3d30c6e4c5b99bdab5779faee69474967c15f3aa81bf01081708132ed773336687fa6e4d21e5efe0b7fed6fb14a21595ddf2cb483ec85d8828db0b995631a4419f0a0a41dc24afc0a397faa5e1a8d880bed857df902f32587baf29bb1e5282ff1a651bda2cd3c0393b22908fe761129e6f57891e1a6142950b9905034ddf580a14606ff302f38f965385785c5a7a57fa1d414e94b44b99b484eefd090e4b2c9603ebe47d974e46c41dac70dd9f9b911fa5c5186c1354e98837141801c0911815bf4491a233e9e40936053d814c76cc04b2fc90476349bff21ab9f1f141d840938094b35799ec8415b4971ff31c814832d75afbb7644a00955991928d245fbb46a72b5f8b20927e278a12a270fff92896bb66fecfc0830e2b2f15b05bc4d506c9c469ada34076b034d5ecbf0bb8331697bed26cd1a0d7a8090d804160a60f1e3a8d5753844a447d228a989771275b1bb70278ace11bb011200a4c3f0f95d740c939eac686d5518b0c1e055af52b9b336a7f61a49d94a6b79c5c1d00db82bad6a692018f1646a34a3964ed7ae059f93cfdbd52685bbde1d7d7e226d89b5bf328362fc6d4a0f7482b2039691c6a439ba72e227285f93f1c5f70252a447caf43556b6e90b7e88913da07ad2169b745ea882262a93158c9703538e63b6a61729d0fefc6510a274e77e6e63620cacf69fd70f2d0e9af6544fb06f70eb4cc809af6562c4e3fd61ffec4fe728862adf1954db14d2001e2332725188c5b9b224058b262a7e080026593099a4d95b491618a6287469408deb743ce7fd6b4e047c6c9632e11c4ef304c6349213274c1eb1c9d028f7d0feea1a952664dee61627738b9d2b1c848a0043eafd328c5fac1df6faa011c81a6ceb01edb3ba9156e95621608cd04f0fae421bbc6b8354541e9fd641fcf53d1f7122dee59eab28f3ac626987a8981449182074d761ae292fe3d587b056403f6b364e7e88a64a1f51b9eaee2b8fc73d2cdf4e685fc23b168d90f0885867d4ef526d1612e06f78cbefd38087b0ece2584bb4fed133fdb8c2d70787978c6e4d8c109cd86b85ceb87df7e52a994b03c4f3a0cb3c112356928a17fce5a31bbd9bc34ebb45f358a823a87f33ceb99ca1e0c0b14fae886800d0364af587116bdce429c65cbf070b6393dfb5336e28a1b655e4adae58f5572ec29ca2a392f66ab7838f2be885267418acae256e52140837dc6d3db4f7d825daad0fae568f0eead402c6281626d3bcfb7473f2bf3e0d0d12d6d7f34e54f841fe6fae0199d88c181ec98adf55866eb0027ab0bdd5903a24e66e49124ffa67dd3355f5c5ee40a80a589a355b4facda4841a0c2e53902fdd260383cccf356a0ecfc1bda8ff1be13508cf5b601579e46599104149b243e7f03a3cc18458fd9bf73b331a027fc803381e29933e349c63291241fa855ced999c18326f90b983bd3624de297b3ea05a603f8a5ae4dda4bfdddfee3d78349a5de5cfab3c0cdd57cfe3df20bd2e45e552d745f12e31e371e4e73048085fc1ff6f8e97825cf9323ecae9d22644fb533dd7be6feaae8f666219ea20eaf6f0ef0130dc0cb7386f21005653204f31a55f7f3b94e839b491b161ce2c7df034997a300b4cc388d41e1e6b7e6d4ff6e79f34f750ec21c7634142ffeaaa3fec627c0958b3893bf62d776aa310c60829d5afcea052d0cc1497b4de4a535b20751164e35a4a478e34720e2fa071acc51e2d968e050f197ec7721d372b68bbe690999231c9205a86745161b074fa56437d606a6bc5e7f5765d64ce3e391df72a152b76ffae0dce1292b4167a2732f5302895a1743a2f9e25a1c646072e869d7cf180e53841e2e2059684a201861cbdd2f5515315d027c2babc502bd8d99e2e1c4819745c4dca8401343fd1f7cac6239e3dad3cffdcf9918c9dad41a3c7692b0eecf25648b62ebf187ee2983a2af711bedba1c553dcf4d22b8552d369611775b5c194064aab7a9c2b1639eec6f1301e954237c13a10afb6de7c80d5d45d92ded2680a6576ca062e94b5e9f266de4d56a6689b6276ddac9e4983441091d4487e82b4634121aa379bec914136e2ad892ba2fa3a4fccc569ccddcc0c354b1625cf86705698e5d21a12375f050413cb360a9596fb4fec5056b0c6194d65457e84cfbab8228136d0cc8118185e2d9fad13dca2382f0ebc2f402bccae2969818dcd436f7d0997f0369196de7139bbedd753208c13d07a5be1b6afa2ec2cb5c052a1ca72ebcec14caf6cdaf0ce0afb49145258842193655672e62793d7f4b7b3ae1be8ecb2c769bc334f0e7f5aecfd3127eb749d6506e3f72b66f789b48941cc712d71d28d1e9b93226f53aa9f9912980fe60402c393ce51d826900d8990b76f2f2993e45e60391dea6fd2997f8db4324e1d327e0c9aedaa6a0eba6f96a478d218770a955713d940790fcd16711a90c2a3ca4f7590588f026b47cc9f2b39cd29c002b384c72566f5e1d28fbae84c7d52fb1fdba9a566ecf03ac0124d2cca7f2d2daafb2b1dbf2d7459800d471777b78f7b126026b6d10b1b4b477f3e0811c2518efca298bb8bee8b5e970c51009aaa940d72de0f31b03cc63d066f588003ed5b72e22846927853d7949853326f35587b82759d5b4db1de63b6e695a3a7cd5e17dfef84aef4405296b2592326a94afd0c32a32206a32ecc07b95649da8dc61ac4ead13ed66f9c37ae08818accd664d997c8d82bce0665cac053827fccc17d9db6f480f22ae4cbb40bdd43f532508a569aebe7e9e35774e53ddd74f43f5d4f9a5bca578af1f724bbed2e4a8d3e73b7e749c92089beb40a417f592d15e29a7253ec810e2d65c54d61320c4f2d091eb1f3cbb69d9011b99a07f810dff5ef0313d1b7d2fcf4409895228bbd63a51efbca8f3ef9c3cc9702163b08a077fbb94222fceafb047b0eb536e8c30443e35c8faea9740f2c6fb04ee517b6fa69409b49af74f98a9f2a5bda561bca369dce065b932b834827a39ebf0e94ba6895c21a72cf92dc6c0851eef2cb4d09bdfc7550db5ed54c8609f581ad52d3099155cc6ad958b30a0e09554b8538f3e1c2b89e983aa1e36839369defa707823e80f2e4aa240c44c65ae3b6a2b66fca6efea68c019f82e7702be11e5655b54ff8164ef9ffc45f17ea7b8b1a3b7529dcd38fd1af187b82d81106a55f912980b9854bc085342c8d7805646ffde71ab036e38e131520b732a356dcadd66397cd4dc5debde5a36ad47cad422a1fa2d5ac18cb83090ccbfc67072be6b6ac83e9a39b0df8794cf3927aafc99031796331edb1be4870b193f2b1956709024548ab56e662aec726bbbd2359d8853454039c6bc9b3f1d101ed7e310b806e5c1c1b1d2e6122f8498651a40183c85b246dbd32b12856c80389dfd8b7ebcdc107ad5f7a13d6fab86aa0360a4a7e2c9920f0fc7d92a92c6aac642c33a7d65199cdd5b4ff2353605bede106aeb088d3c4e5908ec6ea27e4ad468506689244686f21a7d0e720403c108fe1ff80080d1a5718f124b54835013e4600d2118975200e78ca100e16af088fca0f939b62ad08bf95bfa3c8e44361c070a1b4e9cedc17645057f2aa9c48fa7b4365ea2fc1b456121b359f363ff3a9498aa57bac38eb6639ced5938c42ed97c73c490e51ec84d0cdafd383bf3eddcc13f5a18a252d52263d765d7d710ce73a5582dab98f89dca50a08a929b4c61651271311c566f1a8663203f4b3104d540dfef0e21dfbdd088eb186ff6bf491d96a4bc487e23d36f90ac657e5e6681a706951f023e63f3a60e32ac61ce918a147206154206bdac03b474bab94d18f90ace6ff42da233631b7abf92c33856f522623e318c0396ecbbf4efdc2f2f356f422d908d62156ab6f08ab4026a9aac04fc11f31a7bb34c9ae5f5c1d966308b98de443ff3c06c1817fc217ffedd7a82f57fae33544d60178530d2d06b4581b4fea58a6cca264568f7ce419660d73c2e746ca170b5c616d1aeeb3e693fecf877a7d46820ba826bebdbe6347fe7d33407db2b4727104c3d8e68e8753ba1f2768faf55035f57f71bf4329a679112df53e70ff9c8f0a0a89a80cded68fd247079064c76391344bf885fe8d2d058b26641b8929bdcd799e10977db56a0183e3aeba9bf95501196c3ade957f9a0005e9b063a782eb7d6ea9ee18b0127a9b431e57628f3415624a3fe2799a63712c615c49504920bb487944b0e4d58835880dc89cd13b90af4d9266a23bf751b831653c4b3a80e2043d15c0320ce88fdd254a059595af25396617261789f86bac2f76cd7d30b73dbc3e22826e3f5562cbf3885f59d027b0d092f7d72eb87bc827958c10c7fef180849016f9ac4252f1df62b407039b8fb2ca017db1874f31c9e4c8049defc2033d4cad94c2a13685a5cd13711402c8eaead4383346a8e82b245ae5b3cca0347b830b558134338e5149c0c0a13de25f8edbf59c167102e002ae3f60cc9db7e247816c236b8b56540339260657dc55ddf41ccd19616d1566be0222b8ef06488dc209602b87d41d8598de862e7996fd947c08ca064c564488f252ac76bd0a41ac423add8e5cfac34ceab012ff3f70fc171db21dfbec3543ed799258d4c45d46ca7349d6aaebe6435c06bf975022208b22368a72b57aa7f46fbe9c2e90ee82537416dfd0f947422ad4cf5b30b1832ccab493372c10fbaaececa7c8d10e15c25600dec0671c85e6dfe392c0723ab9f4ed810a429acc8dfa76f04dbebb4920101b279d1ed4b7496334bb75d8aeca1018c78af0902bf3ed51a408d6128d6315710813b0761ed038a5eaa62acfe302852c213766e5867ef817e0ec8462869cd5b2338dd5ff2007cff5c93eaf098c6affa3b2707fbd20eac56011965182cb49d2033e036f67c473b32e474aeb052bba15995bb1a0a75312428896d5196fb77e7010836cb2f8ee3b977847a41222de1f62a8361eddb7acd7eda67b899bd4c88f2ebce398e45af83dc001d4c6d45bfa66e863f062ea8420ff027a0544040d7e6c581650afc220ca820a7d8aeda02501ca9db2bd6ae2e3f51429bfe0d519c503e0f4a9cd4e3877cc1e4b37b8fb7c19641ae5a2ef00d572f18454a557f109de1b85b8415b9b5d8446880b98259208a42f2f317b202d5fbec3e6af46aaf0fd1762d832a88a0cb3bd6aa4e7083f34a65e984c83cc5064a67eb7417e70b5e80e85bf92a7488fd623467fbebfbfe1eb95a99fd9e2d232df9ccd40c7a28637da51d900d876895a68b6c764ffd2ec88ded987d44c47263bbcce17fd48c27b27e14a7650f5168ca3bd6472f91d18e4451a49926c1a2cdf1640103822c162a1c15f2909f8df8503e84fe56fd92561aef943dc7e9eaa28f5e298b09d3b980d37a9be35272d63e8cc6f088e3442f2f0427b974bf4368ef9a6a3383eed7918719eee54a47e9325fe15378d9c1ae29550791b846971a41410c2e9146fba9b34183764f541ae4158c21b460417a81c411617611428562eb8bedc6e56a1b512eae3403c01f53ae2f96b9582556c90db662799d72143d3d12c89039593892c57c6e384523db53ec4b9396097a27c95e084d4c0af101cb81f31b352ca4f73291051b78eb03ae5c9cb8e72ded2b2c4826e0bb183b04e5d87437b7ad08c1da858c76ad011f2a44ab8276c5b0f158e09a78fdd8843d6a7f008449580528a6452b42ab96d2b0599a0415220e526ef8b76ef9b249cbceb30f457519cf0db507d4141545bf752b39ff0ebfa208ea9505c3f54ea547242257a9e9fdacce3f66897682ad57318395ecbc302cce220665e4f033d5beeb648d0b5bcb25fd4a6f81cfc17cb3cbc0886817b83081e9ad2588314fd69276cd1fed0233c51c25e8d300394e775f9c89baf701148c0482023569d40a4c2d94023f76b8a5a71773ead066587172edda05537c51689857c919d6b5fc2e3091642fd281a1d20b6bdee9bfdec578dea1afc0ccbe90f745ab815a5db15fe4173dce205ceadc4bcad8a9761e097dd48eacd279468f8e76ca0d3de479fcdf84bffe785a36137cf1da56a8d9ac42377c34f9aa8b64a506534907f1cdbe1b80a767b48229f2f3a4743afa5a179bcd2e965c896f7537f35f86ca8aa5154e3a61fc53f186358c967c9811600547e5694f36a3cf3e5253cd5d254a32864f430deb85cae3910b1d90f9e08cac1cde59e8a0abb65fd031aa442f3b89700163999e8dc26eca4eec80fdc34fcdba9a4e934dafe54fe03902601c494807e2ca865e016c0f9a9bca7fbba969acb149e041b16294f09f594f34207a6d7be8526486a557945d4146c6b494afbb426344778195bd716b07a31c81844d323a1a0baf737900f20777f5e8d921218a3540c321ddb35c49909bed20d802aa81cd7498a5471b6c361824804b35377a2287af724e18fed9978b44526b23566558ad0b5430c70aba7e172b21170000ca063083d77c248e22cb30223814795952419984299ff8ef668893e1b2ab58f31e20e26ff5de24cb037e7a0f811a55c46692935bc8169054215419cc9598a1ac69c575246216a4604ff7f902dd3824d82868681632bd7bb2230669d32353e37b36a84fd0d8051a9b6d75f77cc4951fd5030ddf3a2ab2056bf143f711a067c08b474a7fe4e9721aebb387ff629de9f6dc20894679aa17556143c0d2a4d9962494dab85bc7848b27fbb1feebf80bef2f1af9176f75ede28aa0eef0e46f33b8af7c4f8f74c1f5bbbd09a2a52e456a06013f6d4727d3f15cf49e8e000481fe9edb3c7dd115dc217cb36a4eaa04dcd0b0ab9b9437bafa35f2ad37fa6977a5c11d466eb0b317bd87b058593713146b35b7274d0a78005e377d6b77885bb636a0e58df44e4e7e985079c7928db5ddfb07f0d77da2536e59e06161a9fbbb26c6c03cbe2bde6e68910b2a6fe863f0927a45c87881ebeaa28cf9c130cc5cbadf74dc4c723d32697efe976499e2b39a74faed3e9d601915652aa11e723a606b9bd66585e3cd7ec0ed3c664188e50518a2736aadd7800a340f3107f0fe25d2558b57baba9e8cc03210077f95550aa1b5a4005eb68e2bcfd3c73bc2c589325f2aec6d2100c3259f904b0f7c0210080047f9a602ebb3fbbf4a7521ba51cee0dab67989eab27a7ed14738f65433fad33dc9d8d61ff0b5b0a0db5768205211fe006916d7e8cae16c7a99cb17e3535edd2a5d14e48b12984b55430339fd3fd661941318a371982851c8bbc6b24aaf46107c7c951b83614900f82c545877620af3f9e72ff904766e0257840fbcfcc8df5b9563aa5558a46d4ae0edbe7d654070b1a3a824364a23c5332ad398988ad40dcacc26b9ccd9c6d74a0efa80bdfa65f0b915f7ccdd356f070b7132f73edf0ec580e4cf11c24c5cb9a499ff57f2c5078ba5be474394606071d5bcf29ac7ae18534f1d19d323879eedab711144ee0f4f390376670ff850b354d28f367927bb5086d5f6eab28fcdcd27e6a955c5fc6de702a070ca293b7c8b66114ecf3240a2ced04b711f054166b43f09dff183b03cf701863c122bad59dd42e2890a5cd417f303ca83b74a0f8c95c102a59b6d4526c63ccb8b1e0bd6e42cc426a4ac591c3a7f0805b845307fd9c8ebceef9d11a7b27e0c044e706b1e4a3e9f71231c1b4cbf2fbf74e174c94637e55c34552beaf7b61966b9817d882b239b16bcb7be873aaacdfafafa1f996b30bf9718632fe4420e686f9a2c6f0e2f7384a94d0e3cc8bde9f9ca9c684ac4d867e8c69e2614431432ac2d3ee60127ccf1c7d497633a411fc3380820912982377ef753996274bf84267bb69e538041c724c9cd1c38754568b9cea915c50ef289874ff98f3ffd28da41c4eb3694fd6bb86801ef0abd42530b43e8d81a98a3020c332691e1c1af7f83e8b8608c611b3be80b7131226c56f21bb4d42aceda21fee36b6a8b4ea928111e50a6dcf2d7c9594bbdc785ea28ddb4323cdcbbd3518ea8cca43e648ee0ad9ac8930a7c387627a74900eda85b5bdaf6f706c7c676cff2ac955256ecdb74fd1f574ae278ada8721802e2ceec49388c41aac606ac179c6fd5fc961ac2733889c18f9e10d2f4b1d7b23b847c0c4576325eba22d83651a79cdc37de6914ffd48025a487a041c4c87768f44c01ba7e62a998cf61e893f21912d636806cdd2a4fa7408e184e65dfab3d27ab305f86162d19b9b783dc38ff562b20d6180448b97ae496aa471a9da5d5167c47ffe7d2e76ddd60eadabec6c0297dac37dd423be4be984fffcf11231d1c6c7bdb206a1e2bfb6c16c4d153f10054dee439f36831ed0842fbd0c315eb01052338f5ddf40785e33493cf2ea5719360552dbf7b7bb4e64d0a0c5062fcf85733755de7998e573504d78dd270bef30c45c4a655363ae3b4b2f5b56bb7fb8091f7e9692e2a1f1194525199e9ef7d030a4b2506eeb19517caaf1a7201e6553099597f77cad520f0da1378861e2a54ee7d540e33c695aa277386e66a877c938e5f708598017c4218a2d464863f1adc66422487e402f90b520fdf305de8f4be08d487f1d802977cbf1f54aa583304c067371c798e86cb76d2aa89c178ec2351107ae5c292a2df5c927766628d8baac5e7896473b255011a439971af704af7310bb44425ea20c84dbee9821dca3556c95068478277efa376fdf4599b064265cca7ecaf2423fc823b15751dd4ab98deb5698a47dd0dfbbc41d98007bc45939e1ded606735eb4abfb0e5272071f1f03d60200afc048b8005e91f53d4e90227d96ab9e61ec22161cb8bf515ad5bfb7ce8777923f2f7f2eccb49b74e4c47c3917ed51fc8bde63f1769f503aa34381fbcb40ed28b8cb46ce72e57de5a38a190149babff0aae16c475baea8091ef277eab43984e3ebf8f57c864972470a71e127e0c5f2c4cf5a38418d786c3a3b5a186d100a9165949d5b8b7cd9c4cd3481af99c983311a33e6455891c2935a58c876a657256b74e3e8a6a6d77e675b8a75bafba2988a5bdbd3ccd8f0194bad4909c91cb2087ef8e3870eb654988655284a02b53618ad722bf47a326ad45d426becdb4299b8b0bcdc265122da548b4559ea22f994a24ce4e50916a3ee75964eab99129269318b4a7206787c39f7cd857df50650f83b2e9c0408e449d97ddff5d19c199b079737a76bbf7c013e239fddde9811aea14805177c0bbfc51048ba7e563446f5a6d6a9818bbf7f8958d0ebe740211eb1a619202153dc6ba1c7026ff87210eb098a675bab306054e9efb002a3ebae21b31c9f588a2cf5a2f1814ce362f191b546f7ca12956219903980e2db0bf7a60c3cec8bef94686cc40e92f43f9777e0b71fe45774f5c2756a0886de1efb9666ce852ef9dd4cfb10a603d3105b549cb59710c375d096c9555f60dfdca81772c13d787b57ac93651b40b135872e4f194cc8f6e73532d762db842ac75013031650d00209ee9107bb1bc94ae35adf06a09616d3adb43e01d9963192324bc453a6c06a82c7536b8a5fe4b2a51fdbee8f4a61d2eafb7faefc14b92776fa00a22a698f12f7cba047bda69b5e7642dc0eb89747cd96140c75303843c09d34452cba8e1a5284443ef411ec23ee65ace1653964704bafa213bad2fe0168c8336dbf524fdace5927c0954c7d125da07b3d619f273924b198cad072e664ffd5a24508ac6a2cf36b5bc014dad14f956c78ce10e7f9c0c0a4f86b86d05dc1e65a642714c25cdeabb837deb7325affd4e7cdfeda74040ddebd016288bcb705c385602458bccbb2994ee5573b782d1e6b9d3b09266c63385f773f5cf2e62967403724f7ae5f97a946c83a7fc00319fa6a7d2bb3dad44c976a36ef1bb37b79f1979f856d27815270c6d6fe25e9b2777f04b91e311b2dbe8656079175bd1ce9d5039aa60f27889a93e01a539612506854e5bc33ae92b223a63d13a70a14c0e332e804ac5be63492e8026d768de188caebc93c9170b15f7457aecc2e36d100bba1aba722395965aa25da37e503159a21076cbba4b6c86bfa6832541b6852ef96c8d33e289c9038a0683dd1484f627bd02605093bf972af3db9dbe8cf464dec695f564a6f35232b83652a85ea1d7809e2b536a90fe725828d754fe0501a1a57390166c0cfe7b488c0c9f2a1927a03cfddb7201f9e0c08df0744a0247447e4dcfc80a3185fc1fa12907df44635c5047f51abce7ca8f9a83174efa3fbc6e8d69792b40589c55d2bf5899db77303fb7485fc0cddb5a285e756ece1f60a8fb5014dfe0f564cc759f54a0b0af2b09f4e05756a1f1b707ddadb446c4ce7580b179bfefa440a48ea1d7c26f6ad3594aa50bf055e5076fd464c76958bcb879a2f9d3fb904c6a4ea32c46e6d494104c1764eb68af3a4bf1fff1bd0a704a3bcc769eb665482630c3fb090c1cea383a26b69933cce3fdd98d9e7a986c27e85824ded51eba6d7be746f886bb0b34ea2412f1f322f196e0d4e98500545d694108a1335d7406737157fc7b95a0423b710685498a54993688c4ce094b1e819d02b1b6f6e1dc38ee5707a3894e823273e8d96ebbbaf8dc8366138be32573f6098eafa799645c06edd4b53fd42ce84a2fe9e11bc32d631b726dc0c20391fdca0bfb19213296fa217ff9db6308ac46d8652d3e59e577a0eaa841284bea19e659c716088a645c1247cd4c42b0094230b33228dffc0265edca7326a867e915c05fe375184247abb481803edde417a5f768c572dbe5f23edeffd9ef8b799f71189bac2f407a6f4a93bf10eb69270c00d7dc4e00f14984938f38176c7a726b214a62a60e08e6775ff1c6560e0e1c7defcedd3a2815b53582e28c8c7da1d01c5dbd1e65767e91b2d6d3c3bfc75011a75997e6380c7626af622e35747ed4740431d4d1bf05b42e1e5192a5bd8090974d47fa27665283e402163fec9028d028abd3376a2b56d801bf06e59e97e7c8899cb70e3f91c377821e8b4249c4f3dc015172cb6f030cbd5b91a3530584b641bce5d396e2e9fd2fdfd0b23957532f1e07e99c7a5e48dcb313ec9daeca6c0ee4326c16213766c1adfbd941122b7d0b785e27a0e9bd07a940e317e1badf75266b9fbe62b0490fb9d5821367ada1c7fd00742aad4ed73efe7820c7cb621923ab4c42272656af71b2c114f38d6dae4eedde4653644b8c65650e09e6f7c93f2ac0d93c113b58328fc11d225f8e3b9d188d3fc2543b10f030523accff55ab8ae59ff546fd5d10ce10289fdf5a0ee0bee45cbb32e6e026782d3168f0890f86b9af9dc5792b4e86f490934de653ca5a28cb987db7d57e704491ff6f9672225e8b63d6ea9aeac65647dbb78de88f2408188de1f03ddd19e4915087fb137588c2e0f06daa1ca5c119fd49fdc52ce38b3bb2cd319ea56e69cc58c2fd5fd1befe56df7a4dde84b700a85f9222bea09bccf22fac302d5b81efc4e77a5529a880a69ac2f722be56b3860e6ae3777fd22be77e509b129d0be38730578cf96437255aa5e7b675efaef82ee101774b27e53d8695f96b46ccda1144e19b73ba607076a51540004b49a5ef153d5b7cd2499bc6c7e8141fe5586c83ccbdf1b07073b8fac23821ff47a8add742276fe7d7939626b575655658f5c6f5447d0667ca60a001f3de4bcdb9d2cd1842354774e0e0d875a1136b3a1d9828a8c9462a0b3153528c2bbb22be2195a21701b0bc4433e9fbc29e3db54d611106625f128618d9330dddb4791de64b9e57159e31d07e92e03d246131030a7478fb427afccc026a62dcbea00534679fb2a978de338d67a69fe0356dd8057b092afa0699b918355b702bbfef80ac841779681dfb2d2d335b5a4d8401b4b478c3501c95f0e124c1947b5534f65f1c34aebe08e791351b6e65ccf839185d5452e186e97df4c979f00ccbf3fbae0fff57ae1a8ee96170003101b71b657915ac70e2d638ee0953cb98ab2f6466942658aa3d805dadbf923231a48baad2bf2eda9ad1c2091e162c64a7a330e7acb8acd42943648cf49949bd19932852d98f3cafabfb4496db38ec9668774bc17c5b79486ca8ecd0f3fb06d38f3f7d026d5f35db1c1df835db23c1b8d53521269121a0268e2b91c9a4d8acc5be8e64a95d6ea516b39d7b6c669979f5831737ce82bb31a1908c5515c8593b2004e087122299e1ac9ec36aabe40a91888fd08d79d896a91c3b405d7a00fab83988e80ea2c60200d272d6a086b119a625ce12f4057138a432423e6925e1f6b242d7fd42cd39db826c3d6d24069c46463b3155e412dfeccbd2accd0067cad192c4ab411d8003208416ebd491481a01e2e9c6bf64f4e2df9c37bafd32eeca7687aaab27ab29b9f3c7dfdc81a998b688a210116c138e4d46e250b2c7e2281c964b6ed39c9d79f1e5738c459acdb9671226c9d693c05f4ae064bddba2db87ab30a5420f0109a17a6c00ff3b18a2e1f2daa7c8653bcad90f33627a1fa98071280613f467d81275d656554d313062b173e142dcb2e6d3d3c6ac1a4b718be67b6645d2c51c6b8f63bc08dc84a40013ec7ede385870dbad0085c0ca8a4f478387c21081fcba42a1b7d57afacabf2693e81d2b1fc339892f2d6552e29d64dcbfbb888a2999227cbae85ec80966df8fb5f75b06c79f2b0d4efdfb49b4b939b758ad3b115432472c4ca439ddcd173646d9a5f90caf2e79775abfd22704a142594d84ce90f97e21053cc59eef9b6f56b1433142c531d00da9914c8363f58c48d05f63dc11f75f68cb41e67ad292b8fef79d98b055ebbf750efad24f05296a5c6449dc286595867047b79c23feba0b26cc3feba3ba1ac471893aae760f14d184a1d290518fca3e460a20696537c3bb535f27e0ea5026f41c27366c2880b378eed30b43f3b8071e0f0be71437b517e13dc74f7459af4c57c5c501caa295f52329c8325b7eb9b8974fbdd752ba3a3a2adb99d2c2b32bd9e779c928956bcdff484d7e9fb9ad587be99d2bd11c2a0021359af403efdeb68bb153cf6a9f11d31000021237f939e69d4c64afc22c28f1301eafb40456458c3b045948b3084e9d62bc1dbd4dc0f94294e7f8b307a7bcb31a31b22fed4bed3459309aa109b9798b26bdf75e14d7ece84c8d425bee51352158726044a8e2771a85616e6de7fdedc692755d1ce2f548e060ce6dd98f473fdca0982a91736e7519447811ce807e94a61d7e4a2278ed4ec7449038e33633a554d483f26a497f50c5368fed8a28f58a4672801f70de925957a4f5ea2090ac651cb50688bf41dcdd53374d69a486012b34fd7b0f4eab69a8e12cf6fd7ab77805e9dd4a67cda7e3ed2142d0b455c432eb25b09df304481b7f0fbeaff7a7466bdadc6af1056a22d1ad19aa74c71d82b50fe54f58a9aa463cc77cbdba5face461a6f59d2581d0203e1a3e1caca64b043f768b25aa82ef6d5f14549ba1f2632062fc9617cbf25d09985ba9a6c5428ceff0135ebee4aa2e5b0e1684f8ea60015bb8452bb802a4b93070c41850ec334508129a92eecbf563d809679c8020e548d625d99aa5f0ce2026445247238093cc8905be930a00df9fae1321593f38a94ee7a51ccec7833560a64721462d3c084c5d974d5ccf388d943c42637dbd07acbdd4bb4a691b6432b0bc4cd3f5ee0d62504694c8dbca13c6c747354b535e50ea4a7367adad3cc90527032427c47ca99cab9adaec6169cb221442cedb689ad803b0bad965c1cd77b0b505cb1cb29724a5faae28a6a6c55e2a958c84ebd7faa11c6bf2651b93753e3006f4eee06bbc6cbab28a30414cb426af6e905c059a22775ff32f626a7da26cb84c9907963b8f7e14878f22ba0674c4f9a53f5d435727f8e1f4577f02db55a6908521df1c4bf8f54de872f80f1975a2c2adbcf00a435d2eacf693e2c66f8703889811d91060c596517b520b07bdade9771347fa8b796aa46a4aaabe6a1ceecbe4b0fa66256fbf3ce97a92ee429e33c411b7d47e48ee8926982fbfaea3b8a6103643e40543a7d2c9e8fa347eadf93b8379ee7551bfe128730d4f72816e2cf2132d63b83edaff80ca492de15c386f534f2fd8b125202a9244e438b3f3c09cca71ffea620e55002f631d8040fc23eb29e646478e4f975dd8043fa517441e31376dfa21a32eab22730c7d4d8ef1d2755cd4f5af87e71d3ea479d5bead2d7a7d6dabe070004c4b7d4cbe818355899e92499bf53e18ee88c5bce3c2c0d2bd9d1f14951551a7865cb11484ed8059ee4f85f88e71971b35bce68c4bebd20767dd62bb305ba2a06e25fdc3bc95fca553799e7e2bebedff17147fa8d0659ac40140b8dfa05fbe44c1fb28ca5cd3e105a17e365d072645e718d8b7c39054d94a52e595c057750569e89c78fe2d0b7d8998a1af86b08373c422fcd1f07e66207a589c7a7350263ee310e885825911cf7a445d7d01c8598a7fee9981628c4672dc8f28ffb4f0108f1d450203f4fe227793673925382160f96400927342d407ee09f4d2c5b697a70d46957b5ab725b86cb99d6e8f0e6e3082e6f281e4e1745c98fb1c1373b089f272f35a75b53e1f4ebef5d8ac9109768a28d24d5a54816a067c734dc53cc74a3113fa7ed86557fd6b10d58dd2ac61f580d0ba2f66599fa5460868b2d92ce2efd8325808850c930e0654bc3d8bc93e648f94c7e52ec9814af8a0f240a3c89a1629af5ba5c4ad339cab2c10ac276f8523a4b435057432d01c505e14f04ca1ee140fd28026f654affca4b12525c8ae36c6c1ef610dc9f379b2a59ad5be32a1ff079c6ad225ce773d6aa517935b948e1e7b6f4fa1e0524bc35da031e71b8910dfd63ab9ca6c94f5c86aaa846526b9d85f3a0ab35671cce66107049005a1d12e9c8bd9ba7979faee230f391ac52b0c171744249c079b924a37be0d4d2413415641be27a283ff4ee8775fbac4d7846be2f4e6a9e1db323ee16323b81a7304173b71cd5a6ee8929224aeb9fea4ae55b91ec5177ec09e464aee47f610f60053cd9f9e66e9cfedf4d91b8e9c10737cbd6719466f22d0352d273aa4403c9c09df157c5af88e027e9856d24b01560a0fc0472f71266fa2549d7524a582f05286433484b181b229195c70feb0078ecb28b3eb4c4d399fad4041bbf08d3bd8593e2c582cfb5ece510612ed30dc4243f19f4f225b97547a9e96de16087237bb3d8e3fa3c2a7d38eb58219414309a55b173c4d1e7b05af7eaa80602ca4a0c49db2f502c10b64c1de0e184829f8b5123ecdcc8d85e6c46468c81ca63761130d90e382cfcb4c6c106b3a56ff40ba085533fd76039b64f7dce1bdfc9fda07d6daecd1386758bc66a5f7b5d8da45ab63dd8a23824878827c28e3965694cec19881e51f03319d81dc8f15b0f5407e8af5289f5f77f3f2b197cb681320a6c5be9f3e2d7d5d702e3b7717bf4fdec13b0918a52d9402270255c9055e7f49e03d16219630b497063f5fad599eb442db4019b64eb3a8e8edd4ec3c77bf8656336cd2c22bebe12104fa279f0e314d01120bb4b1313e6ac5ac86b59008caff404bb508bec8276560e4f85bedcaa28f8937063b1d282ea7e3bae13336de709518d7661489566dc357dd6bccad24b9385e5a3dc2c0e56c196d4804d5cce4844f116f83f995e9602bbeee77621b15106d098930753e9c601a4a1f036f5c705f92355214f90cd0c0e8f10b098321999004ab10ed6201839548e14548239ee24af5d1eb9cf321f2e4dfcc38dd1c650153f072ba3c213c52aaa2861626e16dfff4dccde9d5ef8ed59db160e6ad467d7c915f3aee241a894019ba790eea43a25ec1db15fc41dc1abc475aaa94818848b44646fb40a6b437187397517a30e94ed905707da85c6b328c6da7f70a76bb6ff45e26cb8c67a5a7a3c3810ba37f6153ec5761e2743a4f6369847dda02e1e18de4c4dbe5d5ac74f4446aec93a3d9c083e2bac815e151421c52082177d6ec1409445c9a047598055b047748282cc54132319e59f0dfc094351af7ecacdf4336543b2cf818b932520b4aa039790a23944f37acb73ae3de2d10420e91ec1f149a4f5bbaa94483423c63f8668a6e0372fddd319dca1804e83d6ce53bec35d60bb203258276e7d6ab7cb557fd99065327085d207b2af1a77b7277216d2d3aff715636f17f1f7f41d372246090bb9fb51099cca7ec1583a35d6b2581d608d084645b9265c93df1855040871985fc319418d49d63669bd9ad48c95500ab52113feb1eea76549e9879cf81f4f3bd33c8983aced4e1a96cba0bdadfe28f884b4f0ebd938406e19d376ec1b4043c7874c62c9658259ebb1d913ec31b9a71de264193b7917272af212d75135b4196249fc620740eae69cafae2daa23d5d6623eee02eeb4881df3734520a64a02f3ab65382ab0c393d4467ff8485ec61216d2d3fdaafec5d5f64c4453ae89d105fcfeea2a0f3f4110bce1a506d387519abba030accd5b00b3a1e6eabb7e535d1fc41f4f3fbc9f596d41fa63d2faa57ed3089f39cec400843f50839e7da4d28f6dc4f1066dd3c922f120d7dd5ada41641b066e7c731a5320953aad32545f7ab922687d71a56fc4c8be3756c522377721f08ea105c2d8cb308e9e699c6ced5875ef1b19d107ff08989ad373c8cc1a33c9c1ec8596701362dba056e0dcb6a49299f4ccec8cccead0b0d9b11ec0f581e5b25daf07eeb637ee355f124770893c262d8df5bb85666d0724cb7597e56f1342b74971c169669ba6a9a8fe8ed058bdcf68cda84263ac976b984ac3fb2c99067c884721efa2ae40f61842470cc1bccd2b5e346644fca5ea7a574985616fc01137e2331a59a5e61b8dbf25ed77e69f2534b7987e22b7fe212736c02491f94b74e5cb0e023d98a5506a609a2a4cf7268f5fffad3219550b99ec92ce407eece0ce0524e1ee6e753b29f16895dedb78d0a914bbe50e73e256973cb98aefceb74455ea8a5b788b5373a1df960612c2b7ec484d04324164c29238137b4e5d7405f3b42af6b6d83e0a2201ef6b23553f02406698384c0a76ebeedb254b952c114cdbf495ed4f5bd4c278a9962004d98aacdd46fc165409599221cf67678248a7b32f1a3ca15b1d081dc6055f0c1911bc2dae08a1675a7418ffe95147bf4b35df36c32a9dfc3bcb21c73ced390d1f5b97f33688cfe9ac7e82baf10dc91ac53542333219bad0bd8751270d3338ec66a59059e2d25584a8591ddffce5a4dabc83ff51117b50b6c4e5bb642d075a4688edc79ec960145e86f36af0e149bbea79f7c8c422522c2c2b63dc8fd9d036d703a1da18a54eaff706a3a02bea1babaf8d662faed8e485d8379a0c3acc34440f10810d1fe9eed82b0bee93034be44b1d5fd46afef43af759391218df167b4788f10ba41c1e2da324e809c9ca97a5d81537561c7b2760c010e86bda8256166341c5604bc6602319a4a969ea60f2c39eb934356d10452af2fd554185ef555d8dbb54287f9f4ebb85c55ff0f138bde5001ffcb3b416b73566cdc17220f1ecf04ba7d5b68c83083cddc1507481e2d7309ebf026b3f9d4f9d5954aeba76a00be1900f481063ad137e0bd1cca058bd4a2b95de8315012703b57f5a286cdf71df2859521c266aa1a505329d5d5548da023697d31bc5b5069206f0ffc72c73b7db8b5ccb6daf8279ed5e5b5767c3b00e00d3d533eb9a9921e7335005ed5feddfbc94d839922a0fdc08f45ed93adcfdb7bfb83f95330c5ef3161a5fbcf036649e911845376c8e0f42d0fecc4a5461519365210920e3642ee819807486f5332dac285230879e7abdcae337f2c74a62c34ec4f74f2b0350c6d4369ef37f7bb94a300556901aaf076d012211e22027f8190aea3884e1098426bfaafd5d19bd6ddcc10fa1416f0aeebb425f8549193e8bb249b0c5cb66c1f1b66c532ddc5d20ef5dadbd51a4c7d76a04892eb0c3fecd06378dc948b90823dd7b9f926d8b53bb002df6a5e96b7054ceffbe6bbdd238b880701b76da695eca356dbc26137c295c352425e20db1128bdc8149fd506052e2128306d0e848222f32ede1a14bc8c08c9cbec7af6fd8bf3108b337533a1bda7f254b5278ad4dfe076c243aef475d0000ebe12bfd56524f13600f757ac72d96769f2c5f5a83e94850927bf2fed68655d50daeddd2bbbd39149358ec69c313cba7cf3e4c579feb16113960e38ff8bbd2c4390f789bc7a753244dee9510a81639406dbc3b20638be673f85d3da624a2cc1baadec207d870398213776e50dbf1fadb966b4960eaec8b066a9db48f55e48c82f79ad3a3ed0d004caaa560152649aa26dd3f7ac83a404e2b832b73f8e943a4f5f819b46cd27f9941810ed76836a1a6f797e635ce7361aa6620ea297e821b4d32752cb4c7ac13b4a26d76914a314e4577db24e5afbf4dab034faae73cb0dd6774ea70597cdc2a453320648521708ecc1ac26b1d3bfc271269dc39bc801c8e9c99552d01e4f034dff657fd089d0c095555d579c3e680448f73b6e58823a7dcb3d659465e996aa100d45bf5247e86b25529aa1dadc7b177907e7792c8a2d7b052e638ee262de6248cd4fc9ef25c4591c051114528078b897a1a5933cff84599e220c00232cc392ac00995f005d0045ad0fea20817a4756aef85e7a5479c1b8faa804e3d74d45d61daf687f6feba8b5694ee7ee46c7dd2896632c7fe34f433ffb0bbd72b734da6597e38b1adb98a9536c3cc4345101a493cd31ea03e64cb4c36503d652889fb68605b41835f802f7d78437bbc0ceabe92923af86d1161232490676fce4b42377876a7b02ede4412d3bb223bf8b29f261a435146f4b89db3db0d276757e796e1266a0f8532ea40566188ad4646ff486c719a74b8e20d5b79b10d8b6e4132730f0bbe795c15413bd0c735f5eaccb310c55a4fde2bdf35bc9d5041c4acee184576181f06dc0adfd90411a72a180e9b2a0bde5ac436b5742452701a9e0e62dae364ae59843ac92fe7a8150c1d8d048363658f0c30f8110d5e831608e4d6334bf07376fe4dc90a47873501882e18c1ab62ff158d5c86d3c9a8b5e809514615cd0ea4aa704799b9f379247e5cd1fdc124b22fa1480cccbe089f316421be19553bf7f03d521389e001a0d481d19785b5088a49704154140855e9ca299018c0093d143854d127cce923c6b0ca72eb7255e629fcf0695f48930e386a6d4028a281549ae8e3b950f9d73686b147b3a16b6628d49b9679ea4951a01cf63e3e08f4820e8c00cac2e84dcf538d3c9c9f2f4d40c3a72c7063ac41c0847ba135ead04d45c8d513d7580fc3e41433b33f177d67776a3ed4536767d7924dff45f5c7bf01ea192ad09a7ce6fdb303f1b65923d3b9493c2209d65b0896b8b0a3a547b5210df807c39a05edd7f7c4b12692e3ab3b3c66c501dd10e1dd9a064cb3fc2d57a7708d4bfc6288f008a9229a74cbe0a0fbb68b8814ada3a4279d287ad8cd02b180bf8a057c25116b651c038acac817799b6eaeb611b960e3d7a029b51a3b77f634635469681b03653596b7db6fcaefd9c589c3a6ebf26803885185d4d3d1636afaafc78a5470f36c79f9387f34147a6a3bde4a9d8ebc0820c6d0b34284d45f26a1e8853bb292428dac793d4774203a5d3da2ccbbef91c89b1dfbbac08b93fe4ba38945024b2848eb871f3972d6d6220d07958acc2e17f9d82913e6190064acb0b4e5cc867c1b61839d7a14c93262b1bf161d311c64c0f8f11b3cacf11db160c7a355f63b6661b60c47c00807a413b1c7dc325d737d111f6a445583d26b80fb3fdc4c6b51aed45313967fe7da67f2c2a591286a33974ec06217579f048b18024e38668485a0a2919751cb96a3aeb3f204945f47eb5ab165418c12935980a5037bd0e507305a314b484e7695f9a28cc586a81296410dd6b77c461e8386e2967364ba9aa9a0aa2c053e1c1378da7b5593c69274ed24fa90e434505b133ccd3d23beb92847068d8eebe1b24acf38ff71ab1d23c4fd41cd910b392710b1f8ce4cfa1915708b94b075806eb9f8850446e438d97154e2e0fa446ff2e379e7d1474074b1f592c5a27b281ff39913f57a93af1442d296eed213ef110bc39571ed8c0f7672b603d2cae1452699db3bf4618f0617da53ac550e38b3f4efa99ad8b89ba36812b283338880c24bd398364e93ce89260dbbc95864cb1f315ec5b17d172c043c11ced606a8458344943d97a19b01d2bdd58096fd495ece946b88b0b0402005db2adef8bd9c9ac088dd4062e58532acde379970e71cedf71907f66c16378c48b5eeea8a1c1570ed84b401946fdf6c80862a9fb950a60e303ded1bfcfbc1b94f8e00b5d6f2bcd14321f60f2e2c7bfa9acb5a753c401a67e1aff49e52ee8ab4629c1a3a6fc321428a8d086aae1acef8c42f3ab2812fe8762f8d5bb8c272e78f8d45d9d61d0429b5d3aa78d418745fb94cdaa55adfba201bd4ad1beb8bde6ed206d8c35262ef8e62e801f94efcaa972c67d3503bf534f62d71bacf1f0e62a7ebd93d71f100a29adc8debca934af8f3e8009d59ebac912a17247416cee4ac168a2b41a4e794976388cc3089cf551336884218594e25a9bfec676d0b18d6d999e349e972966de1b274aa654f35af18d722966127d5c3dfb43ea361b7a79c8b88a1b574b5580311426ff14e5aa7e99d68af40434f5e920555a933fdc61d443e63d50951b7faaaad7ef2f4ce01b5d95157ff50991cf48372d5c8d25df62072b626fc9898fe77b1a37808d9c4a40fc47f32a95cad50e52d827f038d9eb73fd49f38b2bc0ade7ad7349668ac65c395c68e41e42c777ce7a0ece8d0d02ec1ccbe9365044f8918d1de8545a43d3ecccf1f816b30220db2543dbd15ae58b21b368eaed1a2aba8046907a952f9d8fd49c02c66945bf4c74e5f5b8388ba579acf923d5719f7b16bf65a20e200d8765eb6931dbcda01a273e09eb736b0a322a9af3f42b5ab8d29bd8a7605df27e0671a581d7f03c250a0c825e0fdddecc694b0fd2a6ede970362200baa11dfd21d417dc0273243112f19063395920423105c918ebf47a0ed660e4c6b9e0822762c022cc4b21e102b185f7b74a00977fad5c636cd8945c3680cc9d9f5154884795c0a9c49e1cbdd0a4f9c0182e6f89d51dae9dc6ef62aed6fca35cb08c4f431fbff548aa167d368c140bf4d6b5e6bb91471133ffd3dfc2fd9f25572e8a925d845b69cfb4cd135b139a82fa18a0fcaea0797f2dbdc818bc7ab6b25dd46b17d27dcf2b87a828e2935030773cab38f9d420f4d0cbdf48fdc32e862461f8e83bc53035e4de984eb1bf6c8b66111f39d66965e9d924b57f38d35dbe206b15e29a9946291b2dc45e7c75adae359b1a7594d282c42689db9a96f0faa0ac0155ce6613115c6fc069f38e3cb0724b865eb08e56d0bbf43daa368f51d2c5934a5e0ce1e55a816f35c9610c749fa2ab7e57c11680e760c508b1be4a728e129cc3228b26d3307fa3cc53f1da22f45c18fb3322974e4d8fd4cdf4b958e46d30181037fb0cb3d3b45cec860598f837dd9aa013c7aed1348e26d32d88e7685612839c1e7f3957901be0b709393de16d8992378e27d03bdb8b436b9d3a21234dae33deceafb693314f2762fa8f3cae6f1fd4d084853d0b07b490f043f6b27dbc3d72bbc458f1fe1bfda026840f7d905165a1e896b937b107e725409b6e1fccd2969e26bcb7910424c14477b7cc03e58fa8fe1f7f1bb605258ca58a5ad3dd38a6828a8a396a92926775b8b6ffe4be39afe179fbe7e552a88d978d65b050d9f5424e9964a96a0b4e77ae28aae9e96b78e025edf0c2d173f2c1f406fa38deb1bfe6c3e60ae3fa81a4c98cb4e1143ba8c7b2dde6821a6c39501aabcce33f7f4b66fef54cdcbaaad858b0720b7705cbe81d0b60352a8a4ccc0a3f117b5cfaf7a52172ee568034492991266d29cbd5080aac1e147b70215e1fbdbb19779babdc4ce09930f2d7c69bc09d11a1b33ce5596f116f9b18802ef7e2de267427bfc2e844cdd7419a6ba8b5e4c3da897b9a0d236c0ce0acf866b18cad283f4674d4735e8ea997913aa01d7761513f511d693c8f952f1cf1dd3d0e98e54e7ea97ba0238c81aea2cb2b160c44f62bd90745ebd974974be93a876dc768a175323f2319712b63a0c2b4181ba07066d119d5b038b14e467ac6326e25fe74f22c62a5cf52a557ae34bd8974536d0c6baf9b3bce2ca292abbb01279510badde02bd678b6328f7d6d346d2adf43b9954a11b8c1780b358288a2636a9db487eab414fa2e79ff50af6fefc1ee3a90aacf3818d2e2feb39735998c93576f3e68657da8073c6610c2d44407ab9b5359377d869797e93e6c7c5c4f1e73f9c6e39bf930c2d8a1c0315e2567b441173cbad38ef3f30238d774a5267a7d7d646e94dfaabe41da17332c49eac0823b1e9928f3ebc27824907d40feef77e72e0a05be86a4ed1ca659eb207d577e845a5761c336cf309ee2186d7a6e67bfe212b0ebe5d2fd38aaa76c13e83bd73812b5780fe0d305e6fddbef1b54e1da160e038d5e142f152f871e819334b1b86f6512a74c9ecbfd05aef7da605b2c179164cf221c5dce4c951e3d440740aecb64b6b1d0aced042db7d20086ed20307a5a7a7ceb8c7b6efc2e2f266412e99e6fa392f78ba08933c4700856700b73cf6de7c52d7880716f768e131ebb4267c6428c84567453181aaac79edcf9a835eeeeb52f38b0e05b1d7051b217486a67864d03c716af9d977d5d3ca8cc268d6eaf43b9ef7fcdfa77611628061074a6a03082ad63b35aced47d91d1de1d08332b49f08483497482e36664610dda641fcd10324286b78685d0d95ea894122f421095c0a438dde20660ecc57b818c407bd5de8ec7a9c51d8e074551b4c50566e4fe3a3abdbcb2a9a8005197248e80a590426237bc89b693c4e56b6acfa119c6d06eb6a7862338a5dba2bfee28289c6161481c72445b0e2d2b62a02ee88da55eb409aec9a66e3818c05ecbe09c75b46eaeb157bb5485c68d7d08afa4ebc335a726ecfef3920fde5a2716c8e65355ce8c4ac25dd60e090b241b9a6028e53d95a618256209857dccbf2cbea2bf5dcc600b734951c961d711bea7466c28fd6c4917da2847a2a740577e50dcb94b07d213ec5e92f695fa8bd1cc3aa2012b32e8f5e3405ec191ee6a31db3af39a7c97bcae0a99a30de136120e113d0e3f8a5d52674230fc1d9b5b83479d0356b363b842fa5695e360def3199855b758a702fb6bd155401334c30fbf714b07b2c575cb9a28be243c704a2408bccf8eda2ae9ad3a64c1f175df99e44482d9a88487191293f8020aa3130bfefdfd62e9707b617e5ae37909b6946332cf4b7599759bc7afd18f8e81197899835a2b988e761fa8839e583de380fd1f818826f1bb508caae9a98fb0bfe8f6ac5534513ef745b27d35e01a8ab4f4ba37fdc257a9c849f368497073ad93cf579e7454d0c36afec7ba8d054e85b2ae74616d2b9ba2624cf33738196320d87ce10663cdbabc4c6b90f8be0de868459a8e95b9fbc88cd60169be31b7a5c98b4f22e15889efc31f6efd039a1f437ae02d828149c1f397e9843039cad5f07ac2df0adf4596228f0636ba71040b055c16f7272ae1954e3354cd5466f72e7ca634d9e339e17259c3a2af5507033d8c5999c7c360119d94e136038ece391246e6bd66c0b2dfa13107c88a002bedf1f5f1d951da832ca3b95fecc6fadfcec16d2c7f183420a3e9e503e689472f4710745ce0b231ab210472e8c19c34f57eaaff1ee2ceb6c67e3e234277b2c6c68b09d8506bf9169a17b1b7ce14fcb53c1aaf1469f036ec6434fae4f9edc7e808d30d1d10a0396d875825c21f293d778a657aa8ae40daeca7f15a8d1278db1f2a17992ea78f2b6f45c250ee2c434d734759f88743887db726f2fc4ca37d8f426df86853812c0be730b2dfa1b9346c8af21540dcdf832ce6d82cf95965866bfd6f287a7962cb40c5cc3c3443676f942ec0683b44e893d42873a2bc23c7d86053eb32fe9e380aa0bbfcf846b49ffab0304c38509083184f5e8641de04b03f51097bd8a18a192812d80984adc0c7b53f4f7e68670f9fbb6a2d8075696f0e815e8f38e71f93def624eeb0a97697dfadab7de6fe951b9f8515d1e047175826412655c86d45f921740614a653421941a75222d8445fa2ee6c24c420981deb3609e51c7cb8b1cff6224288cd90574ef774d9367d38e065af6c28d5619fb8fce1a7dd3ca85ff9f0157296d9f2bf78fac2dc68064937cb37e3efffefb2fe76ecbe80b24aa5c9584b2a64c5cb58a2644bafc5dc86e949c81d1b872ee38c7faf1f4ca05d9760c0062c574555851678494e4124bb83dd9ccdcac76b7a48deea909c9f4f0b2be5198c555ff02269eaa30c9ea9e6341da70ac7d96c327c8163fc6899089391f244778eee10dc123421ed3cdf537ee8c15b383766101b447bd46e25a79ef4e61ac98a8787d33e12bf91ae98f3623e9f9d11a24542c2dc9ed3b60a7937073d25f12eb04987b80d7bc72d7fed48275b0518f9634d876b6a421d4d130bd07d22e2586c786a400a50af98cce23549445b34f83f29638ee57f20ec1c703c917779d45cd5338d81ba4ce69ed845588f5f3c45ed5c9a692f20e59b447399cf53bdccb4c52ddfe0b1d36acb6b22e25a50536162ad2161025858141b8c00f37aaacd7d4b4290f07ae77c300bfee083881ef3f2a6233d616ad23852c84f471a33e1a6152c0dc1c5565a7f54f16b42d4e0a9bed8b27d1e28d9fe70d27ba3471aed2325be11fcf3bda76f377e2a8912850730c770401fd82659378a4aa7260791b89cee223539ee2e5e2b9bc2d200370a769264db79369818aba834a65720e7f515596c0dcccb17ff4170577b7fd50451b6b684e491d37f7e953748dbaa2910611071c85712e54fdecdd07880fc094c3084f8ba1a1c7f6b4a4dcdc6273737bdf3244a5d6b3f7b75520d147a417640c1e7d09ce7f7d31cb2adbe4b48055e5c7fbc07d10be69b594ed02092f7eec48b22fe2aac2d9c05e65a7835f41d4f49386368101f0ac9c227ab2be457631e6adf0771b186dd33bd138b47a22dae199e0ac9852340258e9e18eaf735df9c6839d7b2a88113c0918ccbf31c23eddc890d94ab9909cc25d40cc5e7e57e92f7edd3755601f7987a13d306622041da8a4a9bfcf5bf14aacf3cc9e73490a57d6dd0b5b107d54e65baafa9a5f4c230cf410c4017b72951c5c27049cc08b95ce0e8edf2fc3fb5c9ac68c11a48e41fdb64230b05137fe620c63d6e0b7549853e564421452c6fa03dda9786c9c380b24b0a19ed895b9a51066bc5406adf9ae49ba7907c9af38907224f4eac88140122c52a02ace0f51006ba87cad0678a03373d72898ac5d041fee182a74cb5c49f7b63e66e008e0edfabd101c3573b3058c8f17809b7c98d123a6349f547b6c5ebccefdc124fda4991d246e40f54a478f7587323e8823929293ccd35dcc26a1ecd4c68a170ec9a2274a2d31f495eda66efb87de5ced6a7212efb5efaaca21531dec1944613fb68f208d2075aeba231e6a903b897d99cc38347a57e1266e83099f054e0708371f7033957e4158b847f41b3ac76f1de7cfc0b7a1f357b765f92bedc1defa0274b87119d92b793f7ac7df44462636a67d33cead2faed839849772c9b1128ebf14623147d930f2905b14250d6cc792262851d447c2c7c143c78b3d8a976f9f366507f4aaa208ba812d18b9967c6544d590d124ab5983f7bdb2bd2954a2199f5ec7369b4d2f6fa7d14dde917714411d3ceef4c6aed7a8f2e0f4cec0cad033709b4f019fccb180fe778d15d0053a6fbb87984b5ba3a1d493d82ab633b473457d1231a08955a1715468edcea6dcf7fefb9ed4ac7e37b10d9b1a39967b71a345585c247b61488a82433815175508331c417564b875735128a253336df7e0ee3836fe740e817c1328cfd28e813564a2edd1926cf5711a612484e92c34242d9352ab587429d58b1834483cdd36f2cdc3cc77c6181927b63bd3cd3ff30c94e442f98f6e85f41a46dadaee3f37fa0592ff91d164a8cbfa2362098a529568bf548e41ce680d723e0c405b7ed7c5a5a59db154c7ca2fccc6d7430e4b6cfc73eff416922dd5b7cf262943e3fd33792665f604d8e064092ec415d6267835e31209ab955bf11b6350703c4313a364f550d29554d1f98e28c97126c1fb214eb141d666e3ff4c5ddc29380e8316b9d7a6436226e197626d6bd73cf8e64d913d1921098a62e2f89571e8e972d3c2554a186e0589e1709ebb90ca8cd9bf04da619f4fdd93c1af1c5574ff04982c991385fb0c03d640d79b3216e9b6a565a564d32cadef1bc1386679ff5cd491382507d385a319987197336d51c4e8910c7c198334444c26f3ea9a42dfaaa12eeb22f191eb3476ab8e2f4e8c80992d3a770ade5c43779b40ea50fb99e192bd3425b39a512d18af44689ec5ca605890e280903c9e99bd5dd391894b2d7f444d583bd6ebe26045d88cb72ca5df661cf80da5bad59ac3293e0334ba989455434ed4b4481ea48fd724f116ea4243e11668beed44647a969b337a2891fd18fa2f8a2ff94019bd0833bea9115969dc2aafbca4fd8b1f74693723e23c037a61538f8895749757bbfbe551c13322c773d9ae87097436c4a288eb1c106e6f2e57a3ebe56fa0adc5b8abda1c6f5bd1c1ea199dde2256a35e584b17f3d705aa71eed2e0f515d534c3412ce239d38afbae5f60e820ec3e8d532b127b72d2d17a1bcf394348e7afb84b266584c3bb6a121667e6529b27a9ddc9506de90d9183e46aa651c3f2286b9f3bd07ea924a249ccc5ae0463c50f2ec78eb57808ffbb1b85120578bfc61c91e647bbc697a825c2ef6c38f9c3c6a5d2e473e6a6ac751ed7a7a15efb564be9ce917716bb209936477bd7524d3412c03afffa9649c6606fe05f98d22e63a6839fc77655f140060f70fe413fc98083569075edd5d657b02345c9e44a8da31505674f9e185989b608e9f5c6a26e6e3310df13c168a8a15b4215073bafffa6ba0ad609ec9e61c955b6440bc21c2bd4d6666b9ef990582aa94d86b7acffbb0cdfd00c6827eacb06b8893b9405736c3202fea621df82642c585cce154dbc12b3c75fd9b104043c4d7ae4cf429934a506ea919d216fdc39e28a8c38c065717bdba7393a30ebf027eaf6615793563053ba3cf8c7ead28ff7165d13631783786957a69aad680462f118a187f3176597ad40085546ddbe9df4b6a7db457c791ffa58fabf7875964a3affff425d2bb1a12b3a354941d705d4129543c79a04e46c1877f60777dc3bea81aff2b38d5bd2b817256a9d0daa9cf9b248f9330056dac2ac737f2bd08b10fd4b7f0a1a2717b6d7db23321db8cc5882e5acf2d4f9cb97cecae626ee2264c237c1156774b1c9f3ac2e4ce24e590c4a96ecdbb84f0be9b190002ba9514bde6508603b00d7ec5b1611dd808899614fd446c7a73344074f44ab250e33a3cf9486699356654a2b14ca184023cc93fc6fa815e348e2bc59ee633e8828b5260d7039c43ad1711caab330b2e39ede9d71c64d9cc9d4032ab8db125b72b3333c1edd922131ab84b97b0c48377168b699f6029d53470263c3323e7e440851b8c4023a0b7e759c1dcd0ff0e4d005e77ffcd72a93e6383afed7f55cf0a044405d4d03d7068f38a0383bf84bd3db1368bf0939695058d1cc9194eff11292803e095e0624b0ebeb2c38f1447969264b601e2ac25c357b8599dbdb9130292ac6c094f13a8429720d3f69d0099ace16c639a72bf8ec243ed8615d801326f5f8113ff9ef12fffb025f64895aadd08da9326125fea5dc1247330fcb741dc164a83408864dc6b99e1980cfba204ff51100493015fab01c3a7189da46e8692420b7ec3581e45307fa1e61f5b28e346a59827436b2707d8d6aa414b5c63741c20abe0dd081da41cc7a288184003d6835d2065e4f50e836ecf8eec59e719a6580531150c90e94995eea391ce4d3f1aa03f68b1ded26e93fee46484709aec1821e64413fd0c49263e4b512a588159cd720c5ca7128e99050b8f63e74a4f786ba41bbf90dc5edea585aa681585b2b2c584c2704ba8b42d15375039e0813783b6ba27c87df53ef98e35b9d96108da81a40cde9d4bd25955e8bd35a89f129053a62653dac6a2cc8d380387b4247fe5a139f514bd7bb877d818d6c92c3d5040a2dd5a3bc42c8e538dba77b479c00cadbb953c088f996ec5a8429bf59b0a5cac6688d17e3bf44c36e02467ae2de47177c070e4602f6488959122723a464ac8d14398a4cb37e5d75ea42f60d976c2490e86bb68f1c6ae13cc57239389b6b918cedf319e68ab51be7cfdda19f36f14e4598970da275586ed771d36e7ea2d443f2cbd7c11eb56007c2af967a497c00d36bef5dc1bb2d59cb08c2b9dd96ad652103bbac4b3fd4d6faf5930394e5d180c98628ed83cb48668f8bea688e6a163516a12c9aea799cd08842e9659fa00dd8dfefa98e1e0d37c965b71e4bc195706e38a01e93802f430b57ec1dd7cd0ac0c797cb67bba86c9b96e48d45da9f9d7917dcdcb0ab08dbfafa90ae09526fb8ce6477d893254878a6122fd0b7bb205eb00829b44a0cf7f7b39677cb6270e4b6e97fb24970f0a6998b9cd891c15e401f695516d8f9d807f6e9454f52fb9096ff7a7326f57923c109df71ac0e911d97dd5118f885b47cece0a3329470d80c29a034f100163fcaf71a8edd7280474f4a2a26955a5f9610968ef84146adc3d0f9386d13f9c4568e62608a24e17689d9aff4f57ee085854835f8be003b52f5952d989aba7cd57226d99e94e321fc24c72c1a293f933d3c4237765f15fbea8993b5dc7aabe8462d7954d7ad60df1995da59ac7a6f9ba13a4b83624fcab04212126aa38b46dc301c1352e2e4b716167dbe6f157eb28825af38611dd1ac68c491e5e75dbae2a91657d0294ca1f0f9601d2fd92e48310ecb8670e113447bf4d0304102ba5d7994f3ce22c58e22f27b35902555538308a664f92e4dda6350824a1c6bc22177e9a95ae7a3fbb1a9dd8f89fc9b9187bd1913794b61dd7259a4c7482b432c65a049417ec1441837d9fbedfc3179119f0b83706601d1c42aaf34521ed3cd5eae92925984c8ebe5210d360cd5012964d1bc0869404efca51b940f92a2c022865416fdeea5489505fb54919cb34e9e60fe9029625b8759b9c159055d45475a8b67a3a83db08b43661f752bc43f89f0e97965f3863182e83d5665e1633cd530e4d21df462317260e4cf4e4ab98cd2efc14988fde587e36839dfd30a67964ae09236d81cd0ab590c92583fb60d14ddb96f6fad4edb4f7eee937b2837a5a2f4a3dff3a1443556ba5772612187d661455ac3033b35774201b50e57d9dce52ec1ec7ab45c6b73b94402efac378b94b20961daa1b5ade812a3940d850f5ec03d9fc1a9fbb0f6079e32b6f77ae2000ed6e8d2894bc33f2b7837a3549b3a305b5e38014fc70330e27e37fb16bd82b6200b16da41f7654098cd85aa6dbfd8a7161a855749343935cbe843189daa28a4246ec0161d224620ef4c864a05ba8bfb328d846d6497899b4fbddf35f747b56b502da4ab4971fed67d2d4f46c6be9fe72f5e820b759d6446f89596f19b5b549046413c25ad50bd3a1a2d81362679f2986de976fda34d1538e211abb2fc978bd973ffd6418ba2592f08ba6e66c3bb2c93302850b5ec98740ccd2215b4b90fb5fb1f378cbfe3fc26bddc8ecc5cd3add6610c3c24edacabf98ebfb92f79613a9f1dbe065f77c4ce5850e07fda26ea06b693bf97d178513a874729a341080d00f679ec869e00faa95d1396ba09c7ceba0b27f72587fe3999e4fd520fcab28de8738638d88b81646efa1cfaa5527b18d3a21671f920c2661e95213a9dc327a32bf6bc34e461f644b5f18ef2768c8a599ea40063088fdbb8ba06382c68a502ed84af7ff2b3f27086ed34834d363d34840ee0fb456a49bd9de025028e4156459d0b740503f856bb6581d1ab907e7c212566cdf6d4f47984122166267b7f2f2e5305d8731398fe8f0f7975676bc083eb8e4aa2c1b45418b217f52d4b59c8649774120ff63ad685cfc1c2a1a2a95d9d2f401cdf712f6187d0f668c4028be70f699a2586d8b99a6ff491f616f8966cb05d7385db026dde1a60a4e14bee507122046b2318fff6679835c51696b8291af2452ace8fe828e1b85f1fd7fd800e2305c33c0a78c87942f5ebca5e17f6fff24fc19c9a09fe6f9369afae3d7c75a66608e639882f7eef053ae17fe4286d7d5d0b4bf811c0049f0c62a3d1f649e553e43011bb4d62fc4e2b930ab06da3bb4b2f29e0ec8f0edd5df2ff498ad894099f1818a20f8d7284c57efb5f57652f951d16edbc0f1fec8cbc8a3016ca6dbea9540d1f0417af1300342ee3da317217b424d340908b5fc5f23631b3a99f567e42027141a72310dd3e6d623ce721b6a3dd76e0cb526e4ebf7e4151286d8662014bdb95f35af062721e9755fb9a2e1a140e230f4404d287f190e4d265d3e0e4c154249521e5c3aba326066af192cf8df4b4956db820fc30697f331b4e0e6001878adf41506f9a95b89be1eb4ff4a74e9cd63ba9bbcb494aa9f104774eea4dfec0f2294dd7d55a8df67a0a3e5e134342417ae48e7776af81ba2c182e55afecbd3345f50ade62e0e7ad5671aec8104e81841f5158ecef2eea0dd95f2766a872f53120d31a470a5f01e7b64c5a1c58802df2bb1df057ed2ae1e3f798d999cd16500d15f50334a14538480982f385ef50656e02455c3e198f2f4f13fdd781e8b5bcd5014da96dac36b218e6ed0ea0f6469f6192d7f70718a6ed5a182f6c1480f7f00c25e3c19c644f00da5f6f07a3fcc57e15503aa362ace8cc16b1672859d21a5bd2cdfc4529d785ef4ad1b28fe426dafecb076c003deca605aa877aeb1c27471401d044531e0f6dff2056e37796b016b4a61edab1b1faa530e9eb9bc1d562a087845e3f42937b773786a0710565bfc766fbcdf9f8ebfb658153cb6f915010b1b1015fbb322b690e35784f450b462dc90f18eceafba55eae25a3c38b37172ee33230ec4431c9844906a176577699e87b8cc7d73a67ed32205083aeb0a778fcbebe408c9963d4d47acd2e1eda0d78799abc734b403d74d74b59b6e12a66fa8d30ffaa0dc65d151a8326a50f54de1f575fca62ca9a9d31faef2f88d426793f2bdb3039c8262b7baa78ce01710acba30b7dbf96d3e2336796d2b6e4f9ccd210558b4fb40f238891c218a5d617b3465268a60ee9daf52b3a9ba3f83cb83d1e7ef2f244f6299bfb35c1ab65d3750a0a1fe40a850c91d41deb47593fcd34781293fae571a5286396a3e262c17a135637d2645081b32ebb49a3d92c4913b62c0d25f58866582abbef1c9096fb859abc466c18db798b814bf7441c994ff120268aa07fd462129d2f3dc649bf4d13df7cd4c8fcc3ff8e0bb2f08899f7404cf5897444c7efa60be557e7dfb0b368d482a872c97d7abd80bb4bd13c71917c1bbcb5e9c6c8bd028551463813a95ed858d8821af5902df54234922ec187dba39d0c0b94e81d266121f87fdd56565370ac3b37d002ae594306069084e107ed738c1e1e2a91e9533591ec3e33bfa9afd10ca51173907f52a87eb9fdd5f7d8eea372fbcec4ec4a73373fff250aa6aaf302012db8c732395db37e014312c938ef4ae73d83b8db03e960be391700a0cd8ae49eaee52dffda551a9c3c0e2c3903b6cbdba83cad454ae0f3c5ce311fac0079979c47ebf587221717bf6c7f60e66645eb2abc928408cf4ebd17a5ae62e9ea9f7f901c732073b3eae1c35ad682367d38ac2806ff2a58ac211ea22b14b4d31713b329310c33ba77d53728af0fd8cfab66d2b668b71be6a3e9e8f21217dd8069e1c26ab87ebdb0f963573231a1918d42f9d1530f866de02571208179670044e28365eef7c442d0ba87bb73f8387ee4fb93a5ef1db7d6faf7efa79550ed23b5bde59c9be9b9a77479c791dfd02a8bb44e5987282cec79187e772c18684af8d2e8701ca2e209a0be83cb4fec4e0a61db3e5d00e8d595cf1fcaf669cb2864f4a4106f2efd7c6699acc38c6894c70bf2d33f7219ada55ab5d6f53fa65eadacee83d63b711b29164092d06fa93019da9c8a6dce6d5cde26a49f1bc48d11ba49bb732c4e0f552770b4139bbb3e31c2c045fc76e8cb29c62ac48ca7d9baf936f71b1a099b7af0b65d65b728c2516c1fc059cb54ace791646888ea77a406b2fd598071f6612337f5eed71ee6d75d51185155937640c06b033e0dad5d3b649a87862abfcb086d7a0b2f998d3e82d039b265e117e2c3527271ac4f9ded21178514a5c35275a9701bd4194eadd9e4a008c7c0a2453cc59e503f14c78d5226774a706f3ff54af532b56c86b73377db69ccda712d4bf143e32ac266ca2c567902e00ac5aba9e0ddff3c856137a25aa1b8507047ba8b17d2cb0e03a9d6c8afd39077750c274e9e3758177ea1e4a7c62837baf853ccd9ab68373a36c59f95c18f7b16a6c606a8c67b9efdca3659fb4d9dff7b68a5cb15c77ba333e1987448f10bbee583ad5de9975bb0299d2f4a770076fd844b6e45b18fc1c42518b358502200039e046968489ccb1daa0c7cb1c7161be7671f0e9a47778e8a0e215d499398da7c0e1da01b150849ee75de7e3ddc8d7c196aa76da2354b1916ac71fed02b492d8dd765b99340f24f623fb8b109bfc8450f2dd6f8f6e17e4b231e7a36cc6beb337f9f2f2fd975a3a516316b7c0f0a9b27aae6d3446858743f33bef7dc5c045cdd559f80adda4a11c6123ee9b8e9f044dfb497f67ded62623d0ef400dabba2ecedcce67d90445e653b8622a1fac21719c75739c1c73e5fd56e2201eab206c131b6e9b305c7475c059f6b94c45fac83ddeb5a25fe898e8b06e48425beaebd3df1b00cf193202c066a3ce5e336a46a30e26d598180eb466ff7f333d835e5f49210c7d86c1acb956c2d6d3c47ab2000520b161dc0816424b9fc8a995165927cb6fe5aa51fc311a671910e6c50a80048c5639d75421ccc3cd4e78f219c97d266d21b0f2c177e13c456faef125c7782808c80e80e9853d402c150b871e6e9dbb38ca654203d1889a790d248538382485604d0ca528b55bbe3f4adcb45d42dadf5b7b33078d9dd243078aacc377dda726085061f7479ced34cc5a5dfc95d39073b18a685fb7cbb4b75ac8ad0f9c760fe29425b2223f7790cc0dad05e37f5c157decf5f030654ac56fe206ed2cbf7382f1e541e5583801e5c8e80dab209fee985fc3d1f3d8d788a0487da52b05fccb1d302cef2bf7df3559e2ecc7d56d7e81132807c1b1b13604ef5acf462918cf38cac41fcd81912308c1d2d1be96f975db891326f44c7c1d11f2efdc51f274ed956e6e9935ce225a362bab03261b2224d05ac9a0d48256eb713c273e36daf6543c7fd793fd3249564608567f1b41e0d10789324d03e271d3d08c5dc2c1de7af093829be710a7ca6499eb8e133050a4ae7f01d834f74bb54151b30021f9bb13cdfa1eece55890eaffff7ca2002d9d4df6862d6a95f849da37dc61920804826f97f81066857d7c6ece98a7acd1490eaf7f872f22d5970ebc19265e804f4b688ea159a5fd9c043c8178477cf652f6b4fb468f38bd5c4ed9d677b8747acffc445740b60408e68c29db2b80540192c259481a5056579e8c9e9f3a3f7d16d945b786b110fb95422e1742bf16ee54413301acfcac5176287a961b16a550f4d45a6791512b862d15e9db5c97dba18ee1b901c32d605a57797d5dd1df096b0a1a3d6ca18675fb10320ca7b745373ce8ea883437e058d5123b08c16ef065b24cf26da7302ccda26faad6908c71f1d9efbe882f198520eb367499f25194c33a592e638a17bdba327ac62e7fb191b45169f46a49d1f67bb4512e2d237c46fe9a52ee5341cc9109dc910ebb6f7082858cbcf4dcf669f513eeb4fe527920122db415d4d07ceeab191a066847fae13806e2cca72fe17ad9b3545c538606b5d0d7c883fe943611ef1fb18c091927d5a88b543fc65a5f94b59c7f281fa257415ac06a744dd44c1412dcd54f09548f76b6b58a622e19e395a49655e8c95eaaa85d2cf8411bcd58daabe7bc38f9905fc054fa7940274075a4c576ac378a12b19168cefa829cbacbf173d8064617d4084f34ad3c09a2de6b2c4791e8d5d3fb7fd26cd58822df0ac28258c5088fd5cc2ca3186aa8dd0aff2fbe71c4257c1ad10f77401eb3404c66e32070130a173573c5f49f8a6822a84fbebf3e1f5648aa46b82d9f691e72eafdc6246532f04caf6d411d152f5efd2b0a027452195be1a21e1d3b0481f029650f28f5298940c56e5672c8b1d7ef3dc97551867627279389432fd8b03b573e31f48f5e101b75c93e7c4c71e8228b4e8dd1465048738f3947914f2f01cd9d7f7842d07c98d3c21ae3dc3c90fd8db11ebb7549a52dbb11b3454da70a9a44ef6766c3cca367a171f295d3bc62df2faf122f5f6ddb5b052b3297b87ab218735b667a9e08bcd86913ae139a1895dc8b0a15b3f6ecd14d4a50564bbc51d63990a8ac63d1017479a4cbd00001ad826dc724d83bfb6fa43d3608b25e24323636152cd0799d1e03bc61322a7cb848833848de54bf0a3b138abd4d1f3d3f56b45b37a460c07b1dceb89a3e42df8bbbdba2d1cd604453df7f8eb22aed327d43d4dfda917575aaef8f9d1f3c1c9f04fab73b435285e2617de694fe6c851f8ced4f61b4964d637aa2a33cfa657eb0c3f02d1e20bbf66765a622400608ee56ca5be8f29b23db35cccfeada2a77be43672e0a2948baa9a93d7212580b583d5edb5f08a60e8bb7649562bf4f7555a9136256809ac15453ed8eace0daba8fe95f7ffbfadad09ff4a49485394d0d103058733cd84053107364909322c416445eac166deaf2b915d549379a00f8ecf91445322819e03e0b0635fa571d95a19b2cb83f7010e42cc5d003a33b7cb521cc18dfc3c6813fca5bbe2587aa5bde64da97c4f4b8ba9c6e01c489ae559d9d2251dece9c491f0329cf75e749e65b172f2065d780ef6beb16ceaa170c42653b314dee410faf7ec488b1fc9e01c70f24cf27ef1e15f4a64d7d26343e69f25917921198b891ec1afe391a841d3448f06bc3315363f027642451d0d07c7f42b47995fbb8ef2efc7012770c2499216bd434a8d94002ba60cecb46289539e273459d129c27145be008c06561048f62216a2aab3c35b1b7e0ffb38ff0238d8f1a42120461e7c295202d49e468aae0d1f48d6cc30dccfbe2d68d8ba29cc8775580b3cd0b38f193be33d34dd05b3893643e79820bfc34cf6a1983b46be7b0f2f4f65e5911aaee2b5a870378e5181bd58d7ba8b53d8db3427ef529d845af815bed0be063c1572a51fea65cecf0206b4f799cf43ac97caa8a83cd4a6e48e06bb2a2457c1e435d8b1fb9a69010b2e4745ace806918d54700d9794f2be3c6bcddf36d43b4080d9f124b1d761662e78a7e345ae9b252939dee0bff95a4bb17bbf63e22602a7465924f783cf8cff23e3f99bb8c11d54f86d19ac5c8a9ccb977490934a01a56ef790c84528b91cf342eb7dc41df8e315c1e6df04227873ec0a0a3537ee9e252cf4ae88b84095531c1cb1dfee1c4a6aa37d130c157f2b568c23982d38bb67a49774ac89a91fd6a4eb9f6e445aa30ea10709486a6b437ef580c2b6a164a11549b0c9b385595e6d1dccaac4855637c80ef2d61fd29fc0677fc6a51599714030beca8ef9658c4d0e0c1fd46aa0f2606133bd1bef907b5970140d5e5b63dc4f82f382556f8c14171b2c56f22e04376f820b4352b8c8b4cb816f118751a588bb795aa49bb0e1bb3a3381478b42f39fea3d1929f0299fd599a89e031b7eef0907dea3cc2266a7a3d27c1db7f8d4fc890f8f49448418dfeecb58f28f26acc1a81b185406b7f5312664fd6ac988b4a3ca86c93b4ec0f1442d5cc9ec0fc8c5874b542c4f4d962bc75018ec5aa0e205ce65cef1d1e5d93c4fdf58f3d23b38522b458526ad50d5837e10aadacc2019c4da57a3aa16f39116bb2f93d6b076300f0e33dbc60c5ca251c08c325095188344f8b711c883b473efaae6d49ab0ffc0bd40c0ed1a21a1f83135a73a76fd1ae0607bbb14bd44b752613a418684a6c8fa604eb3b37dbeab9fe2c44b70f89c68bcc90c49d5bd90e1be968b98ca7131ecc2fdc2130be84f96802186db73021aea31f701c6a05ebfcc8cf3256aabc043b5108811b6bc1d1c535ac9d95295fd2b30206da1573a725d9e5c0d5f63441621f622ffc271c1759d087c36ca27268b4e8b6991301d4766076be48ac29e3063faff4be7ec900c63137a65f2bd1b45cb4de4d666618a4daabfb266292b17547ba98969a5ee7fe7332cf043c4c8fb090a2724fc731a167fcd4bd8d42a1472451e55562851623d700adbbc220d4603e3543a466bba63c3becca7a444d6b6be04a1d161f091607c2297903167f184ab9a32b8321e3e6d5820ab43597cfb16ed5cebfd683a1d1dd2bb3b579b56dac4808686808dc424c9345113e83702f5208dfade5a52f5b2d008162b330f0b2c901be238cee3998b6216404228a740faf4a9e86f2392dfd2d907cbd46c02e719fe941a9502c68e99f43b6f9c52d1c2ac1d5e6a664f27f16bd7ecf94ed5de10dba5e520c9976ea09487ec16fe13cc2a223cc09e691ced0c4f4a432d48238e8398d43bfcc0da9134a1409ac16f95d52425279ab4d1dcfce725dba480d6d9460bf4861b90e754513d9c276f29484180866ddf08d901c713018c4cf6c7b0f9d4a13c5f7c8ca8064b690426a16945246e7ab2041a4e0dd061e911808990acf2c34f702998a6b70bcfe43302dc2c7977c01ac454f83ffa188ffcb9cf0dd343433783d42585ea1b986b04108079c31fe498aa50d81b0485c6d305b8ceb8424c1e4139db4cf48050fa79134e9a7927fed624672d06bd2901e6c7dc19bceecc5fb71dfe273bd86cbbf361bbf8df08c3bee49a4b26264c6f30f01c0f9663ab00ba1aac18b9c175a6964cf1f827c10966cb8835a1bd7a4c0f7744dd2572d3ca7c26fb1033ab5a472d7e431eb3d14b57035baf3b7ba9fd8e9dac3352bb7645039d1c657fa17d5e340debd67c2aa6eb3440ca33c697360de2b0675231c5f3ec1fc58a8ec890e95429323a6030c5ec5a2be44446d834a62e7b971d48bca153cc40e4e6a19ad7caa6110c85ca7caafd619a5ea52477fce832f765d7c5bb63969a16bbbf8efb190dde77ffb10161683faf9f4b6b08a7e947a7cfd40c267c738212f141b4d3eedbfa5c078258b871efaf4dc18a02fcbd449a38aaab19cccbe61c6393baaeab6d5aa2a0c715f768aafdca8e7249633ad0515f58c1661ed709eeef4fe8024c33c8624cbb630f051e11c47faaad7c561efe69ac68f89df972d167e72b9806e199b936dddc624a791e80b7eebd7cfa8af046411a22e887f4709364e262e12e8e5092e150b22c6c37e8679d4edb8f578c677efb96feb108dd11d5b079bd6a2be38e4e6cc412524afc51a6ee83fa3407d9342163196ae69bfffceb803422ca78cf350623d977d13be83b3f3eccaa4c057f4cc7874bc9082ed90e91b010bd5cf84f80d743ada72fcd2cc06f29000ff5d18ae05a74d8c604378731481d7c56667ff2136937829be5b0934595068cc9a13eee3f1fc8078ad53c625207aeb8a7a6212260d97c9f9a770c65dc339e84b6ad6aac51194dc2ab8fef8559bc7e37843d3f5981ac44b6f454d828b11c168b611dd4a78a76d9af8b893b13dc8782e3b8b5c1821f18f99b58e7496ee1aad35f8dbaa375c5e0130385d404509110cca3cd639da44eb7c3588e4014f16b8c542bcdd826ca8e72d8f921484f1d7cd34a5802428bdc513929cdb65823b038a57ff8805ceb645cfe58ffe36303ad54fa19f90592260a76a20c6ed8f2923869e3a4cac0c14051f337c94506133aabb1305e7f8e6d84546b6281cda9e66eef74dede5340591af06bd9fd87176ffc48636aa4d820e62dd865dc3ffc24c41be73c483d98e34e71b8a9cdcb24fb4b6c7bff94dc67acf0ba7122cdf8a323069ef1f58ecbb6a2e9a83c40b31d4c7b76cf212379a1e8b20249ac46a7b5090b46867f091672a2441d9f1533584b19b238936141509ba4775765e09dcc52932d0396417195fdc94dec3bdcc13ce58b2e8be3242e5f1f72ec0d37423fbd15377da1465ba168b058d4d8d9e91d0fb088d9b02f1545cfd3c358f92b73a31ca3869ce2e0e2e38acf6c312503688f2d5d13b7a5085ba6ae80ca94a54602ce0956a8b510771eef4bdfd415eeedceafcbc7b99805ebc88c022954ecd10e8c187bca523835df2ca301a98651fedb97b40ddcffa96d08950aade3f04c204dac4af95304df473ef74e8d8bbedfd899b5c7fca583f87398c90a42ba19cd31db47a6dc4ec0902e4a2fc102b1c96fc5b9e66db11856ec81af0f389a938c117c9ffb70ab358c3f963ca697efb412a7760db189a0baa93c4a5bc5ebeefb84dd68f54210d9d0322d2d52032199be500f5d66d75b4370c5f39cdd58622a7b0e41cfc67e1e795d8c4f6f5f5d230f1fdab8bbbacbb83fdee256f999eb36a19177124a5a38645a1e9e3e0956095d8df887acd395c59a605f650f3ce5531b08805bdc46ff1ba8b3650e6cd577e76c223d9bad1f3034684f7b4b84bd5ae34b8273d8da25ce4bf00ef2fa256850cf810a5a059a4f5bb065844cdc997e111d5add6dcac98ea0e5242602ed3049284e52163b9057a7a479f61514d07494df32969fbd50d6badfa9bb03e62e4c57704a9f53097d53f1e5aecdfdc4995e8679187819aabfeee471c4dc80642ad00819981b51efc8cf968cd88fac26dcc716e09086cea430fc6665d351767d25d008c2f102ed6ba198ca78bc0572215ddb6aba82d9a23619ef928a38a281b89c38f2ca61855de03a78db0d805425ef2dbcce97323b34f7a23392b2c8a868dba4c2dbd8077c49dd41c4d38c5e83147bae719957a449415411a2ce653c013ce4b3544570ca24f7de86045eac5d2a1be67ecc455a585bd29212989ee5359468861e61f6b51a88a5c6a3a8cd8a2ce04afc0ab1d0c8eb03d93cc86b80032885410c6d7697e87166562fcd2cb6c15949d1d6b9ec0cfe59a9ca53bf25c7cb8600ed7f9e1987257b40c7c4f768f3fd5647a454e2549914b813a17f65165553a459f8d64dae01bd02aea531b3d7273c35f8dbc1d0de8a774b38bb1fc57f66252699208b9a0e300a6c904bdbbaa1a9736e3b67357e62ea9e59546ac864a0ca111d8c16a6266a94592d8d3b3f4483d955a8daf10af3147ab2504296c8d640f15dab14f6355efc3eead62b4e4421dd9b4b19d7e8e79c3aa869c5a06c15d9647aa4578f2cd4f2ae356032fd6c2e7311e5d926f61efe24e3e2bbce878b355500b5eee828ece86d9f964c14f33a196f43612142be75e94c3ee56015fa2fca2e7f7cca9cb6357169763968d5b5753773df7f7e585be75901f65e2411c1371cc92a79cbd312258cc60ec8685f7d2d9abee5473efc522775d4fc0162906802b6aa0e03813eff947870d63148850a727af1b822238d5cc70a17df111435152591b3ef49c2677b8b3fab638074b44e7b3a9311dbd6beba6f7a5c6cb4aaa1d2ab0ca9525b7f5ab5d22732e538eb4151152905a8115c8a26a79c3450e436fae6ed125557951ca4c0f394f02fa85e318ad94014b9b9ca6199b509b2aabc0987878360392393b849a91c322ebd6947e2e87aca7e36b144fa4a66f497b084b674f60f92b754761e25265aace4e47d6d9818fb510f5c95336422e6ba2aa13b483a3dd6b92a535fc09ef85bfb3981f9d39da3abac44ef6f2bab7d235fd5ddcab28807c9f14c21627ea153c9f897b0baac51d82ec7d576531a31865caacc47d5ad944650faccbaa3e147bac9fbdbd995d5e7144de851e37ae53f0a90535418763cf004708566f965d1b5cc77a5779c80c196e6ba0585a9a579869de9d83e5a68da7c12f5c16112ee1011ecc8d9dc487abdc13e815309fb63d6c218cc434933b09c2dc39f87aed9b0ce56bfb2641efc22fa4d870fac6f26ca99772bafb8799372124535cbdbe51cfb740cc3101b54629812ada0d3dbc4fa4a4ef79600792cda49a16e088bcf5784d4c16fb5ca6e094873cc271965a110a5bea07da6800bdd687d0c24164d66350d1b726cebf8d96152acefe91d66643b8f80150733689b886ac4fe7d0a908f10dee3c5b71911bd7a0556890f8185f53d9dc2733a766d5baa61fe9a19261b164293ba4fa120ea186805cfef42a2978f6718fdabfd2011e4330b62a81453646e31650462c384656b67cfa82ec328b0a4bf9dc36faa4e720d376e3f5f6cc4b4afa90a953f1dbd0c7dfeda1917401dceb0a6c059af96b056ad53880b6ed934da1b78005b9cc67fbeb7ffc0f5bafe0736dbe7f10940af17d02c997f8abac90147a6a97e6cdc2909cf0dbb781181d94de281157b402d7681aba567bc2b70be36134caf8b83ae2e0b1e0769044963bdc10c5fb5e7494a753e11d589b7411e2c7f5d3177019d65a4951ba9c5ccd212ff266683682e429622a3a2885eb7c068a669fe1525661fb871230f8e929066ba683455166ae0e315583b044c1df4383bad151a27edb75c7c5ece2f42daac33a64b9ab126269c653ce1ceac38edf32e5df6219ce157fbda2203593832343ba4bc5ccfdb59a8db1504f3bf81156a4c2f01f3aee05174e57693eddc7de3459b61a7dadd81e10da38986137d9d68f8c822dceaa7f3420097f47ea90e91bc81631f2323612d2043eb049ac351c086dd8f4d8e1b200b03e092986b14a54d7192abfb7099c6b969a29d9696aa72430260c9efbc038fa5daea3c85c7842ec49ebbebb6bee69ba685527ded73ce4be575a155ba9ff835e9ad623d44796ee503cc36dd6e8c3f315261161701789c4a1119f5a0eda107e3a4eedb30204813df5a42a74c2b5ce70b1c39bf57e5f8822c345ad8979e9d0111381943453bc886a1f71ef05dbc95a4f1cbdd26870638522163bde7f7cca9b880d3b3377e4135acfae593244e4f476ddb0305dcfc013ccb7a0046deda060420f1ecbb8c412edd3c2168831a397bc3ab29b2430d8ff4afa69f5aa949211ad3f419824b84455c3b22408885fd67b3e97706956876e2ec13ea24457793b36d43f60f60240873a040c335bc187de138e0c61fd10d027af13cabd833a8d4ea6bd44a47eabdf827923fbabe85445ac5ad7506281198310d92060b23ccf7477396211993e9ab6c7496a911bc6ab5b277d0e45540615f15a51d398907566265c36c13077df2b159237a94813484375867e21f838b29a407cc5bb4759f378001003af546702432865742afba830f36544b98d48901b683ba6d16880316739089a2b3c6fca381433821d1893edc2a90556703d4c253edb5a838b22d350da6715a4773e2df5f4149b19717ec1ca186d0b23f0a2adee1795eaa184994434d0326e1311dc420e3dac34f2fc09cfb673e4f26cc746a2a8a9732cbc45655a327617b4591d647e96a29df4bc3987ea4e4d3faa714061939131ee6a36f06037179a71d9f7ea0be62717d23a3b9cfc6b91bedda8838b09df35e0471c533e71bda1eb7b2c47a5e0fd9592d58c433f63c03994ba4709741207e8658f0a4e32853e6ed19f1ce167831ca3b77e7e26e8b4386025194f6eca579ccf54fd7cb98af87dbe613c00182520c96a22db57f9b5f3ddad5c5991b9b9dacf7c92d1e8318d8dbb2c9714a9965aed658d5749db319a0169f456d2c08d1bc20a60a456328afbaefc252192db0153272416f21659ed5b0f9ce2fda988b3351e38c1d967c3dfa58a139dab5accab5991ebb5e929a782e0690fe8f91b4e564fc107c6642d51d125316bd4f4d1c5706224d48373b8f625c2b822e27e0a4798051be3affb1b974c48c1551a5258450820b465189337f7bb3fd917451f1ca14ef149ba1c5bb7c11f543b01fced5e4c95feead1a91f19fb37dfc79f7c72144fd235cb6023cc8a3cc6b0d48f355c9174b4ef7b1c6f74a6490bd8a5a36a7408b34045c0855d3c569d97321189d7e597d330a43773029b2d98bf3bcbb977f5e6b6229bd92ff57ed3c9dd5dd4a25e702cd4aede0278c53b35533ca29385fb310025a27ec681f6c77a220e5acfbcf642159cb92c07e5330fc85c33ef250fec1269a23066629a6547fba926d0ae3c58e6c33537640469ea69b339be8069579720701b801bf9830225afa2b3a77b0fe269c12477f0011c8c32c6741816e9983a322fbf8be28465759c1b0f2c83ae577808e2522c3216b6cef0d468671def253513b4e679274cd92f8b76fdabb8bb91f78fcb4c763801f686d8efeb3480701016720f6e26093891b08606d8874abd0ab49f899f6759efa65932e48a158a0fcea6d03e28866e8d0eb759aca8ea881d344d79ae4de301bf02403389bd27fa3d5150386cfd28cd3758edbbdf1352045c2deae27098cd973abc6a0b276ff14a80966da5b917df27d4b7b6285aae7f16ee03b84cf7b1194f7e0b78c8a66cbb966d2dd2f63a4e6f7cc129e3d3a8982f26504f453638c12d01fd8e185ceafda621f4a897b1474136b857992a0a1f60a671391ec660bbaedace5250e2947859bffae78976c7ce643f00d5fd92c10b20f346d909ba2369a700efad96777b30341780affb4ba60f2b34abc41e1826b9b8b5d70fed12215ad7dea2c8a5ee2fab1a71595f221a2ddf4dc518920b82483f298a559e619c3b87df52d95ab7a6fcc35ce75ae420ef15a679fe53b88a520eaa96f593b5bc51d3a021cfe7253ea0ada6d2aeab764ac355cdba8fc131117b182386c6c6ff8ca9423471fe24c5c5a283a823fad85178fcfe4f0cac2b2046f91d52f2e8982c5e45ea66aa186c33407021e4382ff05662d43e935c91fb40f504da7571044e764abb3402b3331a6743df8474e480964bd443486bee85b2d93c047b51975469a64070f93d492ab6b3cc8d8189024ee1d529c4828e4f0211be1d9e83be2b08f2d52fbfba5975e316ca0ab4d782e23c7e5c0ec537a05f20760a3c339917ecacb2583bd9b36b6864dbfb62c44f078e9ea15e33051c0bd8004d389c0133aa3e4a67c3dcfdd0d8b40cae876f2f162626d16d3a4e3b8abf62ad93ced5ef04aa88e7a30effd8aca1a880904f50429dc1c71a821db2cdbbd429b94ed75f27d66abeac44bf0e2b0d7a7f8c71c204a8bafae7c780d078401b96ed49bc9106d4741294b84630ab3a2b750bfaffe2e57638442cb942ecdb9a8f3ce759693615f7b6e27722649fd9612f2cd26baeba5c1c97033c644d567cdc4892689db08e62a51b1bd45e0fb30f214aa963d0bddb3d8448b711a963f743a1dc9777570b11ce76c344fa07d17451e0177887a1ec17cd093975a09421845d22ad70706d9cc874a2beaa600125b4b153f5f252cfd0d01bd676708758ee139b42652277f55376d0672fd75c69f6c95f4fc8e00003f21a6e1ba1b863069c374741612ebc800a487433ec09d501b26ca445f1aa2772031a94a15694a71b43884659e1a4e22254f480d1c9028624f7ab1818c1ee162b7f6a79718606a912ca1696e94b285bc05d8b90ede584f6704a0117af97170581729d671f294d8abc2261a7d8832f85729480e66ff1fec43d62049eed263e698707a1f48dd5827fbbee8d3025157568df84558df1804011e37aad43475c483069db7a643e6f37abc5db10d3bf90d3a5e55f6511c9f86f1ad6281c1f450e5652eade4528a0315d71babec72fb42131b75fcd3a650dd4e859425b3530ab82c5f6bca66b7dbcaebad656bf923f1a0585f18d8d28e638dbe7fecf1aa0dbdcbb160b5124772db99d294e6ae6b44e8bf1247d548559da52ea2ab98ddae7f901c8b7d20723fa7759a314a7ef21810c5709eea4c090c7a6de0a62f99977063c3c2587c24e7d9e2a441dbfe61c25d390a59af7f8b7c7e4bff6303b4c4e8839b631f89f3f49b72f7938924a7a9e0bcab86c69741b30fea6cea574c22e49a3ead1337d20d49b4c9b13919fa4b670e44bbdc5017aa4e92eb23ea87f21adba40566df515370b983e73d3c7faf32b1ae45c13c682c0daf72fe7a2c6125408b63f124c3b61271c2949487369dac638fbd9122af711f90944899969e45057ebf4ec5ceb554077c599c30c8eca8b1fe1acfaeeb1873c2813661fcb4074c91d79d2cfb00d4b32a82efbce19a71dd16e73c5c4712f4d817117d835c00491dfeb011c15c0a8e2de2daecf39381c0127408954ff1a6e7f33eae49bd4fcca5803f22281e1928b3618e1d7d8c9879dc7dbe98178787268ea6702e34a497292012a15fe32dc810e482b4bd194415a50c8fb92192bf6e053e93020cbc3c7a18e3ed1cf8ae84ea63bd6b221fed5e8546fe738d562fdccaa1e08cc879df7e2491247b2a811d865177a7eeb16fa70e8998f094c25cd3549f34336853da4ecab9783de96b0331c96b38bb44cf5fb7e2ebcb9c41eeef7c919c77a1b52d1b0749b43ddd19e0e652533b97bf0ca1f28ba4cdf903af8dfb4db16a76c79437ab71d57c1312c68a25afae52b45e4c26277294335fa079e5adf5b44fb75c5f588e4576d000df4e642170226348870ab27e3c2a18ca63009234a0eb5abd3fab44bce78b43f57287f3e637b7998abcab181e99b5a73878292d0bbbdc6c05bf8bb7fc0590551dbf1d57762b4402acbf95629980006b7ced48b1bc64aedc5ef6154470f90bcce48160b40c9dd55adcb3cc4789ca008bf23c7837123e29de247667fbf555c78bd82d6f9f0f13699e580da3d2140589b53f42ef43f000473383631209a2023ded5a2b32800d1f98928b81338f026228ba55a4638e505dc4ef47161773eea73ffec2dee4bf2c13a503f730c76825d4f44926188b7676361a8208721249e59fb020636258b38bf17a528413c088016468df68e48b059f86c9c00244720eb3b08430c7e3836dd237b40761ac7c452b725d39edc63b95e364b6f61fbdd6e445758e96053b44932a7224335811afa05a92e8f8ab415f2237bac738ddc32c9857f27fbd88689c356838d38cef9471a8d5ff631237496f55fa07edb88781e8fb77ea5233a809720d64a7894299db2cb36054e4c5ceeaef565c4b60cacf6f07b72acc0e1002343ceed83894da405aaee42dc12bafbbb9d65499d1a4379e00fbb9a2203f74567b730d714965f10d3862a7704e0ec3d8e7e7a8e7f3d211c08f4650f40550332c66f04514487a4eedb2f4904035355d2dffa1bf21f0a7a7efc487a5b05da0908c8ed101a973aa3237cf73a73b668941f7ab8a6e5fda88b22773c3f616ef0f579ea090083d9f623112ceb9bd178d929f07fc8bfbe6ccb548db8d41623a860b872c3ae4e86d691e6eca9c3a826dc4f5d84c6288945f00363e82b4869551b17f27fccd0e3432fa8a9dd6f803585bd2047b64f9a7ada1b48d644837160c6ca65fa9372aa48903cf79859d918d5ecff6df96a0ee7c329ca8f6275806146761e6d371a55a00f4b0d357e42183e2eab6a20b8a380628dd2e5254a3aaa610c6828eadcf0b1a69bd1d865600d3d60e687040180e68c2008be19be0a81aa5df1342c61337c5a9f3373779b941ddc5c4099f40a307bdd605aebbf237d206a29ce503d30169fe8fc3892d62a318fde27398134eede95ca8252a4a16cdd50e0c1d06b4e036333a5a2140f2276b512ed2c51ac77ed5a793803cfc60bec8f1e0f13094188f92a1f7e83db7452f801db6cd2c64ebad7cc4571007113baf75b4f395fb4e958028da4a2420754fe0a5c66fecdf4e0c74b71a5e7b633793bb14ab77f380c43997e32f3437482d5af5abbf0b51a0b0fa5b2bb6f536432e73542bed1c32253d65920698d84d39ea56dba281743239c0dd46b981d794b70ea4886924cc7b2b3d4441c88cfa5052636169715e982f4993351c74da468de3bc90b55d1b69a92f1d7848046912df295d99217a8f2a594690536f6a693057e3a194b7cc7c7303ef7851f386545c82a44b6d93960eec0e6b3736a21ea490b56c6da334da39fcf6f5e2d91b7a2e7c117c29d99f373cedbbf83f7cb17364d65d48bbbfc490162e07eda13b389d0bb97d455da445b5f766803be0fbba44b47c7605a3e60a38c66d8dd3beb58720b660f36a9e736fd1ab5c2e28b77efe23862ff531eeadd59aa34c5a3c0c8d3ddd2326f217cff4acdfe363133765f5457612c238e278eb2cb7b1e294b51035709aaf28b4223ea995cf7c61bca804bcfa79cb2434c5bb36edaaff08bb46d13d56ab52cf4c69256f2c4389e35d71f78b66a8277b19c8f1298810a30df61e6f3fdc5042bf81f7eb0cf48d3d4745619d9828df04af19c4ed579a7b2c92289fa11a1281dba61bc544157b5c6314de1435b48167b16c04ade5f0ab5a91de6e0466df3327b6d4f6b28c9cdb5c28e2434290c13178706225c2a31a998404bfe893bafc681fcc3395dc4e1d1d5af076a7b24870631f803fd1590346907ce8e58a676bcd683291ff39c6213a9feb1681c72b5165e9779d1a70a95a94a58da8bfe4bec6bb0364edcea270e3773dc309df65d45ebf2bb22c0ee7a139717ef64512bac687e7a22691ff092407e95070b135cf90a9edd64ba2e053a3764322d3378ede8d55eebc0b24274cf4585eda9b0da3c08141260aabf87aec7e8956d3b67b1030045432d2c65fa8787379a59cf1e117e7a061ea81f41fb74ee4667f838b4408666518a9951222eeb7ce925ba6a18cf2813507460ab84ad0503516333dcbd1894a58f264999d485e19acf85c0f9e4ac41a129fbda1105333b8ca664f80855b193b72996448055eddaeb0bb1bfcbd042a238f2359e2b6a228c6f053bfb73977e363a6552f5cc145cf931f3017128ee08003d34660aaf9bd2e5822ee7f6357fbf538b138a22ff82fe78fad4ebd3ca41e27232d3f12abe538b0e59f8fc9ec6dfd8be06fb5a98f6e11a13b17c1339b7718578aab765e14809b1a57211be2ab2dcbd7116cecbb14701f27c0300f34192676c0ecbcd1fa176e4e1dee9c96f8c68cddfb96d5cfbdf39bff6ac015253eb298a1326658a81114c38ddafd0753f5dff30a53e0827247d2f2e41737916f5699b1b83a4ba79d294b8f1d330b21adfd94ca3da8868078d0f146b8006c00904aebfd7d0473b8d1656d26e90c550e30a9dd3710511b89d978e6134b716f0779a2b74a2aa59927d3bbb8fa2df7c95225efdd11d44bc92c8dbd77c7398b43925acbeff2f3607792f14dc2835d92bffd5767276ff4be342c68e4af57c0ac62511704965fad995c5a2e0843cf63dd9a79446b5d128926fae5ba78e6aa2a8bfd0fe6aeb55a8ccb3ae543ff9213b7c938a5802fa5bf92ff0e3032c2401150ccf91b6cfc4ba616aef4ba0fe0861eba3eaeeae6d75f42501f1db6464322b33418aa342fe6c0d4a82624a05befc56c7cf3bf67c079079f2d261078d229c76977a9c75ee23f4b68675dd80c5c084b8995775296f5a7fc8c78e2081acc0af8ea5a1cf02e27aa15b5145d86e5a7f1655e6f4d7fc3d1ecb912d99b3989bc9a6aefb18608967705d34633ef98ce1dbda4f2dc23f13196015fd8852a68ae1ab3f5bed8ba54bf1fddb7dca2e86fc9ef15394debc154578a0403c31b786d2986cb30564036df9bc63a4551e4523c039a769910abb8c94d9bb6596da22c91b9a8e45e72eceaa2b1dd2a27a1d5ce144e4ed7e9f41f4d63b738839fa918d7a5ac60cf3776ee927519c76ac67e5feb08d65b60222bc6691615cef8332a7d19bd285d6c9972131da5bbfea12084c7d950a7eb138d1693cf973bdedeec95d4f309e3aaac3922a8ff5d8d8d8d78057ee131d7e8a511c674b21b75d134e773a5383e9a42ed7e454dd93748d17bb09b402ffdb80b5f692892aba2106566666e17e203a8d707224b30d8000282aaad107e05d983cb2c7cb3ed4a82870923bd12929fe96d01f8be775afa85d1ec1f52d97df9b43bdedc66525b5371b82f76892352749ef69109fb7ea6916cc9feb086794eb2847091bc99879247eb9328c6bb26eeb82544948578f745e7da57e86b56a76b61b20070e03189f1b7ca83df6147acd61aa3f160297464959ea86687040e7f3b6c571af9dae4e301f67adf4f93d13f29a19ca57b244a27ea6f22a814a38fcc1743a72531b9e2cbff62d73d9ad8681565542a86066438e8f9085d3d261f18af12c5494f5e1bbe9c2ca2cc35f0af8742ac3fd636b8ee12348420f186681fb55965bff0124ea832effa188455710e50a3284de9b516a731120682ef83b358da8028084e3d135a0717a52d8e95462962527b74aecadaf0672d46ffc19eea0f165c8d8301c8cda504f5809061166c4493b6c89a505843a386e967e59fa078dfedb9594201560114418256f9679c8e8ca46b672876367a4df28ea14f322bec130142d4b0067894e64294065d7c6cd4d27cf746bc85cd5e57eaffe590fb7ab2877ee15c9fe96a60f84190e0debd8883f9bd720288ab5664fe98ae0299eb31e55ebace0966bd26601de7066c6b2ab374fd080e28f93962b7e6e0e301bb1a811b52e3e3df7e491e30288ece5f02f7754d13aca2580c503ef3fd550e1890738cf79d5cb6288f7315019de8a5ed8ea870636c2a165c8d8abd0e5b5a6b8601abeb819445eb777419b53b5340927e89fc639102eac09f97d316a8d1f93f4fd529daa971b03744373e83237bd90cb452bb4f81e53d6e05b3cad712e7a61505687b7355643fd0a5b8b7e49df27a38382329915028dbe5a9b60c1802bdb237b7fc71ff14d42ea59a79d9ddb751e8468a46358bc9ca7ede03c8236e8ba9b621b5181fdcf0e67838ba0f6935b1239283f695ffed899a93059a6f7e42834b18d17cf8aa4a45d4f311b1d01d777edb8fd999bc43a4c48c431207dcf5510f45a001fa7cce9725bde17c655128f30e7e30357e87b9761faedf74c767d07c101a95caa2a1937057b3a39ca899142df0206573f5ae52a8b1368b88ea37da03ad2162aae11cfa879badff6226fc09847250339ea07758d4745837ffb7856696d771820c8a13fb082b7d1c33b455f6b3fc5070dba5ad3985ca83ebb13b441723fdb666583f560806f57988b207f8ec1682856e3238d417a850a0f4ca3d45daa3a0c85aa3a505bc2fadbc8c6aa323ad9f38e944e2416d1d9f6840195dcdf20d9f9a8aa25ea3d01a8e72e063f7859e53719b1223b1ab58fcac381eceae1600cba716106554cef42c37aa591a5eaa1d0f2a659a306ae37c4ccbc5d8a76e9f1667212486291df116bed47c87c9d65d345e9fdc8e66ef907e6e1cc91a1196a8aba275ab0a9e170bfd7ef17a91c83bd34a3c173a8f6774df0f91a76ca7b0b0b6b43de1c62c661a02a3222a3c41dbbf260862f131cbc81cbb28a9306d6bd7d06a5e6fa4bc5b46437102f720fb33e4eb3d4ae3fc46fbe358e61150885a3483682ff075b6b51c7af22b1a8c43920b1aebdeadafed75ea9520865d33b2a62a2b680fd01ba6dd4e7f5ccdf371ab78c33543172c92175434287a4462baba09a642272ed5ce80d1ac8ffd31aa5e2f14d16eda904ec0b4084a2cb75382696d294c961ebde337b86352335b537358252c696f60287ef5084f9d46224bfcda7d02ded92ffe7d219e8ad1a53197123af7bd03c8eff6a038e292acd8836601b03f3b54d29cc7f10cf4f448b6bb6fa93e1734a5fb94f88d69b2a43adedefd341f30006344dea8a5e813a2ba1d960f61b6724c091a7c375f74030e0d0028a9f5389e0eb3a83090f45ece108d47174be93ddf2a094ab474dcb49cb817e1252f79c8fccd11644854ad3a31ec36138f086a39eb2a542f3ceec99996c9b5d76c5712c61359d53f81420a1d06036c6b102aaf2b862ace1139a886402ec802fbd51df7404a040d787a481994dc0afac19d726e03766d0d0b6d0ba6d139499d52a306d01544bf44892d5c241504eb85ac0f87123cd42ce2a4f3b222154a6ca0bc3cf6fdeb8dfe1ed74c8d094ad38d97be38b1b1687658c21f4b281ea2b45b28bc9615f2ba3f13a5cd5b383d7d279017b172e546aa8274c4584a6b639f6a69989173bfe93a5fa50046eb67fdd6d9861cf1c6f898541f202c95dc820b392632edc74bedbcb5d99835022f9def5fb8450d1c641ee8afbabac87049f4b4fdc7f11a09d1b94744e663c806915f1bb7e3eeb7689e3481473ce01ee56248971cc17d45a647821cec33cb0fc232bb3e1ba219201b3dd7ab2c70aa8b570bc2d09cbfd997bf6504349986739036d31c908dc3e68e3ab3aeca8d801e6f8fa6b49eadaed1829619c8d0755066bd44caa1f3db1bc61b7158e4d304a1f6711fc86417ce6906c02e10e91fc10213d93519e6f502b26dd1de87643f1290e8c65c848ad0656c0ef98b5624adce625da51f0f87ac08677538bcb313947baff3eefb122a333f85a0659f05f87c3d71bb79731ecb999f782667dff185cb79be4fa8c3b800cc5fa414bfb106563c87d38278019e7eba2e19c2911f421627924c6335d9cab8e1fec73906e291362c6d97482ab3b3e6a481dc920d1f03fbe189a5b22af294a52bce8bcabacbc4e737bb82984ea18b16316ac3ca7e4e6b168a0f4e722cb2a2740a3ec482a1a56e51b92ae32e3ef791335b42864583e76af88b422d0e6a6cd8a6ed1e0c68cfcba5c5d5f82e92aaabceb8e73cbd31f764294dcf849f0fa1f91e85e3aca77552caecb01c009e6b56e0ed422fc345cbd68f4135ef363513ce88fa9e573a0801ede2dda6266894d4db4b9571442b838d5139084a28747acef9dc5a21f53cc779794c8ae17ecc6cc312c7ea5491c3dce047a20c528144f3d7f96b25f93dcb38b543ad0e470b6a2c0fb778e8ccea5ec26bc8f5377cc07186ecc95c546e1af8a7f0af1ace2e33933b295ddaab37482e63aed29363f07e713c7d603fa8f953a35c51ee40a70f279883be989e0169f1e0ce5f5ec6121471d6e3222fdbf74de6cf938916efa318305fa4caa4e3d50d423724e284a98d477e519a82eef5eb8f07a3e1809c2a37b9e9d80720303ef7df6b3b303d6806b115ed99789630fb961d64f880ad0889ecb195e5658ec0847423ec46cfec00def2f772dcadc92509c77385e849702f63fc64734f283f939b71f31b8890ab24a8ed49948cf3d120df759d81d3d8d8696e8ccca22f55b54a694bdbc585431ead6d4c69d78bbc24bfc251ec1f7bbf3a8e3c9a5434c620a7c2c194cbfc8f5d8cdd71f08476820008126206f0e8828fe7834e4526ddcbcac22b4919e0f81f0b5ff7fa92850cf10cb75c1a265d09f7cf996127615cf6d297c922aff81cb8dcdeedc01f9b0a6e7b82c892ab2ceee663bb273896a8eabafd028109b8049d6133eb9be618b048300c54064170876fa9c50a069a107c596a99e1d679355417b4ce825e846bbfb301c63c0f02ea97f746584b7de15b3dbb19a76c253866d080f9fceb0e06697038d767f27822c20e0422a887fe8043d82573c87c34c97ee83b0292cdd861d7054c89e57199caccf58b96a245bcafb53d2a9437b356c752731a60a121169d59112f50f8b83276953ad6fa55625ea0858b84192b8ce977b59a32e06c5b6f1101efe20e98ab2c0bef5bf7d4f353303c8beea396e715045a70e634ecf7af23518f6f0727e368e264e634fdcc17dc4664c990942f50a4c8faad8197abb1918f413c613f669ccbca59f1c8be074d384f61f1cbfd9540f660d5bd7f6b778e5570fe1a9495ec5e088adf38ee3f08fe4e783db001c30094f561c40fbdadae1ce35c5d6eb665187590f77ced77242f9ea9579862df90199e37d310d858c35720f0dd76a4b9cb732afec3f7a31d2299d7f56338df1290b2efe853a9a6fdf232766fa50c8ce835a2ab606f9a49faf1dd6af3d5eb19e322acd96e5e2532ddd1feedf536f4f88c4a2480b75382fcff528a955f4ae9c0b8e0717c16adb49316ab37834cf90856c89af73931cccad953faba24952f6e7f2b0ce2326b7460f61ccfe9bded0ef45a2f0080f317a7866ec943806ab4f8a556bf5cf8b8515ba5a859d049d52f61aaab84d0dc8f7d63db436012aaf92f3ea8ea26bfc212994dbdfb8f397db2537130c6158b52c8d36170857c9970d47b81ff56fe95af303662ac721c5faa5edcd4b4ce09f7043930a5efbc554acac125cdd4cb485ccd96ef32c5fb33fa8db44eb8e03ddf18ddee80e49c5c5e68d01b9b9c48bc3bef93f889e054ddcbe7d603c5d538264ba50280abd60453287e1a8299339ccd94c3e6093df0dd509b3748ee95796c4be1b82e5428be6e223713f64b3e48b4c917357ec208568274e043780be2c9ee470aefb866187728e62bef8776d8a990e49386b3d86fbe401be2d7ebcb0072911da02a54503ee3902beb2befd6dc9fb9e0ded02d5d44bbec8591352b40910ea8559b51c85e4f9832dbeeacc92137ab5fd8f5a0041485e4a52067332981af7ab12802847fec2c8be988eec5bc6356ae1ddd3392e0d67e4bb384ff02ddbc84790579a39d40e47cd8019061af4c0124fd77d6d892e0d63e870aa24581367b30d67eacd8b8f4b489ce73592a3b0eb17ebc0f9dfc22ecc483ffd3e3245e209c536515d6d0c6b9237581695df4003683d8e536bc41c7c127cd85fbc1b1477a1e8efb9dc155e7e9a25de326fa35d0a63b6de91172eef834141446b487361de6018514f11adc53fb21d5a297636047e7d1fb4391b1518f9daf2ad3d5f4fd4c4a50148eedd359eda1d077064c0eb3ac9c496279636951aa65c515a3513017f77afcc22b2a732215527841ae82911a3137c6be663ea10a23fc62f912b8229374c06ffa22ed14c2bf9aac7f2f1f8c7853a968e6d82abfc864d995ae4d57036cd85bb0b43da74443087030be7a7d56567a046a5ed67457b2563b77663990bdec0995043c2ca01d79565836a339ebc87b4b052e137ebd08df036d4ac4fd4af4a546d0e94088c96e3cbb38fc66ce8f60b4f02d977a82750ba7d876349f07c1a4150b0ca50f49d2fdbbe01fe92143bd2721ce370efef0521dfdb0e25a157778a20222931d966418737b84a83de320aafdd70225446b44ea4260b9b800c93f87ae2ea5738c87648a3bd078f244c69dbc92f4e07bdab690b03e3b63d147ba879e4f81edfe73e409d5fb41692f9624c72a9dcda73489963782f6d26870ef3bcd6014f1f80a8b91c7a04e08eecd41da8e3925c10f4ad3ca6ba7b7deef5f5d2405cc24a0cbe24e10b899b550360a26b089dde82cf15ee8c7c6f99597ded37745fb592b8f5a94096f551b5af79014702461bcdf165864658bf3b6776ba8b001e3a4d4363687f57b4e6a3293374c235e47e710f6478411b71d0f094f73c21bef029857823306f14347a9fa6e4a4affcec31992e3a0eb92ba0916a38d28c403973bc713d62a9faf8304b4cfffc4a61669c7efcf30672bc36152d57b6864fe892e1bb25fa373637e678eae66392e6734399760939d6805c31b528e32c53a7be73a4171b00bc298d811446f2d3a9bbc77d3d790b474ac5884ae4b5f3fa94e7244362d883a39908e6bb0c29722575ada9d296f48595bfcecd068df024f8e825856f17eb6dc2f67e11e86a5d26f107b61ecba8395703e6ec3972368b947d15fc28fd46e8dbe7fdf5e6ef8e5a799e8a42ba6ebc5f5955473c4155987e47f79b035a45c969e014e523bae9211d9f122023960dd0d3df1c702dfe0def454f22fbc4a5fb96a3aca412879a7abb31febb7be04cfa9678def491320f6ab61f9e9fd170a9ed43f69cd934c57c80dac44635824d514b6b86000ec187acb02663d34e8ed00d6c3350a3b5f8a326f7d9c64d27a6e737cb6ee1fe36aa361fa073015df0c138f6a7350987c2a13d3f5d549328d2e407546e9558d3ddd6901f319a4e28e0e1ceda8a7a7ebf72508b898a0fc06ea4a2f8d8bef24fbe87fb91c15d494f796c7ba31776a946b349cd97c10da50a950a2775f742436a2f5d31eecab76129aa770256e3dc061583c841cf08e0e8c1953394cfdebe6ee38802a8361572df86c934b07da34e1732a079677ebfcfc0c47f326821049bee23927f91e1040d0864e26a90c31be6a1bebeca6c20011ceac5a6f85f22b0ece7257b723f7ddfe5f85a3ab221d73a4723d10b2e80c8d18cb383470236311e3427b369f6c8b6c9f86c19132da9e52f982357c715bda1254dfed2ca6df50066c0b8265ceb9e2bb0113272168e500a7b02aa859b68e74be2111b0</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>Study Essay</category>
      </categories>
      <tags>
        <tag>虚拟币犯罪基础与实战应用</tag>
      </tags>
  </entry>
  <entry>
    <title>js刷课脚本实践</title>
    <url>/2024/08/01/jsScript/</url>
    <content><![CDATA[<p>某天拿到了一个刷课的网站，需要帮忙刷一下课，但是呢这个网站</p>
<ul>
<li>打开之后不自动播放</li>
<li>播放完一个视频不会自动播放下一个</li>
<li>不能直接倍速</li>
<li>不能拖动（这个解决不了QAQ）</li>
<li>检测出倍速需要点击弹出框来关闭，从而继续刷课</li>
<li>切换一个课程后有时候会弹出一个alert点击来播放视频</li>
</ul>
<p>嗯……就这么多破事儿</p>
<span id="more"></span>

<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h3><p>油猴（篡改猴）扩展程序</p>
<h3 id="自动播放视频"><a href="#自动播放视频" class="headerlink" title="自动播放视频"></a>自动播放视频</h3><p>一开始的思路是直接</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;video&#x27;</span>).<span class="property">play</span></span><br></pre></td></tr></table></figure>

<p>让视频播放。</p>
<p>但是在网页的控制台中这个方法可以，但是写到油猴脚本里没法运行，还是不能播放视频。因此使用浏览器模拟点击的方法。</p>
<p>在点击之前，首先要找到video视频标签，这个网页的video元素使用的应该是用js动态加载出来的，所以监听页面加载完毕的方法判断video元素加载到了页面上不太好用（实际上确实不咋好用），于是使用递归查找video元素</p>
<h4 id="查找页面中的video元素"><a href="#查找页面中的video元素" class="headerlink" title="查找页面中的video元素"></a>查找页面中的video元素</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 检查页面内是否有video元素</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">hasVideo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;video&#x27;</span>)) &#123;</span><br><span class="line">        <span class="comment">// 延时100毫秒再次检查</span></span><br><span class="line">        <span class="built_in">setTimeout</span>(hasVideo, <span class="number">500</span>);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;再次检查&#x27;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 判断video元素内的视频是否在播放</span></span><br><span class="line">        <span class="keyword">const</span> currentVideo = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;video&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span> (currentVideo.<span class="property">paused</span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;当前视频未播放，开始自动播放...&#x27;</span>);</span><br><span class="line">            <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                <span class="title function_">checkVideoPlaying</span>();</span><br><span class="line">            &#125;, <span class="number">500</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果视频未开始播放，那就调用<code>checkVideoPlaying();</code>函数</p>
<h4 id="检查视频是否未播放"><a href="#检查视频是否未播放" class="headerlink" title="检查视频是否未播放"></a>检查视频是否未播放</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 检查视频是否在播放</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">checkVideoPlaying</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">//console.log(&#x27;checkVideoPlaying调用&#x27;);</span></span><br><span class="line">    <span class="comment">//const currentVideo = document.querySelector(&#x27;video&#x27;);</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// document.querySelector(&#x27;video&#x27;).play() </span></span><br><span class="line">        <span class="title function_">simulateClickOnVideo</span>();</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;当前视频开始播放&#x27;</span>);</span><br><span class="line">    &#125;, <span class="number">200</span>);</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">checkPlaybackRate</span>();<span class="comment">// 检测视频是否为2倍速播放</span></span><br><span class="line">    &#125;, <span class="number">500</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="模拟点击一下video元素"><a href="#模拟点击一下video元素" class="headerlink" title="模拟点击一下video元素"></a>模拟点击一下video元素</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">simulateClickOnVideo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> video = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;video&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (video) &#123;</span><br><span class="line">        <span class="keyword">const</span> clickEvent = <span class="keyword">new</span> <span class="title class_">MouseEvent</span>(<span class="string">&#x27;click&#x27;</span>, &#123;</span><br><span class="line">            <span class="attr">view</span>: <span class="variable language_">window</span>,</span><br><span class="line">            <span class="attr">bubbles</span>: <span class="literal">true</span>,</span><br><span class="line">            <span class="attr">cancelable</span>: <span class="literal">true</span></span><br><span class="line">        &#125;);</span><br><span class="line">        video.<span class="title function_">dispatchEvent</span>(clickEvent);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;模拟点击 video 元素&#x27;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;未找到 video 元素&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="倍速"><a href="#倍速" class="headerlink" title="倍速"></a>倍速</h3><p>在<strong>检查视频是否未播放</strong>的时候，里面写了一个函数，<code>checkPlaybackRate();</code>检测视频是否为2倍速播放</p>
<p>先让视频两倍速播放，如果不是两倍速重新检查</p>
<p>网站支持两倍速，但是有时候他还是会检测出倍速然后暂停…………解决方法见<a href="#jump1">6. 浏览器模拟点击弹出的按钮</a></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 检测视频是否为2倍速播放</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">checkPlaybackRate</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;video&#x27;</span>).<span class="property">playbackRate</span> = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">const</span> currentVideo = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;video&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (currentVideo.<span class="property">playbackRate</span> == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;2倍速播放成功&#x27;</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(checkPlaybackRate, <span class="number">500</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">checkCourseLearned</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="学完自动播放下一个视频"><a href="#学完自动播放下一个视频" class="headerlink" title="学完自动播放下一个视频"></a>学完自动播放下一个视频</h3><h4 id="检测是否学完"><a href="#检测是否学完" class="headerlink" title="检测是否学完"></a>检测是否学完</h4><p>这里就要按照这个网站的特征来分析了</p>
<p><img src="/2024/08/01/jsScript/image-20240801234544151.png" alt="image-20240801234544151"></p>
<p>把鼠标放在这个对钩上面发现显示出了“已学完”</p>
<p><img src="/2024/08/01/jsScript/image-20240801234701881.png" alt="image-20240801234701881"></p>
<p>这样的是“进行中”</p>
<p><img src="/2024/08/01/jsScript/image-20240801234727101.png" alt="image-20240801234727101"></p>
<p>这样的是“未开始”</p>
<p>所以从这里入手分析</p>
<p><img src="/2024/08/01/jsScript/image-20240801234849537.png" alt="image-20240801234849537"></p>
<p>选中这个元素发现里面有一个<code>&lt;i&gt;</code>标签，里面的<code>title</code>是进行中，所以就判断这个<code>title</code>是不是已学完就可以了</p>
<p>同时发现正在播放的视频这里有一个active，没有播放的视频没有这个带active的类，所以就寻找这个带active的类，看这个类下面的<code>&lt;i&gt;</code>标签中的title是否是“已学完”。</p>
<p><img src="/2024/08/01/jsScript/image-20240801235841750.png" alt="image-20240801235841750"></p>
<p><img src="/2024/08/01/jsScript/image-20240802000239250.png" alt="image-20240802000239250"></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 检测本节课是否学过</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">checkCourseLearned</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;checkCourseLearned调用&#x27;</span>);</span><br><span class="line">    <span class="comment">// 查找所有具有指定类名的元素</span></span><br><span class="line">    <span class="keyword">const</span> items = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;.resource-item.resource-item-train.resource-item-active&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历这些元素</span></span><br><span class="line">    items.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 查找 &lt;i&gt; 标签</span></span><br><span class="line">        <span class="keyword">const</span> iElement = item.<span class="title function_">querySelector</span>(<span class="string">&#x27;i&#x27;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查 &lt;i&gt; 标签的 title 属性是否为 &quot;已学完&quot;</span></span><br><span class="line">        <span class="keyword">if</span> (iElement &amp;&amp; iElement.<span class="property">title</span> === <span class="string">&#x27;已学完&#x27;</span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;找到一个已学完的资源项:&#x27;</span>, item);</span><br><span class="line">            <span class="comment">// 如果这节课学完了，就播放下一节课</span></span><br><span class="line">            <span class="title function_">playNextVideo</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//如果这节课没学完，监听视频播放结束事件</span></span><br><span class="line">            <span class="title function_">listenVideoEnd</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="监听视频是否播放完"><a href="#监听视频是否播放完" class="headerlink" title="监听视频是否播放完"></a>监听视频是否播放完</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 监听视频播放结束事件</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">listenVideoEnd</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> currentVideo = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;video&#x27;</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;listenVideoEnd调用&#x27;</span>);</span><br><span class="line">    <span class="comment">// 监听视频播放结束事件</span></span><br><span class="line">    currentVideo.<span class="title function_">addEventListener</span>(<span class="string">&#x27;ended&#x27;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;当前视频播放结束，正在尝试播放下一个视频...&#x27;</span>);</span><br><span class="line">        <span class="title function_">playNextVideo</span>();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="播放下一个视频"><a href="#播放下一个视频" class="headerlink" title="播放下一个视频"></a>播放下一个视频</h4><p>首先要找到当前激活的项<code>const activeItem = document.querySelector(&#39;.resource-item.resource-item-train.resource-item-active&#39;);</code>，然后找到下一个没有激活的项，也就是<code>.resource-item.resource-item-train</code>，找到之后就点击这个项</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 播放下一个视频</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">playNextVideo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;playNextVideo调用&#x27;</span>);</span><br><span class="line">    <span class="comment">// 找到当前激活的资源项</span></span><br><span class="line">    <span class="keyword">const</span> activeItem = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.resource-item.resource-item-train.resource-item-active&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!activeItem) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;没有找到当前激活的资源项&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(activeItem)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到下一个资源项</span></span><br><span class="line">    <span class="keyword">let</span> nextItem = activeItem.<span class="property">nextElementSibling</span>;</span><br><span class="line">    <span class="keyword">while</span> (nextItem &amp;&amp; (!nextItem.<span class="property">classList</span>.<span class="title function_">contains</span>(<span class="string">&#x27;resource-item&#x27;</span>) || !nextItem.<span class="property">classList</span>.<span class="title function_">contains</span>(<span class="string">&#x27;resource-item-train&#x27;</span>))) &#123;</span><br><span class="line">        nextItem = nextItem.<span class="property">nextElementSibling</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!nextItem) &#123;</span><br><span class="line">        <span class="comment">// 如果已经是最后一个，循环回到第一个</span></span><br><span class="line">        nextItem = activeItem.<span class="property">parentNode</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.resource-item.resource-item-train&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nextItem) &#123;</span><br><span class="line">        <span class="comment">// 模拟点击下一个资源项</span></span><br><span class="line">        <span class="title function_">simulateClick</span>(nextItem, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">            <span class="comment">// 延时处理alert并播放视频</span></span><br><span class="line">            <span class="built_in">setTimeout</span>(handleAlertAndPlayVideo, <span class="number">3000</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;没有找到下一个资源项或资源项不符合条件&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">hasVideo</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="模拟点击"><a href="#模拟点击" class="headerlink" title="模拟点击"></a>模拟点击</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 模拟点击</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">simulateClick</span>(<span class="params">element, callback</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> clickEvent = <span class="keyword">new</span> <span class="title class_">MouseEvent</span>(<span class="string">&#x27;click&#x27;</span>, &#123;</span><br><span class="line">        <span class="string">&#x27;view&#x27;</span>: <span class="variable language_">window</span>,</span><br><span class="line">        <span class="string">&#x27;bubbles&#x27;</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="string">&#x27;cancelable&#x27;</span>: <span class="literal">true</span></span><br><span class="line">    &#125;);</span><br><span class="line">    element.<span class="title function_">dispatchEvent</span>(clickEvent);</span><br><span class="line">    <span class="comment">// 如果需要执行回调函数，确保点击事件处理完毕后执行</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(callback, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="处理alert"><a href="#处理alert" class="headerlink" title="处理alert"></a>处理alert</h3><p>这个可能不会生效……所以后面又写了一个直接浏览器模拟点击按钮的</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 处理alert并播放视频</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">handleAlertAndPlayVideo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 这里假设alert是点击后弹出的，并且需要用户确认</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">window</span>.<span class="property">alert</span>) &#123;</span><br><span class="line">        <span class="comment">// 模拟点击alert的确定按钮</span></span><br><span class="line">        <span class="variable language_">window</span>.<span class="property">alert</span> = <span class="keyword">function</span> (<span class="params">message</span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;模拟点击alert确定按钮&#x27;</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="浏览器模拟点击弹出的按钮"><a href="#浏览器模拟点击弹出的按钮" class="headerlink" title="浏览器模拟点击弹出的按钮"></a><span id="jump1">浏览器模拟点击弹出的按钮</span></h3><p><img src="/2024/08/01/jsScript/image-20240802001050196.png" alt="image-20240802001050196"></p>
<p>经分析，所有的弹出按钮都有这个类</p>
<p>但是运行的时候发现，一打开脚本就跳转到搜索界面，所以肯定是某个搜索的地方也有这个类</p>
<p><img src="/2024/08/01/jsScript/image-20240802001320139.png" alt="image-20240802001320139"></p>
<p>果不其然，这个搜索图标也使用了这个类，所以再排除这个<code>fish-input-search-button</code>类就好了</p>
<blockquote>
<p>这里是怎么发现的呢…………本来这个课是放在虚拟机里刷的，因为不能离开这个网页，所以网页比例就没调，但是在某一瞬间缩小了一下比例，本来是只有一个搜索按钮的地方突然变出来一个搜索框，由于之前比例太大这个搜索框没显示，但是现在显示了，所以多了这么一个类，于是就需要排除这个类</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">simulateClickOnPrimaryButton</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> button = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.fish-btn.fish-btn-primary&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (button) &#123;</span><br><span class="line">        <span class="keyword">const</span> classList = button.<span class="property">classList</span>;</span><br><span class="line">        <span class="keyword">if</span> (classList.<span class="title function_">contains</span>(<span class="string">&#x27;fish-input-search-button&#x27;</span>)) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;按钮包含 fish-input-search-button 类，不进行点击&#x27;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> clickEvent = <span class="keyword">new</span> <span class="title class_">MouseEvent</span>(<span class="string">&#x27;click&#x27;</span>, &#123;</span><br><span class="line">                <span class="attr">view</span>: <span class="variable language_">window</span>,</span><br><span class="line">                <span class="attr">bubbles</span>: <span class="literal">true</span>,</span><br><span class="line">                <span class="attr">cancelable</span>: <span class="literal">true</span></span><br><span class="line">            &#125;);</span><br><span class="line">            button.<span class="title function_">dispatchEvent</span>(clickEvent);</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;模拟点击 fish-btn fish-btn-primary 按钮&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;未找到 fish-btn fish-btn-primary 按钮&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="播放完的Bug"><a href="#播放完的Bug" class="headerlink" title="播放完的Bug"></a>播放完的Bug</h3><p>有时候视频播放完会出来一个Bug，就是视频不自动暂停，这时候如果用鼠标点一下暂停键，脚本才会检测到video.ended，所以再加一个判断，判断视频已播放时长是否等于总时长</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断视频播放时长是否等于总时长</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">isVideoDurationEqual</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> video = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;video&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (video) &#123;</span><br><span class="line">        <span class="keyword">const</span> currentTime = video.<span class="property">currentTime</span>;</span><br><span class="line">        <span class="keyword">const</span> duration = video.<span class="property">duration</span>;</span><br><span class="line">        <span class="keyword">const</span> tolerance = <span class="number">1</span>; <span class="comment">// 允许的误差范围，单位为秒</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="title class_">Math</span>.<span class="title function_">abs</span>(currentTime - duration) &lt;= tolerance) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;视频播放时长等于总时长&#x27;</span>);</span><br><span class="line">            <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                <span class="comment">// 点击video元素，触发视频暂停</span></span><br><span class="line">                <span class="title function_">simulateClickOnVideo</span>();</span><br><span class="line">            &#125;, <span class="number">3000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="持续执行的函数"><a href="#持续执行的函数" class="headerlink" title="持续执行的函数"></a>持续执行的函数</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setInterval</span>(simulateClickOnPrimaryButton, <span class="number">3000</span>);</span><br><span class="line"><span class="built_in">setInterval</span>(checkPlaybackRate, <span class="number">3000</span>);</span><br><span class="line"><span class="built_in">setInterval</span>(isVideoDurationEqual, <span class="number">3000</span>);</span><br></pre></td></tr></table></figure>

<p>这三个函数让他每隔三秒重复执行就好了。其他的整个代码逻辑使用递归的方法让整个脚本持续运行</p>
<h2 id="总代码"><a href="#总代码" class="headerlink" title="总代码"></a>总代码</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ==UserScript==</span></span><br><span class="line"><span class="comment">// @name         AutoPlay</span></span><br><span class="line"><span class="comment">// @namespace    https://creeeeeeeeeeper.github.io/</span></span><br><span class="line"><span class="comment">// @version      1.0</span></span><br><span class="line"><span class="comment">// @description  Automatically play the next video in the video list.</span></span><br><span class="line"><span class="comment">// @author       ZYG</span></span><br><span class="line"><span class="comment">// @match        *://*/*</span></span><br><span class="line"><span class="comment">// @grant        none</span></span><br><span class="line"><span class="comment">// @run-at       document-idle</span></span><br><span class="line"><span class="comment">// ==/UserScript==</span></span><br><span class="line"></span><br><span class="line">(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="string">&#x27;use strict&#x27;</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Autoplay js start&#x27;</span>);</span><br><span class="line">    <span class="title function_">hasVideo</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">playv</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;video&#x27;</span>).<span class="title function_">play</span>()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">setInterval</span>(playv, <span class="number">1000</span>);</span><br><span class="line">    <span class="built_in">setInterval</span>(simulateClickOnPrimaryButton, <span class="number">3000</span>);</span><br><span class="line">    <span class="built_in">setInterval</span>(checkPlaybackRate, <span class="number">3000</span>);</span><br><span class="line">    <span class="built_in">setInterval</span>(isVideoDurationEqual, <span class="number">3000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">simulateClickOnPrimaryButton</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> button = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.fish-btn.fish-btn-primary&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span> (button) &#123;</span><br><span class="line">            <span class="keyword">const</span> classList = button.<span class="property">classList</span>;</span><br><span class="line">            <span class="keyword">if</span> (classList.<span class="title function_">contains</span>(<span class="string">&#x27;fish-input-search-button&#x27;</span>)) &#123;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;按钮包含 fish-input-search-button 类，不进行点击&#x27;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">const</span> clickEvent = <span class="keyword">new</span> <span class="title class_">MouseEvent</span>(<span class="string">&#x27;click&#x27;</span>, &#123;</span><br><span class="line">                    <span class="attr">view</span>: <span class="variable language_">window</span>,</span><br><span class="line">                    <span class="attr">bubbles</span>: <span class="literal">true</span>,</span><br><span class="line">                    <span class="attr">cancelable</span>: <span class="literal">true</span></span><br><span class="line">                &#125;);</span><br><span class="line">                button.<span class="title function_">dispatchEvent</span>(clickEvent);</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;模拟点击 fish-btn fish-btn-primary 按钮&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;未找到 fish-btn fish-btn-primary 按钮&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查页面内是否有video元素</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">hasVideo</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;video&#x27;</span>)) &#123;</span><br><span class="line">            <span class="comment">// 延时100毫秒再次检查</span></span><br><span class="line">            <span class="built_in">setTimeout</span>(hasVideo, <span class="number">500</span>);</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;再次检查&#x27;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 判断video元素内的视频是否在播放</span></span><br><span class="line">            <span class="keyword">const</span> currentVideo = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;video&#x27;</span>);</span><br><span class="line">            <span class="keyword">if</span> (currentVideo.<span class="property">paused</span>) &#123;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;当前视频未播放，开始自动播放...&#x27;</span>);</span><br><span class="line">                <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                    <span class="title function_">checkVideoPlaying</span>();</span><br><span class="line">                &#125;, <span class="number">500</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查视频是否在播放</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">checkVideoPlaying</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;checkVideoPlaying调用&#x27;</span>);</span><br><span class="line">        <span class="comment">//const currentVideo = document.querySelector(&#x27;video&#x27;);</span></span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// document.querySelector(&#x27;video&#x27;).play() </span></span><br><span class="line">            <span class="title function_">simulateClickOnVideo</span>();</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;当前视频开始播放&#x27;</span>);</span><br><span class="line">        &#125;, <span class="number">200</span>);</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="title function_">checkPlaybackRate</span>();<span class="comment">// 检测视频是否为2倍速播放</span></span><br><span class="line">        &#125;, <span class="number">500</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">simulateClickOnVideo</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> video = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;video&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span> (video) &#123;</span><br><span class="line">            <span class="keyword">const</span> clickEvent = <span class="keyword">new</span> <span class="title class_">MouseEvent</span>(<span class="string">&#x27;click&#x27;</span>, &#123;</span><br><span class="line">                <span class="attr">view</span>: <span class="variable language_">window</span>,</span><br><span class="line">                <span class="attr">bubbles</span>: <span class="literal">true</span>,</span><br><span class="line">                <span class="attr">cancelable</span>: <span class="literal">true</span></span><br><span class="line">            &#125;);</span><br><span class="line">            video.<span class="title function_">dispatchEvent</span>(clickEvent);</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;模拟点击 video 元素&#x27;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;未找到 video 元素&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检测视频是否为2倍速播放</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">checkPlaybackRate</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;video&#x27;</span>).<span class="property">playbackRate</span> = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">const</span> currentVideo = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;video&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span> (currentVideo.<span class="property">playbackRate</span> == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;2倍速播放成功&#x27;</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">setTimeout</span>(checkPlaybackRate, <span class="number">500</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_">checkCourseLearned</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检测本节课是否学过</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">checkCourseLearned</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;checkCourseLearned调用&#x27;</span>);</span><br><span class="line">        <span class="comment">// 查找所有具有指定类名的元素</span></span><br><span class="line">        <span class="keyword">const</span> items = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;.resource-item.resource-item-train.resource-item-active&#x27;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历这些元素</span></span><br><span class="line">        items.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// 查找 &lt;i&gt; 标签</span></span><br><span class="line">            <span class="keyword">const</span> iElement = item.<span class="title function_">querySelector</span>(<span class="string">&#x27;i&#x27;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 检查 &lt;i&gt; 标签的 title 属性是否为 &quot;已学完&quot;</span></span><br><span class="line">            <span class="keyword">if</span> (iElement &amp;&amp; iElement.<span class="property">title</span> === <span class="string">&#x27;已学完&#x27;</span>) &#123;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;找到一个已学完的资源项:&#x27;</span>, item);</span><br><span class="line">                <span class="comment">// 如果这节课学完了，就播放下一节课</span></span><br><span class="line">                <span class="title function_">playNextVideo</span>();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//如果这节课没学完，监听视频播放结束事件</span></span><br><span class="line">                <span class="title function_">listenVideoEnd</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听视频播放结束事件</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">listenVideoEnd</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> currentVideo = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;video&#x27;</span>);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;listenVideoEnd调用&#x27;</span>);</span><br><span class="line">        <span class="comment">// 监听视频播放结束事件</span></span><br><span class="line">        currentVideo.<span class="title function_">addEventListener</span>(<span class="string">&#x27;ended&#x27;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;当前视频播放结束，正在尝试播放下一个视频...&#x27;</span>);</span><br><span class="line">            <span class="title function_">playNextVideo</span>();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 播放下一个视频</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">playNextVideo</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;playNextVideo调用&#x27;</span>);</span><br><span class="line">        <span class="comment">// 找到当前激活的资源项</span></span><br><span class="line">        <span class="keyword">const</span> activeItem = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.resource-item.resource-item-train.resource-item-active&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span> (!activeItem) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;没有找到当前激活的资源项&#x27;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(activeItem)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找到下一个资源项</span></span><br><span class="line">        <span class="keyword">let</span> nextItem = activeItem.<span class="property">nextElementSibling</span>;</span><br><span class="line">        <span class="keyword">while</span> (nextItem &amp;&amp; (!nextItem.<span class="property">classList</span>.<span class="title function_">contains</span>(<span class="string">&#x27;resource-item&#x27;</span>) || !nextItem.<span class="property">classList</span>.<span class="title function_">contains</span>(<span class="string">&#x27;resource-item-train&#x27;</span>))) &#123;</span><br><span class="line">            nextItem = nextItem.<span class="property">nextElementSibling</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!nextItem) &#123;</span><br><span class="line">            <span class="comment">// 如果已经是最后一个，循环回到第一个</span></span><br><span class="line">            nextItem = activeItem.<span class="property">parentNode</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.resource-item.resource-item-train&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nextItem) &#123;</span><br><span class="line">            <span class="comment">// 模拟点击下一个资源项</span></span><br><span class="line">            <span class="title function_">simulateClick</span>(nextItem, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">                <span class="comment">// 延时处理alert并播放视频</span></span><br><span class="line">                <span class="built_in">setTimeout</span>(handleAlertAndPlayVideo, <span class="number">3000</span>);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;没有找到下一个资源项或资源项不符合条件&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="title function_">hasVideo</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模拟点击</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">simulateClick</span>(<span class="params">element, callback</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> clickEvent = <span class="keyword">new</span> <span class="title class_">MouseEvent</span>(<span class="string">&#x27;click&#x27;</span>, &#123;</span><br><span class="line">            <span class="string">&#x27;view&#x27;</span>: <span class="variable language_">window</span>,</span><br><span class="line">            <span class="string">&#x27;bubbles&#x27;</span>: <span class="literal">true</span>,</span><br><span class="line">            <span class="string">&#x27;cancelable&#x27;</span>: <span class="literal">true</span></span><br><span class="line">        &#125;);</span><br><span class="line">        element.<span class="title function_">dispatchEvent</span>(clickEvent);</span><br><span class="line">        <span class="comment">// 如果需要执行回调函数，确保点击事件处理完毕后执行</span></span><br><span class="line">        <span class="built_in">setTimeout</span>(callback, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理alert并播放视频</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">handleAlertAndPlayVideo</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="comment">// 这里假设alert是点击后弹出的，并且需要用户确认</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">window</span>.<span class="property">alert</span>) &#123;</span><br><span class="line">            <span class="comment">// 模拟点击alert的确定按钮</span></span><br><span class="line">            <span class="variable language_">window</span>.<span class="property">alert</span> = <span class="keyword">function</span> (<span class="params">message</span>) &#123;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;模拟点击alert确定按钮&#x27;</span>);</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断视频播放时长是否等于总时长</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">isVideoDurationEqual</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> video = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;video&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span> (video) &#123;</span><br><span class="line">            <span class="keyword">const</span> currentTime = video.<span class="property">currentTime</span>;</span><br><span class="line">            <span class="keyword">const</span> duration = video.<span class="property">duration</span>;</span><br><span class="line">            <span class="keyword">const</span> tolerance = <span class="number">1</span>; <span class="comment">// 允许的误差范围，单位为秒</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="title class_">Math</span>.<span class="title function_">abs</span>(currentTime - duration) &lt;= tolerance) &#123;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;视频播放时长等于总时长&#x27;</span>);</span><br><span class="line">                <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                    <span class="comment">// 点击video元素，触发视频暂停</span></span><br><span class="line">                    <span class="title function_">simulateClickOnVideo</span>();</span><br><span class="line">                &#125;, <span class="number">3000</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>安装篡改猴插件</p>
<p><img src="/2024/08/01/jsScript/image-20240802001948601.png" alt="image-20240802001948601"></p>
<p>打开管理面板</p>
<p><img src="/2024/08/01/jsScript/image-20240802002031717.png" alt="image-20240802002031717"></p>
<p>添加脚本</p>
<p><img src="/2024/08/01/jsScript/image-20240802002101858.png" alt="image-20240802002101858"></p>
<p>将代码扔进去，ctrl + s保存</p>
<p><img src="/2024/08/01/jsScript/image-20240802002125428.png" alt="image-20240802002125428"></p>
<p><img src="/2024/08/01/jsScript/image-20240802002214549.png" alt="image-20240802002214549"></p>
<p>启用</p>
<p><img src="/2024/08/01/jsScript/image-20240802002521991.png" alt="image-20240802002521991"></p>
<p>脚本成功运行</p>
<h2 id="Bug"><a href="#Bug" class="headerlink" title="Bug"></a>Bug</h2><p>其实是懒得写还没实现的功能</p>
<p>比如：当最后一个课程学完后，需要打开下一个折叠的层</p>
<p><img src="/2024/08/01/jsScript/image-20240802003855298.png" alt="image-20240802003855298"><img src="/2024/08/01/jsScript/image-20240802003912394.png" alt="image-20240802003912394"></p>
<p>才能自动播放下一个折叠层中的视频</p>
<p>所以播放完一个视频应该先遍历一下所有<code>.resource-item.resource-item-train</code>的类中的所有<code>&lt;i&gt;</code>标签的title是否都为“已学完”，然后再找到折叠层的类，使用浏览器模拟点击让他折叠打开，然后再点击课程…………因为这里没必要所以没写</p>
<p>折叠层的类：<img src="/2024/08/01/jsScript/image-20240802004238259.png" alt="image-20240802004238259"></p>
<p>判断点击这里就可以实现自动展开了</p>
]]></content>
  </entry>
  <entry>
    <title>My Dlls</title>
    <url>/2024/07/20/Dlls/</url>
    <content><![CDATA[<p>下面是写程序时自己写的一些函数，可以直接拿来用</p>
<p>项目地址：<a href="https://github.com/Creeeeeeeeeeper/Codes/tree/master/dllCompilation">Github</a></p>
<p>DLL下载：<a href="https://github.com/Creeeeeeeeeeper/Codes/raw/master/dllCompilation/Debug/dllCompilation.dll">dllCompilation</a></p>
<span id="more"></span>

<h2 id="属性页配置"><a href="#属性页配置" class="headerlink" title="属性页配置"></a>属性页配置</h2><p>没有安装OpenSSL先下载安装 <a href="https://wwl.lanzouv.com/idJw62533kih">OpenSSL-Win32</a> <a href="https://wwl.lanzouv.com/ijudd2533h3e">OpenSSL-Win64</a> pswd:1234</p>
<p>链接库：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">配置属性 =&gt; C/C++ =&gt; 常规 =&gt; 附加包含目录 D:\OpenSSL\OpenSSL-Win32\include</span><br><span class="line">配置属性 =&gt; 链接器 =&gt; 常规 =&gt; 附加库目录 D:\OpenSSL\OpenSSL-Win32\lib\</span><br><span class="line">配置属性 =&gt; 链接器 =&gt; 输入 =&gt; libssl.lib</span><br><span class="line">						  libcrypto.lib</span><br></pre></td></tr></table></figure>

<h2 id="功能-pch-h"><a href="#功能-pch-h" class="headerlink" title="功能(pch.h)"></a>功能(pch.h)</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> PCH_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PCH_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFER_SIZE 10000</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;framework.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;winsock2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ws2tcpip.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;openssl/ssl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;openssl/err.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;d3d9.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;openssl/md5.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iphlpapi.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tlhelp32.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Psapi.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;d3d9.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;iphlpapi.lib&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;ws2_32.lib&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;psapi.lib&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;d3d9.lib&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 检测程序是否运行在虚拟机中 非虚拟机:0 虚拟机:1 Direct3D初始化失败:2 获取适配器信息失败:3</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> _declspec(dllexport) <span class="function">DWORD WINAPI <span class="title">GPUProcDetect</span><span class="params">(LPVOID lpParameter)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传入进程名和类名，关闭所有在任务栏中打开的这些程序，但是不结束这个程序本身的进程</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> _declspec(dllexport) <span class="function"><span class="type">int</span> <span class="title">killtasks</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* targetTitles[], <span class="type">size_t</span> targetTitlesSize, <span class="type">const</span> <span class="type">char</span>* targetClassNames[], <span class="type">size_t</span> targetClassNamesSize)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取UUID的md5值，返回md5值字符串，可以作为识别计算机唯一标识</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> _declspec(dllexport) <span class="function"><span class="type">char</span>* <span class="title">getUUIDmd5</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过个人Gitee仓库中获取IP和Port，一般用于程序需要内网穿透并需要客户端自动获取服务端IP和Port的场景（因为内网穿透的IP和Port经常变化）</span></span><br><span class="line"><span class="comment">// 使用方法：在个人仓库中创建一个.txt文件，内容格式为：127.0.0.1 8080，前面为IP后面为Port，中间使用空格分隔</span></span><br><span class="line"><span class="comment">// 第一个参数：点击该.txt文件，直接复制url，如：https://gitee.com/zzzzzyg/socket/blob/master/configuration.txt</span></span><br><span class="line"><span class="comment">// 第二个参数：点击.txt文件后，点击右边的原始数据，仅复制路径，如：/zzzzzyg/socket/raw/master/configuration.txt</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> _declspec(dllexport) <span class="function"><span class="type">char</span>* <span class="title">getIPaPORT</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* url, <span class="type">const</span> <span class="type">char</span>* path)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查文件是否不存在，不存在返回1，存在返回0</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> _declspec(dllexport) <span class="function"><span class="type">int</span> <span class="title">file_notexists</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* filename)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用curl下载文件到指定路径，url须为文件直链链接，文件路径使用/分隔符，不要使用\分隔符</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> _declspec(dllexport) <span class="function"><span class="type">void</span> <span class="title">curlDownload</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* path, <span class="type">const</span> <span class="type">char</span>* url)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义打印</span></span><br><span class="line"><span class="comment">// 第一个参数：要打印的字符串</span></span><br><span class="line"><span class="comment">// 第二个参数：打印样式。0重置所有的样式 1粗体 2暗色(浅色) 3斜体 4下划线 5慢速闪烁 6快速闪烁 7反色 8隐藏 9删除线</span></span><br><span class="line"><span class="comment">// 第三个参数：前景色。0黑色 1红色 2绿色 3黄色 4蓝色 5洋红色 6青色 7白色</span></span><br><span class="line"><span class="comment">// 第四个参数：背景色。0黑色 1红色 2绿色 3黄色 4蓝色 5洋红色 6青色 7白色</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> _declspec(dllexport) <span class="function"><span class="type">void</span> <span class="title">printc</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* str, <span class="type">char</span>* style, <span class="type">int</span> ForegroundColor, <span class="type">int</span> BackgroundColor)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//PCH_H</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="代码（2024-7-20）"><a href="#代码（2024-7-20）" class="headerlink" title="代码（2024.7.20）"></a>代码（2024.7.20）</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;pch.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">containsSubstring</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* str, <span class="type">const</span> <span class="type">char</span>* substr)</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> lowerStr[<span class="number">128</span>];</span><br><span class="line">    <span class="type">char</span> lowerSubstr[<span class="number">128</span>];</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; str[i] &amp;&amp; i &lt; <span class="number">127</span>; i++) &#123;</span><br><span class="line">        lowerStr[i] = <span class="built_in">tolower</span>((<span class="type">unsigned</span> <span class="type">char</span>)str[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    lowerStr[i] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; substr[i] &amp;&amp; i &lt; <span class="number">127</span>; i++) &#123;</span><br><span class="line">        lowerSubstr[i] = <span class="built_in">tolower</span>((<span class="type">unsigned</span> <span class="type">char</span>)substr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    lowerSubstr[i] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strstr</span>(lowerStr, lowerSubstr) != <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">GPUProcDetect</span><span class="params">(LPVOID lpParameter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    IDirect3D9* pD3D = <span class="built_in">Direct3DCreate9</span>(D3D_SDK_VERSION);</span><br><span class="line">    <span class="keyword">if</span> (pD3D == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    D3DADAPTER_IDENTIFIER9 adapterIdentifier;</span><br><span class="line">    HRESULT hr = pD3D-&gt;<span class="built_in">GetAdapterIdentifier</span>(D3DADAPTER_DEFAULT, <span class="number">0</span>, &amp;adapterIdentifier);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">FAILED</span>(hr)) &#123;</span><br><span class="line">        pD3D-&gt;<span class="built_in">Release</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">containsSubstring</span>(adapterIdentifier.Description, <span class="string">&quot;vmware&quot;</span>) || <span class="built_in">containsSubstring</span>(adapterIdentifier.Description, <span class="string">&quot;virtualbox&quot;</span>)) &#123;</span><br><span class="line">        pD3D-&gt;<span class="built_in">Release</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pD3D-&gt;<span class="built_in">Release</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">IsInArray</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* str, <span class="type">const</span> <span class="type">char</span>** array, <span class="type">size_t</span> arraySize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; arraySize; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strstr</span>(str, array[i]) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> TRUE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL CALLBACK <span class="title">EnumWindowsProc</span><span class="params">(HWND hwnd, LPARAM lParam)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">EnumWindowsData</span> &#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">char</span>** targetTitles;</span><br><span class="line">        <span class="type">size_t</span> targetTitlesSize;</span><br><span class="line">        <span class="type">const</span> <span class="type">char</span>** targetClassNames;</span><br><span class="line">        <span class="type">size_t</span> targetClassNamesSize;</span><br><span class="line">    &#125; *data = (<span class="keyword">struct</span> EnumWindowsData*)lParam;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> windowTitle[<span class="number">256</span>];</span><br><span class="line">    <span class="type">char</span> className[<span class="number">256</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">GetWindowTextA</span>(hwnd, windowTitle, <span class="built_in">sizeof</span>(windowTitle))) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">IsInArray</span>(windowTitle, data-&gt;targetTitles, data-&gt;targetTitlesSize)) &#123;</span><br><span class="line">            <span class="built_in">ShowWindow</span>(hwnd, SW_HIDE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">GetClassNameA</span>(hwnd, className, <span class="built_in">sizeof</span>(className))) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">IsInArray</span>(className, data-&gt;targetClassNames, data-&gt;targetClassNamesSize)) &#123;</span><br><span class="line">            <span class="built_in">ShowWindow</span>(hwnd, SW_HIDE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">WindowProcDetect</span><span class="params">(LPVOID lpParameter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">EnumWindowsData</span> &#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">char</span>** targetTitles;</span><br><span class="line">        <span class="type">size_t</span> targetTitlesSize;</span><br><span class="line">        <span class="type">const</span> <span class="type">char</span>** targetClassNames;</span><br><span class="line">        <span class="type">size_t</span> targetClassNamesSize;</span><br><span class="line">    &#125; *data = (<span class="keyword">struct</span> EnumWindowsData*)lpParameter;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">EnumWindows</span>(EnumWindowsProc, (LPARAM)data);</span><br><span class="line">        <span class="built_in">Sleep</span>(<span class="number">333</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">EnumWindowsData</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>** targetTitles;</span><br><span class="line">    <span class="type">size_t</span> targetTitlesSize;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>** targetClassNames;</span><br><span class="line">    <span class="type">size_t</span> targetClassNamesSize;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">killtasks</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* targetTitles[], <span class="type">size_t</span> targetTitlesSize, <span class="type">const</span> <span class="type">char</span>* targetClassNames[], <span class="type">size_t</span> targetClassNamesSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">EnumWindowsData</span> data = &#123;</span><br><span class="line">        targetTitles,</span><br><span class="line">        targetTitlesSize,</span><br><span class="line">        targetClassNames,</span><br><span class="line">        targetClassNamesSize</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    HANDLE hThread = <span class="built_in">CreateThread</span>(<span class="literal">NULL</span>, <span class="number">0</span>, WindowProcDetect, &amp;data, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (hThread == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">CloseHandle</span>(hThread);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">compute_md5</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* str, <span class="type">unsigned</span> <span class="type">char</span>* digest)</span> </span>&#123;</span><br><span class="line">	MD5_CTX ctx;</span><br><span class="line">	<span class="built_in">MD5_Init</span>(&amp;ctx);</span><br><span class="line">	<span class="built_in">MD5_Update</span>(&amp;ctx, str, <span class="built_in">strlen</span>(str));</span><br><span class="line">	<span class="built_in">MD5_Final</span>(digest, &amp;ctx);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sprint_md5</span><span class="params">(<span class="type">char</span>* out, <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span>* digest)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MD5_DIGEST_LENGTH; ++i) &#123;</span><br><span class="line">		<span class="built_in">sprintf_s</span>(out + i * <span class="number">2</span>, MD5_DIGEST_LENGTH * <span class="number">2</span> + <span class="number">1</span> - i * <span class="number">2</span>, <span class="string">&quot;%02x&quot;</span>, digest[i]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">char</span>* <span class="title">getUUIDmd5</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> UUIDMD5[MD5_DIGEST_LENGTH * <span class="number">2</span> + <span class="number">1</span>];</span><br><span class="line">    FILE* fp;</span><br><span class="line">    <span class="type">char</span> uuid[<span class="number">255</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> digest[MD5_DIGEST_LENGTH];</span><br><span class="line">    <span class="type">char</span> md5string[MD5_DIGEST_LENGTH * <span class="number">2</span> + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((fp = _popen(<span class="string">&quot;wmic csproduct get UUID&quot;</span>, <span class="string">&quot;r&quot;</span>)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fgets</span>(uuid, <span class="built_in">sizeof</span>(uuid), fp);</span><br><span class="line">    <span class="built_in">fgets</span>(uuid, <span class="built_in">sizeof</span>(uuid), fp);</span><br><span class="line">    uuid[<span class="built_in">strcspn</span>(uuid, <span class="string">&quot;\n&quot;</span>)] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (_pclose(fp) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">compute_md5</span>(uuid, digest);</span><br><span class="line">    <span class="built_in">sprint_md5</span>(md5string, digest);</span><br><span class="line">    <span class="built_in">strcpy_s</span>(UUIDMD5, <span class="built_in">sizeof</span>(UUIDMD5), md5string);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">handle_errors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">ERR_print_errors_fp</span>(stderr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">char</span>* <span class="title">getIPaPORT</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* url, <span class="type">const</span> <span class="type">char</span>* path)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> IPANDPORT[<span class="number">0x100</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="type">char</span> host[<span class="number">256</span>], service[<span class="number">32</span>];</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">addrinfo</span> hints, * res, * p;</span><br><span class="line">    <span class="type">int</span> sockfd, n;</span><br><span class="line">    <span class="type">char</span> buffer[BUFFER_SIZE];</span><br><span class="line">    SSL_CTX* ctx;</span><br><span class="line">    SSL* ssl;</span><br><span class="line"></span><br><span class="line">    WSADATA wsaData;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">WSAStartup</span>(<span class="built_in">MAKEWORD</span>(<span class="number">2</span>, <span class="number">2</span>), &amp;wsaData) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;WSAStartup failed\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">SSL_library_init</span>();</span><br><span class="line">    <span class="built_in">OpenSSL_add_all_algorithms</span>();</span><br><span class="line">    <span class="built_in">SSL_load_error_strings</span>();</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">sscanf_s</span>(url, <span class="string">&quot;https://%[^/]/&quot;</span>, host, (<span class="type">unsigned</span>)_countof(host)) != <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Invalid URL\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">strcpy_s</span>(service, <span class="built_in">sizeof</span>(service), <span class="string">&quot;https&quot;</span>);</span><br><span class="line">    <span class="built_in">memset</span>(&amp;hints, <span class="number">0</span>, <span class="keyword">sizeof</span> hints);</span><br><span class="line">    hints.ai_family = AF_UNSPEC;</span><br><span class="line">    hints.ai_socktype = SOCK_STREAM;</span><br><span class="line">    <span class="type">int</span> status = <span class="built_in">getaddrinfo</span>(host, service, &amp;hints, &amp;res);</span><br><span class="line">    <span class="keyword">if</span> (status != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;getaddrinfo: %s\n&quot;</span>, <span class="built_in">gai_strerror</span>(status));</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (p = res; p != <span class="literal">NULL</span>; p = p-&gt;ai_next) &#123;</span><br><span class="line">        sockfd = <span class="built_in">socket</span>(p-&gt;ai_family, p-&gt;ai_socktype, p-&gt;ai_protocol);</span><br><span class="line">        <span class="keyword">if</span> (sockfd == <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">connect</span>(sockfd, p-&gt;ai_addr, p-&gt;ai_addrlen) == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">closesocket</span>(sockfd);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Failed to connect\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ctx = <span class="built_in">SSL_CTX_new</span>(<span class="built_in">TLS_client_method</span>());</span><br><span class="line">    <span class="keyword">if</span> (ctx == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">handle_errors</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ssl = <span class="built_in">SSL_new</span>(ctx);</span><br><span class="line">    <span class="keyword">if</span> (ssl == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">handle_errors</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">SSL_set_fd</span>(ssl, sockfd);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">SSL_connect</span>(ssl) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">handle_errors</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span> request[<span class="number">512</span>];</span><br><span class="line">    <span class="built_in">snprintf</span>(request, <span class="built_in">sizeof</span>(request), <span class="string">&quot;GET %s HTTP/1.1\r\nHost: %s\r\n\r\n&quot;</span>, path, host);</span><br><span class="line">    <span class="built_in">SSL_write</span>(ssl, request, <span class="built_in">strlen</span>(request));</span><br><span class="line">    <span class="built_in">memset</span>(buffer, <span class="number">0</span>, BUFFER_SIZE);</span><br><span class="line">    <span class="keyword">while</span> ((n = <span class="built_in">SSL_read</span>(ssl, buffer, BUFFER_SIZE - <span class="number">1</span>)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">strcpy_s</span>(IPANDPORT, <span class="built_in">sizeof</span>(IPANDPORT), <span class="built_in">strstr</span>(buffer, <span class="string">&quot;\r\n\r\n&quot;</span>) + <span class="number">4</span>);</span><br><span class="line">        <span class="built_in">memset</span>(buffer, <span class="number">0</span>, BUFFER_SIZE);</span><br><span class="line">        <span class="keyword">goto</span> A;</span><br><span class="line">    &#125;</span><br><span class="line">A:</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">handle_errors</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">SSL_free</span>(ssl);</span><br><span class="line">    <span class="built_in">SSL_CTX_free</span>(ctx);</span><br><span class="line">    <span class="built_in">freeaddrinfo</span>(res);</span><br><span class="line">    <span class="built_in">closesocket</span>(sockfd);</span><br><span class="line">    <span class="built_in">EVP_cleanup</span>();</span><br><span class="line">    <span class="built_in">WSACleanup</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> _strdup(IPANDPORT);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">file_notexists</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* filename)</span> </span>&#123;</span><br><span class="line">    FILE* file = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">fopen_s</span>(&amp;file, filename, <span class="string">&quot;r&quot;</span>) != <span class="number">0</span> || file == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">fclose</span>(file);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">curlDownload</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* path, <span class="type">const</span> <span class="type">char</span>* url)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> curlcmd[<span class="number">0x300</span>];</span><br><span class="line">    <span class="built_in">sprintf_s</span>(curlcmd, <span class="built_in">sizeof</span>(curlcmd), <span class="string">&quot;curl -o %s %s&quot;</span>, path, url);</span><br><span class="line">    <span class="built_in">system</span>(curlcmd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printc</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* str, <span class="type">char</span>* style, <span class="type">int</span> ForegroundColor, <span class="type">int</span> BackgroundColor)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> styleStr[<span class="number">50</span>] = <span class="string">&quot;\033[&quot;</span>;</span><br><span class="line">    <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="type">bool</span> addedStyles[<span class="number">10</span>] = &#123; <span class="literal">false</span> &#125;;</span><br><span class="line">    <span class="keyword">if</span> (style != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; style[i] != <span class="string">&#x27;\0&#x27;</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> styleCode = style[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (!addedStyles[styleCode]) &#123;</span><br><span class="line">                len += <span class="built_in">sprintf_s</span>(styleStr + len, <span class="built_in">sizeof</span>(styleStr) - len, <span class="string">&quot;%dm;&quot;</span>, styleCode);</span><br><span class="line">                addedStyles[styleCode] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ForegroundColor &lt;= <span class="number">7</span> &amp;&amp; ForegroundColor &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        len += <span class="built_in">sprintf_s</span>(styleStr + len, <span class="built_in">sizeof</span>(styleStr) - len, <span class="string">&quot;3%dm;&quot;</span>, ForegroundColor);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        len += <span class="built_in">sprintf_s</span>(styleStr + len, <span class="built_in">sizeof</span>(styleStr) - len, <span class="string">&quot;%37m;&quot;</span>, ForegroundColor);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (BackgroundColor &lt;= <span class="number">7</span> &amp;&amp; BackgroundColor &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        len += <span class="built_in">sprintf_s</span>(styleStr + len, <span class="built_in">sizeof</span>(styleStr) - len, <span class="string">&quot;4%dm;&quot;</span>, BackgroundColor);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        len += <span class="built_in">sprintf_s</span>(styleStr + len, <span class="built_in">sizeof</span>(styleStr) - len, <span class="string">&quot;%40m;&quot;</span>, BackgroundColor);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        styleStr[len - <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s%s\033[0m\033[1m&quot;</span>, styleStr, str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL APIENTRY <span class="title">DllMain</span><span class="params">(HMODULE hModule,</span></span></span><br><span class="line"><span class="params"><span class="function">    DWORD  ul_reason_for_call,</span></span></span><br><span class="line"><span class="params"><span class="function">    LPVOID lpReserved</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (ul_reason_for_call)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> DLL_PROCESS_ATTACH:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> DLL_THREAD_ATTACH:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> DLL_THREAD_DETACH:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> DLL_PROCESS_DETACH:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Tools</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库</title>
    <url>/2024/07/19/database/</url>
    <content><![CDATA[<h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><h2 id="数据库基础"><a href="#数据库基础" class="headerlink" title="数据库基础"></a>数据库基础</h2><span id="more"></span>

<h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><p>1.数据库</p>
<p>数据库就是用来存储各种数据的容器</p>
<p>2.数据库管理系统</p>
<p>专门用于创建和管理数据库的统一软件，介于应用和操作系统之间。比如MYSQL、SQL Server、Oracle等。他们不仅有基础的数据管理功能，还能保证数据的完整性、安全性和可靠性</p>
<p>3.数据库应用程序</p>
<p>通过数据库管理系统提供的接口与之通信、访问和管理数据的应用程序</p>
<p>4.SQL语言</p>
<p>它是一种数据库查询语言和程序设计语言，主要用于管理数据库中的数据，如存储数据、查询数据、更新数据</p>
<h3 id="MYSQL"><a href="#MYSQL" class="headerlink" title="MYSQL"></a>MYSQL</h3><p>MYSQL<a href="https://dev.mysql.com/downloads/mysql/">下载链接</a></p>
<p>历史版本<a href="https://download.mysql.com/archives">下载链接</a>，选择MySQL Community Server</p>
<p>下载使用5.0的最高版本5.0.96</p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>启动服务：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">net start mysql</span><br></pre></td></tr></table></figure>

<p>关闭服务：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">net stop mysql</span><br></pre></td></tr></table></figure>

<p>登录：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">mysql -h localhost -u root -p</span><br></pre></td></tr></table></figure>

<p>登录也可以直接打开MySQL Command Line Client</p>
<p><img src="/2024/07/19/database/image-20240719221312406.png" alt="image-20240719221312406"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; help</span><br><span class="line"></span><br><span class="line">For information about MySQL products and services, visit:</span><br><span class="line">   http://www.mysql.com/</span><br><span class="line">For developer information, including the MySQL Reference Manual, visit:</span><br><span class="line">   http://dev.mysql.com/</span><br><span class="line">To buy MySQL Enterprise support, training, or other products, visit:</span><br><span class="line">   https://shop.mysql.com/</span><br><span class="line"></span><br><span class="line">List of all MySQL commands:</span><br><span class="line">Note that all text commands must be first on line and end with &#x27;;&#x27;</span><br><span class="line">?         (\?) Synonym for `help&#x27;.</span><br><span class="line">clear     (\c) Clear the current input statement.</span><br><span class="line">connect   (\r) Reconnect to the server. Optional arguments are db and host.</span><br><span class="line">delimiter (\d) Set statement delimiter.</span><br><span class="line">ego       (\G) Send command to mysql server, display result vertically.</span><br><span class="line">exit      (\q) Exit mysql. Same as quit.</span><br><span class="line">go        (\g) Send command to mysql server.</span><br><span class="line">help      (\h) Display this help.</span><br><span class="line">notee     (\t) Don&#x27;t write into outfile.</span><br><span class="line">print     (\p) Print current command.</span><br><span class="line">prompt    (\R) Change your mysql prompt.</span><br><span class="line">quit      (\q) Quit mysql.</span><br><span class="line">rehash    (\#) Rebuild completion hash.</span><br><span class="line">source    (\.) Execute an SQL script file. Takes a file name as an argument.</span><br><span class="line">status    (\s) Get status information from the server.</span><br><span class="line">tee       (\T) Set outfile [to_outfile]. Append everything into given outfile.</span><br><span class="line">use       (\u) Use another database. Takes database name as argument.</span><br><span class="line">charset   (\C) Switch to another charset. Might be needed for processing binlog with multi-byte charsets.</span><br><span class="line">warnings  (\W) Show warnings after every statement.</span><br><span class="line">nowarning (\w) Don&#x27;t show warnings after every statement.</span><br><span class="line"></span><br><span class="line">For server side help, type &#x27;help contents&#x27;</span><br></pre></td></tr></table></figure>





















]]></content>
  </entry>
  <entry>
    <title>STL</title>
    <url>/2024/07/18/STL/</url>
    <content><![CDATA[<h1 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h1><h2 id="vector容器"><a href="#vector容器" class="headerlink" title="vector容器"></a>vector容器</h2><h3 id="创建vector容器"><a href="#创建vector容器" class="headerlink" title="创建vector容器"></a>创建vector容器</h3><p>1.导入头文件</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>2.构造vector容器</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; v1;		<span class="comment">//空的容器，里面没有元素</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; <span class="title function_">v2</span><span class="params">(<span class="number">100</span>)</span>;	<span class="comment">//100个元素数据，默认都为0</span></span><br></pre></td></tr></table></figure>
<span id="more"></span>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; <span class="title function_">v3</span><span class="params">(<span class="number">100</span>,<span class="number">8</span>)</span>;	<span class="comment">//100个值为8的元素</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; <span class="title function_">v4</span><span class="params">(v3)</span>;		<span class="comment">//100个值为8的元素</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> nTmpAry[] = &#123;<span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">16</span>, <span class="number">17</span>, <span class="number">18</span>, <span class="number">19</span>, <span class="number">20</span>&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; <span class="title function_">v5</span><span class="params">(nTmpAry + <span class="number">2</span>, nTmpAry + <span class="number">5</span>)</span>;</span><br></pre></td></tr></table></figure>

<p><img src="/2024/07/18/STL/image-20240718153228054.png" alt="image-20240718153228054"></p>
<h3 id="vector容器添加元素"><a href="#vector容器添加元素" class="headerlink" title="vector容器添加元素"></a>vector容器添加元素</h3><h4 id="1-push-back"><a href="#1-push-back" class="headerlink" title="1.push_back"></a>1.push_back</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">v1.<span class="built_in">push_back</span>(i);</span><br></pre></td></tr></table></figure>

<p>将元素添加到v1容器的尾部</p>
<p>将元素i添加到v1的尾部</p>
<h4 id="2-insert"><a href="#2-insert" class="headerlink" title="2.insert()"></a>2.insert()</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">v1.<span class="built_in">insert</span>(v1.<span class="built_in">begin</span>(), <span class="number">99</span>);</span><br></pre></td></tr></table></figure>

<p>从v1的第一个元素开始插入一个99</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">v1.<span class="built_in">insert</span>(v1.<span class="built_in">begin</span>() + <span class="number">3</span>, <span class="number">2</span>, <span class="number">98</span>);</span><br></pre></td></tr></table></figure>

<p>从v1开始向后偏移三个的位置开始插入两个元素，98</p>
<h4 id="用数组插入"><a href="#用数组插入" class="headerlink" title="用数组插入"></a><strong>用数组插入</strong></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">v1.<span class="built_in">insert</span>(v1.begin, nTmpAry+<span class="number">3</span>, nTmpAry+<span class="number">5</span>);</span><br></pre></td></tr></table></figure>

<h4 id="3-pop-back"><a href="#3-pop-back" class="headerlink" title="3.pop_back()"></a>3.pop_back()</h4><p>删除容器尾部的元素</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">v1.<span class="built_in">pop_back</span>();</span><br></pre></td></tr></table></figure>

<p>删除v1尾部最后一个元素</p>
<h4 id="4-erase"><a href="#4-erase" class="headerlink" title="4.erase()"></a>4.erase()</h4><p>删除指定位置的元素</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vi.<span class="built_in">erase</span>(v1.<span class="built_in">begin</span>() + <span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<p>删除起始位置向后偏移三个位置的数值</p>
<p><strong>删除多个元素</strong></p>
<p>需要指定一个范围，同时删除指定区间的元素</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">v1.erase(v1.begin(), v1.begin() + 2);</span><br></pre></td></tr></table></figure>

<p>上面一条代码为：删除v1容器前两条元素。第一个索引位置的元素会被删掉，第二个索引位置前一个位置的元素会被删掉，第二个索引位置上的元素不会被删掉。</p>
<h3 id="vector容器的遍历"><a href="#vector容器的遍历" class="headerlink" title="vector容器的遍历"></a>vector容器的遍历</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, i &lt; v1.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%3d&quot;</span> ,<span class="built_in">v1</span>(i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, i &lt; v1.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%3d&quot;</span> ,v1.<span class="built_in">at</span>(i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>直接遍历v1或者使用at()</p>
<p><strong>使用迭代器</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt;:: iterator nIt = v1.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">while</span>(nIt != v1.<span class="built_in">end</span>())</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%3d &quot;</span>, nIt++)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="deque容器"><a href="#deque容器" class="headerlink" title="deque容器"></a>deque容器</h2><p>所有适用于vector的操作都适用于deque容器，将所有上述vector中的所有vector改成deque仍能正确运行</p>
<h3 id="deque容器概述"><a href="#deque容器概述" class="headerlink" title="deque容器概述"></a>deque容器概述</h3><p>1.deque是”double-ended queue”的缩写。在两端增删元素具有较佳的性能</p>
<p>2.模拟动态数组，与vector相似，所有适用于vector的操作都适用于deque</p>
<p>3.deque还有push_font（将元素插到最前面）和pop_font（删除最前面的元素）的操作</p>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><h5 id="push-front"><a href="#push-front" class="headerlink" title="push_front()"></a>push_front()</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">v1.<span class="built_in">push_front</span>(i);</span><br></pre></td></tr></table></figure>

<p>将i这个元素添加到v1的头部</p>
<h4 id="pop-front"><a href="#pop-front" class="headerlink" title="pop_front()"></a>pop_front()</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">v1.<span class="built_in">pop_front</span>();</span><br></pre></td></tr></table></figure>

<p>删除v1容器头部的元素</p>
<h2 id="List容器"><a href="#List容器" class="headerlink" title="List容器"></a>List容器</h2><p>1.List是双向链表。<br>2.不支持随机存取，不支持at.[pos]函数和[]操作符<br>3.ist除了具有所有顺序容器都有的成员函数以外，还支持下面成员函数。<br>push front::在前而插入<br>pop_front:删除前而的元素<br>sort:排序(Iist单独实现)<br>remove:删除和指定值相等的元素<br>unique:删除所有和前一个元素相同的元素<br>merge:合并两个链表，并清空被合并的那个(Iist单独实现)<br>reverse:颠倒链表</p>
<p>list链表不支持<code>v1.erase(v1.begin() + 3);</code>这种写法，需要使用迭代器</p>
<img src="/2024/07/18/STL/image-20240916214515246.png" alt="image-20240916214515246" style="zoom:50%;">

<p>可以定义一个函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">list&lt;<span class="type">int</span>&gt;::<span class="function">iterator <span class="title">MoveIteractor</span><span class="params">(list&lt;<span class="type">int</span>&gt;::iterator* pIt, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        (*pIt)++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *pIt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printList</span><span class="params">(list&lt;<span class="type">int</span>&gt; myList)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 迭代器遍历</span></span><br><span class="line">    list&lt;<span class="type">int</span>&gt;::iterator nIt = myList.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">while</span> (nIt!= myList.<span class="built_in">end</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, *nIt++);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    list&lt;<span class="type">int</span>&gt; myList = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line"></span><br><span class="line">    list&lt;<span class="type">int</span>&gt;::iterator it = myList.<span class="built_in">begin</span>();</span><br><span class="line">    myList.<span class="built_in">erase</span>(<span class="built_in">MoveIteractor</span>(&amp;it, <span class="number">2</span>));</span><br><span class="line">    <span class="built_in">printList</span>(myList);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，<code>v1.erase(v1.begin() + 3);</code>可以写成<code>v1.erase(MoveIteractor(&amp;v1.begin(), 3));</code></p>
<h3 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h3><h4 id="1-sort"><a href="#1-sort" class="headerlink" title="1.sort()"></a>1.sort()</h4><p>对list进行排序</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">v1.<span class="built_in">sort</span>();</span><br></pre></td></tr></table></figure>

<h4 id="2-remove"><a href="#2-remove" class="headerlink" title="2.remove()"></a>2.remove()</h4><p>删除和指定值相等的元素</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">list&lt;<span class="type">int</span>&gt; myList = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line"><span class="comment">// myList =&gt; 1 2 3 4 5</span></span><br><span class="line">myList.<span class="built_in">remove</span>(<span class="number">3</span>)</span><br><span class="line"><span class="comment">// myList =&gt; 1 2 4 5</span></span><br></pre></td></tr></table></figure>

<h4 id="3-unique"><a href="#3-unique" class="headerlink" title="3.unique()"></a>3.unique()</h4><p>删除所有和前一个元素相同的元素</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">list&lt;<span class="type">int</span>&gt; myList = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line"><span class="comment">// myList =&gt; 1 2 3 4 5 5</span></span><br><span class="line">myList.<span class="built_in">unique</span>()</span><br><span class="line"><span class="comment">// myList =&gt; 1 2 3 4 5</span></span><br></pre></td></tr></table></figure>

<img src="/2024/07/18/STL/image-20240919142608882.png" alt="image-20240919142608882" style="zoom:50%;">

<p>只能删除与前一个相同的，相隔的不行</p>
<h4 id="4-merge"><a href="#4-merge" class="headerlink" title="4.merge()"></a>4.merge()</h4><p>合并两个链表，并清空被合并的那一个</p>
<p>合并两个链表时必须要先对每个链表进行排序，如果直接对一下两个链表进行合并，会报错</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">list&lt;int&gt; List1 = &#123; 1, 2, 11, 12, 13, 14, 19, 20 &#125;;</span><br><span class="line">list&lt;int&gt; List2 = &#123; 3, 4, 5, 18, 17 &#125;;</span><br></pre></td></tr></table></figure>

<img src="/2024/07/18/STL/image-20240919143746884.png" alt="image-20240919143746884" style="zoom:50%;">

<p>所以需要先对每个链表进行排序，然后再合并</p>
<p>合并后，所有数据被合并到List1中，List2被清空</p>
<img src="/2024/07/18/STL/image-20240919143837549.png" alt="image-20240919143837549" style="zoom:50%;">

<h4 id="5-reverse"><a href="#5-reverse" class="headerlink" title="5.reverse()"></a>5.reverse()</h4><p>颠倒链表</p>
<img src="/2024/07/18/STL/image-20240919144559547.png" alt="image-20240919144559547" style="zoom:50%;">

<h2 id="set-multiset-容器"><a href="#set-multiset-容器" class="headerlink" title="set &#x2F; multiset 容器"></a>set &#x2F; multiset 容器</h2><p>set&#x2F;multiset容器使用红黑树实现的，底层时树形结构</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">内部元素有序排列，新元素插入的位置取决于它的值，查找速度快</span><br><span class="line">支持通过键值实现快速读取</span><br><span class="line">不可以使用at.(pos)或[]操作符</span><br><span class="line">不可以直接修改容器中的值，如果希望修改一个元素值，必须先删除原有的元素，再插入新的元素</span><br><span class="line">multiset支持一个键值多次出现</span><br></pre></td></tr></table></figure>

<h3 id="构建set容器"><a href="#构建set容器" class="headerlink" title="构建set容器"></a>构建set容器</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// set容器构造函数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printset</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">set_constructor</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    set&lt;<span class="type">int</span>&gt; s1; <span class="comment">// 构造了一个空的容器，默认使用小于比较器（元素是从小到大排序）</span></span><br><span class="line">    set&lt;<span class="type">int</span>, less&lt;<span class="type">int</span>&gt;&gt; s2; <span class="comment">// 构造了一个空的容器，使用自定义的小于比较器</span></span><br><span class="line">    set&lt;<span class="type">int</span>, greater&lt;<span class="type">int</span>&gt;&gt; s3; <span class="comment">// 构造了一个空的容器，使用自定义的大于比较器</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> nArr[<span class="number">5</span>] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br><span class="line">    <span class="function">set&lt;<span class="type">int</span>&gt; <span class="title">set4</span><span class="params">(nArr, nArr + <span class="number">5</span>)</span></span>; <span class="comment">// 构造了一个容器，并将数组中的元素添加到容器中</span></span><br><span class="line"></span><br><span class="line">    for_each(set4.<span class="built_in">begin</span>(), set4.<span class="built_in">end</span>(), printset); <span class="comment">// 输出容器中的元素 </span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">set_constructor</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>for_each在algorithm头文件中，这个头文件实现了很多STL的算法</p>
<h3 id="方法-2"><a href="#方法-2" class="headerlink" title="方法"></a>方法</h3><h4 id="insert"><a href="#insert" class="headerlink" title="insert()"></a>insert()</h4><p>insert()函数可以在set容器中插入值，但是不能插入重复的值，如果插入了重复的值会被删掉</p>
<img src="/2024/07/18/STL/image-20240919150737674.png" alt="image-20240919150737674" style="zoom:50%;">

<img src="/2024/07/18/STL/image-20240919150824117.png" alt="image-20240919150824117" style="zoom:50%;">

<p>使用数组进行插入</p>
<p>插入后的值在s1中仍然是有序的</p>
<img src="/2024/07/18/STL/image-20240919151152191.png" alt="image-20240919151152191" style="zoom:50%;">

<h4 id="erase"><a href="#erase" class="headerlink" title="erase()"></a>erase()</h4><p>删除set容器中的值</p>
<img src="/2024/07/18/STL/image-20240919151520353.png" alt="image-20240919151520353" style="zoom:50%;">

<p>使用迭代器删除</p>
<p>删除迭代器指向位置的元素</p>
<img src="/2024/07/18/STL/image-20240919151735724.png" alt="image-20240919151735724" style="zoom:50%;">

<p>删除两个迭代器指向之间的元素</p>
<p>删除区间为[it2, it3)之间的值，左闭又开</p>
<img src="/2024/07/18/STL/image-20240919152023872.png" alt="image-20240919152023872" style="zoom:50%;">

<h4 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h4><p>set容器不能直接修改容器内的数据，只能先删除再插入新的元素</p>
<h4 id="find"><a href="#find" class="headerlink" title="find()"></a>find()</h4><p>查找函数，返回的值为迭代器</p>
<img src="/2024/07/18/STL/image-20240920210454030.png" alt="image-20240920210454030" style="zoom:50%;">

<h4 id="count"><a href="#count" class="headerlink" title="count()"></a>count()</h4><p>可以判断一个元素在容器里是否存在，对于multiset来说可以知道制定的元素有几个</p>
<img src="/2024/07/18/STL/image-20240920211201726.png" alt="image-20240920211201726" style="zoom:50%;">

<h2 id="map-multimap-容器"><a href="#map-multimap-容器" class="headerlink" title="map &#x2F; multimap 容器"></a>map &#x2F; multimap 容器</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">底层使用红黑树实现</span><br><span class="line">元素包含两部分（key, value）,key和value可以是任意类型</span><br><span class="line">根据元素的key自动排序，因此根据元素的key进行定位很快，但根据value定位很慢</span><br><span class="line">不能直接改变key，可以通过[]操作符直接存取元素的值</span><br><span class="line">map中不允许key相同的元素，multimap允许key相同的元素</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">mutimap&lt;<span class="type">int</span>, string, less&lt;<span class="type">int</span>&gt;&gt; ms;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>PolishMyBlog</title>
    <url>/2024/07/13/PolishMyBlog/</url>
    <content><![CDATA[<p>
    <div style="font-size: 55px; font-weight: bold; font-family: 'Times New Roman', serif; color: #5a5a5a">
        hexo × NexT
</div>
<br>
<div style="font-size: 25px; font-weight: bold; font-family: 'Times New Roman', serif; color: #7f7f7f">
    如何修改一个这样↓↓↓的主题
</div>
</p>




<p><img src="/2024/07/13/PolishMyBlog/image-20240713214740457.png" alt="image-20240713214740457"></p>
<span id="more"></span>

<h1 id="NexT"><a href="#NexT" class="headerlink" title="NexT"></a>NexT</h1><p>NexT是hexo的主题插件，首先要安装了hexo</p>
<h2 id="NexT安装和概况"><a href="#NexT安装和概况" class="headerlink" title="NexT安装和概况"></a>NexT安装和概况</h2><p>进入博客的路径，执行一下命令</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/theme-next/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure>

<p><img src="/2024/07/13/PolishMyBlog/image-20240713215651747.png" alt="image-20240713215651747"></p>
<p>找到博客目录下面的config文件</p>
<img src="/2024/07/13/PolishMyBlog/image-20240713215758194.png" alt="image-20240713215758194" style="zoom:67%;">

<p>这里推荐用VS Code直接把整个博客文件夹打开，方便后面直接操作</p>
<img src="/2024/07/13/PolishMyBlog/image-20240713215953724.png" alt="image-20240713215953724" style="zoom:67%;">

<p>这里本来是landscape，改成next即可</p>
<p><img src="/2024/07/13/PolishMyBlog/image-20240713220125493.png" alt="image-20240713220125493"></p>
<p>确保theme文件夹下面有next文件夹</p>
<img src="/2024/07/13/PolishMyBlog/image-20240713220210340.png" alt="image-20240713220210340" style="zoom:50%;">

<p>注意区分<strong>主题配置文件</strong>和<strong>站点配置文件</strong></p>
<img src="/2024/07/13/PolishMyBlog/image-20240713220338496.png" alt="image-20240713220338496" style="zoom:50%;">



<p>打开<strong>主题配置文件</strong>发现里面将近1000行，说明提供的选项还是非常多的</p>
<h2 id="NexT使用"><a href="#NexT使用" class="headerlink" title="NexT使用"></a>NexT使用</h2><p>先扔出一个<a href="https://theme-next.iissnan.com/getting-started.html">使用文档</a>，所有的使用方法基本上都在这里面，这里只教出现在我的博客里的，我这里没有的去前面的文档搜或者搜一下“hexo next 某某功能即可”</p>
<h3 id="4个主题"><a href="#4个主题" class="headerlink" title="4个主题"></a>4个主题</h3><p>首先确定一个主题：<br><img src="/2024/07/13/PolishMyBlog/image-20240713220816585.png" alt="image-20240713220816585"></p>
<p><a href="https://cn.bing.com/">看看四个主题有哪些不同</a>(自己搜一下)，想用哪个主题就把前面的注释删掉，留下一个就可以</p>
<h3 id="菜单"><a href="#菜单" class="headerlink" title="菜单"></a>菜单</h3><img src="/2024/07/13/PolishMyBlog/image-20240713221145429.png" alt="image-20240713221145429" style="zoom:67%;">

<p>在<strong>主题配置文件</strong>中搜索<strong>menu</strong>字段</p>
<img src="/2024/07/13/PolishMyBlog/image-20240713221242044.png" alt="image-20240713221242044" style="zoom:80%;">

<p>需要哪些就打开哪些</p>
<h3 id="头像栏"><a href="#头像栏" class="headerlink" title="头像栏"></a>头像栏</h3><p><img src="/2024/07/13/PolishMyBlog/image-20240713221355666.png" alt="image-20240713221355666"></p>
<p>搜索<strong>avatar</strong>字段</p>
<p><img src="/2024/07/13/PolishMyBlog/image-20240713221436424.png" alt="image-20240713221436424"></p>
<p>URL填一个链接，rounded就是圆形，rotated是旋转</p>
<h3 id="我的NOTICE"><a href="#我的NOTICE" class="headerlink" title="我的NOTICE"></a>我的NOTICE</h3><img src="/2024/07/13/PolishMyBlog/image-20240713221532135.png" alt="image-20240713221532135" style="zoom:67%;">

<p>这个NOTICE其实也是一篇笔记，把它置顶就变成了一个NOTICE或者自己编写的目录</p>
<p>如何置顶：top写大点，<strong>如果置顶多篇</strong>，也可以通过<strong>设置top的大小</strong>决定哪一篇置顶在最上面，哪一篇置顶在第二个</p>
<p><img src="/2024/07/13/PolishMyBlog/image-20240713222515503.png" alt="image-20240713222515503"></p>
<p>这一篇是直接用html写的</p>
<p><img src="/2024/07/13/PolishMyBlog/image-20240713221731239.png" alt="image-20240713221731239"></p>
<p>最下面的图片也是svg图标，这个图标想弄的话直接<strong>去iconfont抢</strong>就完了，找到喜欢的图标，调好颜色，打开开发者工具，找到这个图标的svg标签，复制下来就完了</p>
<p><img src="/2024/07/13/PolishMyBlog/image-20240713221918223.png" alt="image-20240713221918223"></p>
<h3 id="阅读时长统计"><a href="#阅读时长统计" class="headerlink" title="阅读时长统计"></a>阅读时长统计</h3><p>搜索<strong>symbols_count_time</strong>字段</p>
<img src="/2024/07/13/PolishMyBlog/image-20240713222307119.png" alt="image-20240713222307119" style="zoom:67%;">

<p>NexT好像已经直接支持了这个插件，如果不支持的话就下一个</p>
<h3 id="访客量统计"><a href="#访客量统计" class="headerlink" title="访客量统计"></a>访客量统计</h3><p>搜索<strong>busuanzi</strong>字段（不蒜子）</p>
<p><img src="/2024/07/13/PolishMyBlog/image-20240713222424045.png" alt="image-20240713222424045"></p>
<p>这几个都改成true即可</p>
<h3 id="阅读更多按钮"><a href="#阅读更多按钮" class="headerlink" title="阅读更多按钮"></a>阅读更多按钮</h3><p>在想要在主页上折叠的位置，在md中添加这么一个东西就行，不加这个的话，主页上会显示所有的文章，加载起来也非常慢</p>
<p><img src="/2024/07/13/PolishMyBlog/image-20240713230143130.png" alt="image-20240713230143130"></p>
<p><img src="/2024/07/13/PolishMyBlog/image-20240713230336767.png" alt="image-20240713230336767"></p>
<h3 id="圆角"><a href="#圆角" class="headerlink" title="圆角"></a>圆角</h3><img src="/2024/07/13/PolishMyBlog/image-20240713222720381.png" alt="image-20240713222720381" style="zoom:67%;">

<p><strong>Gemini主题</strong>默认是没有圆角的，上网搜也没搜到，通过自己摸索得出了一个方法</p>
<img src="/2024/07/13/PolishMyBlog/image-20240713222919893.png" alt="image-20240713222919893" style="zoom:67%;">

<p>找到这个文件，打开它</p>
<p><img src="/2024/07/13/PolishMyBlog/7d8690bb39833ee325fc75634bd90c8.png" alt="7d8690bb39833ee325fc75634bd90c8"></p>
<p>打开网页看一下，这个东西叫post-block，所以直接在这个文件末尾添加</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.post-block</span> &#123;</span><br><span class="line">  <span class="attribute">border-radius</span> = <span class="number">15px</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>就搞定了</p>
<p><img src="/2024/07/13/PolishMyBlog/image-20240713223143014.png" alt="image-20240713223143014"></p>
<h3 id="关于Mist主题分界线"><a href="#关于Mist主题分界线" class="headerlink" title="关于Mist主题分界线"></a>关于Mist主题分界线</h3><p>Mist主题分界线好像没有，这导致上一篇和下一篇看起来没有分隔，不好看</p>
<p><img src="/2024/07/13/PolishMyBlog/image-20240713223334965.png" alt="image-20240713223334965"></p>
<p>找到这个文件：<img src="/2024/07/13/PolishMyBlog/image-20240713223438190.png" alt="image-20240713223438190" style="zoom:67%;"></p>
<p>在最后添加这一段：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.post</span> &#123;</span><br><span class="line">   <span class="attribute">margin-top</span>: <span class="number">60px</span>;</span><br><span class="line">   <span class="attribute">margin-bottom</span>: <span class="number">60px</span>;</span><br><span class="line">   <span class="attribute">padding</span>: <span class="number">25px</span>;</span><br><span class="line">   -webkit-<span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">5px</span> <span class="built_in">rgba</span>(<span class="number">202</span>, <span class="number">203</span>, <span class="number">203</span>, .<span class="number">5</span>);</span><br><span class="line">   -moz-<span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">5px</span> <span class="built_in">rgba</span>(<span class="number">202</span>, <span class="number">203</span>, <span class="number">204</span>, .<span class="number">5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2024/07/13/PolishMyBlog/4af430ae6918c0c6c0387454921d91b.png" alt="4af430ae6918c0c6c0387454921d91b" style="zoom:50%;">

<p>这样就有边框了，边框颜色太浅不够宽就再调就可以了，学过css的都知道继续怎么折腾</p>
<p>但是发现两篇之间间隔貌似有点大，直接该上面.post中的margin是不行的</p>
<p>找到：<img src="/2024/07/13/PolishMyBlog/4a1c8635858e49dce80ff90580e7bda.png" alt="4a1c8635858e49dce80ff90580e7bda">这个地方（直接搜索就行)</p>
<p>这里本来应该是120px，该小一点间隔就变小了</p>
<img src="/2024/07/13/PolishMyBlog/4af7e4ebdc3f95f47ee6bdc1a1b9cb5.png" alt="4af7e4ebdc3f95f47ee6bdc1a1b9cb5" style="zoom: 50%;">

<h2 id="图片问题"><a href="#图片问题" class="headerlink" title="图片问题"></a>图片问题</h2><p>解决方法很多，这里讲一下我用的<strong>hexo-asset-image</strong>方法</p>
<h3 id="安装hexo-asset-image"><a href="#安装hexo-asset-image" class="headerlink" title="安装hexo-asset-image"></a>安装hexo-asset-image</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-asset-image --save</span><br></pre></td></tr></table></figure>

<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>然后修改站点配置文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">post_asset_folder: true</span><br></pre></td></tr></table></figure>

<p>打开<code>node_modules/hexo-asset-image/index.js</code>，将这一大部分复制到这个位置</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="string">&#x27;img&#x27;</span>).<span class="title function_">each</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ($(<span class="variable language_">this</span>).<span class="title function_">attr</span>(<span class="string">&#x27;src&#x27;</span>)) &#123;</span><br><span class="line">          <span class="comment">// For windows style path, we replace &#x27;\&#x27; to &#x27;/&#x27;.</span></span><br><span class="line">          <span class="keyword">var</span> src = $(<span class="variable language_">this</span>).<span class="title function_">attr</span>(<span class="string">&#x27;src&#x27;</span>).<span class="title function_">replace</span>(<span class="string">&#x27;\\&#x27;</span>, <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">          <span class="keyword">if</span> (!(<span class="regexp">/http[s]*.*|\/\/.*/</span>.<span class="title function_">test</span>(src)</span><br><span class="line">            || <span class="regexp">/^\s+\//</span>.<span class="title function_">test</span>(src)</span><br><span class="line">            || <span class="regexp">/^\s*\/uploads|images\//</span>.<span class="title function_">test</span>(src))) &#123;</span><br><span class="line">            <span class="comment">// For &quot;about&quot; page, the first part of &quot;src&quot; can&#x27;t be removed.</span></span><br><span class="line">            <span class="comment">// In addition, to support multi-level local directory.</span></span><br><span class="line">            <span class="keyword">var</span> linkArray = link.<span class="title function_">split</span>(<span class="string">&#x27;/&#x27;</span>).<span class="title function_">filter</span>(<span class="keyword">function</span> (<span class="params">elem</span>) &#123;</span><br><span class="line">              <span class="keyword">return</span> elem != <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">var</span> srcArray = src.<span class="title function_">split</span>(<span class="string">&#x27;/&#x27;</span>).<span class="title function_">filter</span>(<span class="keyword">function</span> (<span class="params">elem</span>) &#123;</span><br><span class="line">              <span class="keyword">return</span> elem != <span class="string">&#x27;&#x27;</span> &amp;&amp; elem != <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">if</span> (srcArray.<span class="property">length</span> &gt; <span class="number">1</span>)</span><br><span class="line">              srcArray.<span class="title function_">shift</span>();</span><br><span class="line">            src = srcArray.<span class="title function_">join</span>(<span class="string">&#x27;/&#x27;</span>);</span><br><span class="line"></span><br><span class="line">            $(<span class="variable language_">this</span>).<span class="title function_">attr</span>(<span class="string">&#x27;src&#x27;</span>, config.<span class="property">root</span> + link + src);</span><br><span class="line">            <span class="variable language_">console</span>.<span class="property">info</span>&amp;&amp;<span class="variable language_">console</span>.<span class="title function_">info</span>(<span class="string">&quot;update link as:--&gt;&quot;</span>+config.<span class="property">root</span> + link + src);</span><br><span class="line">            <span class="comment">// $(this).attr(&#x27;src&#x27;, src);</span></span><br><span class="line">            <span class="comment">// console.info &amp;&amp; console.info(&quot;update link as:--&gt;&quot; + src);</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="variable language_">console</span>.<span class="property">info</span> &amp;&amp; <span class="variable language_">console</span>.<span class="title function_">info</span>(<span class="string">&quot;no src attr, skipped...&quot;</span>);</span><br><span class="line">          <span class="variable language_">console</span>.<span class="property">info</span> &amp;&amp; <span class="variable language_">console</span>.<span class="title function_">info</span>($(<span class="variable language_">this</span>));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br></pre></td></tr></table></figure>



<p><img src="/2024/07/13/PolishMyBlog/image-20240713224430913.png" alt="image-20240713224430913"></p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><h4 id="配置Typora"><a href="#配置Typora" class="headerlink" title="配置Typora"></a>配置Typora</h4><p>这里改成同目录下与本文件同名文件夹</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./$&#123;filename&#125;</span><br></pre></td></tr></table></figure>



<p><img src="/2024/07/13/PolishMyBlog/image-20240713224604996.png" alt="image-20240713224604996"></p>
<h4 id="创建新文章"><a href="#创建新文章" class="headerlink" title="创建新文章"></a>创建新文章</h4><p>使用以下命令创建一篇文章（其实跟自己创一个文件夹再创一个md文件一样，不过这样方便）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo n 名字(不要加.md)</span><br><span class="line">如 hexo n notice</span><br></pre></td></tr></table></figure>

<p>那么在_posts文件夹下面会创建一个名叫notice的文件夹和一个notice.md，这样直接复制图片到md文件中就会在同名的这个文件夹中显示</p>
<p><img src="/2024/07/13/PolishMyBlog/image-20240713224906374.png" alt="image-20240713224906374"></p>
<h4 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h4><p>每次发布前都要执行一下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br></pre></td></tr></table></figure>

<p>清除一下缓存，不然使用hexo-asset-image上传的图片链接会出bug，如果上传的链接出了bug，那就hexo clean一下，然后hexo g，hexo d发布就可以了</p>
<p><img src="/2024/07/13/PolishMyBlog/gifgif.gif" alt="gifgif"></p>
<p>如果不发布图片，只修改文档内容，可以不hexo clean，但是如果图片链接出错了的话，就clean一下再g &amp; d</p>
]]></content>
      <categories>
        <category>Study Essay</category>
      </categories>
      <tags>
        <tag>Hexo NexT</tag>
      </tags>
  </entry>
  <entry>
    <title>检测虚拟机环境</title>
    <url>/2024/07/11/DetectVM/</url>
    <content><![CDATA[<p>
    <div style="font-size: 50px; font-weight: bold;  color: black">
    检测虚拟机环境
  </div>
<br>
</p>


<p>今天在写程序时，不想让这个程序在虚拟机上运行</p>
<span id="more"></span>

<p>于是尝试了一下代码：</p>
<h2 id="注册表和硬件检测"><a href="#注册表和硬件检测" class="headerlink" title="注册表和硬件检测"></a>注册表和硬件检测</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line">BOOL <span class="title function_">CheckRegistry</span><span class="params">()</span>;</span><br><span class="line">BOOL <span class="title function_">CheckHardware</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (CheckRegistry() || CheckHardware()) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;可能运行在虚拟机中。\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;未检测到虚拟机。\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查注册表</span></span><br><span class="line">BOOL <span class="title function_">CheckRegistry</span><span class="params">()</span> &#123;</span><br><span class="line">    HKEY hKey;</span><br><span class="line">    LONG lResult;</span><br><span class="line">    DWORD dwType, dwSize;</span><br><span class="line">    <span class="type">char</span> szBuffer[<span class="number">256</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查VMware注册表项</span></span><br><span class="line">    lResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE, <span class="string">&quot;SOFTWARE\\VMware, Inc.\\VMware Tools&quot;</span>, <span class="number">0</span>, KEY_READ, &amp;hKey);</span><br><span class="line">    <span class="keyword">if</span> (lResult == ERROR_SUCCESS) &#123;</span><br><span class="line">        RegCloseKey(hKey);</span><br><span class="line">        <span class="keyword">return</span> TRUE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查VirtualBox注册表项</span></span><br><span class="line">    lResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE, <span class="string">&quot;SOFTWARE\\Oracle\\VirtualBox Guest Additions&quot;</span>, <span class="number">0</span>, KEY_READ, &amp;hKey);</span><br><span class="line">    <span class="keyword">if</span> (lResult == ERROR_SUCCESS) &#123;</span><br><span class="line">        RegCloseKey(hKey);</span><br><span class="line">        <span class="keyword">return</span> TRUE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查硬件信息</span></span><br><span class="line">BOOL <span class="title function_">CheckHardware</span><span class="params">()</span> &#123;</span><br><span class="line">    SYSTEM_INFO sysInfo;</span><br><span class="line">    GetSystemInfo(&amp;sysInfo);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查处理器数量</span></span><br><span class="line">    <span class="keyword">if</span> (sysInfo.dwNumberOfProcessors &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> TRUE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查物理内存</span></span><br><span class="line">    MEMORYSTATUSEX memInfo;</span><br><span class="line">    memInfo.dwLength = <span class="keyword">sizeof</span>(memInfo);</span><br><span class="line">    GlobalMemoryStatusEx(&amp;memInfo);</span><br><span class="line">    <span class="keyword">if</span> (memInfo.ullTotalPhys &lt; <span class="number">1024</span> * <span class="number">1024</span> * <span class="number">1024</span>) &#123; <span class="comment">// 小于1GB</span></span><br><span class="line">        <span class="keyword">return</span> TRUE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol>
<li><p><strong>CheckRegistry函数</strong>：检查系统注册表中是否存在与虚拟机相关的注册表项。例如，VMware和VirtualBox在安装时会在注册表中添加特定的项。</p>
</li>
<li><p><strong>CheckHardware函数</strong>：检查系统的硬件信息，如处理器数量和物理内存大小。虚拟机通常具有较少的处理器和较小的内存。</p>
</li>
</ol>
<h3 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h3><p>   虚拟机可能会隐藏特征来避免被检测，在实际操作中，检测注册表确实没法判断成功程序所在环境为虚拟机，仍然能运行成功。</p>
<h2 id="GPU检测"><a href="#GPU检测" class="headerlink" title="GPU检测"></a>GPU检测</h2><p>突然想到了在打开任务管理器时，主机会显示GPU，而虚拟机不会显示GPU</p>
<p><strong>主机</strong>：<img src="/2024/07/11/DetectVM/image-20240711130459658.png" alt="image-20240711130459658" style="zoom:80%;"></p>
<p><strong>虚拟机Win11</strong>：<img src="/2024/07/11/DetectVM/image-20240711130535937.png" alt="image-20240711130535937" style="zoom:80%;"></p>
<p><strong>虚拟机Win10</strong>：<img src="/2024/07/11/DetectVM/image-20240711130613593.png" alt="image-20240711130613593" style="zoom:80%;"></p>
<h3 id="检测GPU信息"><a href="#检测GPU信息" class="headerlink" title="检测GPU信息"></a>检测GPU信息</h3><p>但是在使用程序检测GPU时，仍然在虚拟机中检测出：<img src="/2024/07/11/DetectVM/image-20240711130804118.png" alt="image-20240711130804118"></p>
<p>但是，这里发现GPU有很明显的特征，<strong>适配器名称有VMware字段</strong></p>
<p>所以，获取到GPU信息后，匹配一下适配器名称中有没有VMware或者VirtualBox字段</p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 辅助函数：检查字符串是否包含特定子字符串（不区分大小写）</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">containsSubstring</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* str, <span class="type">const</span> <span class="type">char</span>* substr)</span> &#123;</span><br><span class="line">	<span class="type">char</span> lowerStr[<span class="number">128</span>];</span><br><span class="line">	<span class="type">char</span> lowerSubstr[<span class="number">128</span>];</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 将字符串和子字符串转换为小写</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; str[i] &amp;&amp; i &lt; <span class="number">127</span>; i++) &#123;</span><br><span class="line">		lowerStr[i] = <span class="built_in">tolower</span>((<span class="type">unsigned</span> <span class="type">char</span>)str[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	lowerStr[i] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; substr[i] &amp;&amp; i &lt; <span class="number">127</span>; i++) &#123;</span><br><span class="line">		lowerSubstr[i] = <span class="built_in">tolower</span>((<span class="type">unsigned</span> <span class="type">char</span>)substr[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	lowerSubstr[i] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">strstr</span>(lowerStr, lowerSubstr) != <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DWORD WINAPI <span class="title function_">GPUProcDetect</span><span class="params">(LPVOID lpParameter)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 初始化Direct3D</span></span><br><span class="line">	IDirect3D9* pD3D = Direct3DCreate9(D3D_SDK_VERSION);</span><br><span class="line">	<span class="keyword">if</span> (pD3D == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Direct3D 初始化失败\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取系统中第一个显示适配器的信息</span></span><br><span class="line">	D3DADAPTER_IDENTIFIER9 adapterIdentifier;</span><br><span class="line">	HRESULT hr = pD3D-&gt;GetAdapterIdentifier(D3DADAPTER_DEFAULT, <span class="number">0</span>, &amp;adapterIdentifier);</span><br><span class="line">	<span class="keyword">if</span> (FAILED(hr)) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;获取适配器信息失败\n&quot;</span>);</span><br><span class="line">		pD3D-&gt;Release();</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 输出适配器信息</span></span><br><span class="line">	<span class="comment">/*printf(&quot;适配器名称: %s\n&quot;, adapterIdentifier.Description);</span></span><br><span class="line"><span class="comment">	printf(&quot;设备名称: %s\n&quot;, adapterIdentifier.DeviceName);</span></span><br><span class="line"><span class="comment">	printf(&quot;设备驱动版本: %d.%d.%d.%d\n&quot;,</span></span><br><span class="line"><span class="comment">		HIWORD(adapterIdentifier.DriverVersion.HighPart),</span></span><br><span class="line"><span class="comment">		LOWORD(adapterIdentifier.DriverVersion.HighPart),</span></span><br><span class="line"><span class="comment">		HIWORD(adapterIdentifier.DriverVersion.LowPart),</span></span><br><span class="line"><span class="comment">		LOWORD(adapterIdentifier.DriverVersion.LowPart));*/</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 检查适配器名称是否包含VMware或VirtualBox</span></span><br><span class="line">	<span class="keyword">if</span> (containsSubstring(adapterIdentifier.Description, <span class="string">&quot;vmware&quot;</span>) || containsSubstring(adapterIdentifier.Description, <span class="string">&quot;virtualbox&quot;</span>)) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;检测到虚拟机环境，程序将退出。\n&quot;</span>);</span><br><span class="line">		pD3D-&gt;Release();</span><br><span class="line">		Sleep(<span class="number">3000</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 释放Direct3D对象</span></span><br><span class="line">	pD3D-&gt;Release();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2024/07/11/DetectVM/image-20240711131135615.png" alt="image-20240711131135615"></p>
<p>这也只是一种现在比较可行的简单的检测方法，不保证可能厂商以后把这个特征也抹除</p>
]]></content>
      <categories>
        <category>Study Essay</category>
      </categories>
      <tags>
        <tag>Virtual Environment</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Venv pyenv update-alternatives</title>
    <url>/2024/07/07/live/</url>
    <content><![CDATA[<p>
  <div style="font-size: 40px; font-weight: bold; font-family: 'Times New Roman', serif; color: gray">
    Venv pyenv update-alternatives
  </div>
<div style="font-size: 13px; font-family: 'Times New Roman', serif; color: gray">
    2024/7/7 01:35:52
</div>


</p><h1 id="Venv-Python虚拟环境"><a href="#Venv-Python虚拟环境" class="headerlink" title="Venv Python虚拟环境"></a>Venv Python虚拟环境</h1><p>Venv，Python虚拟环境管理工具，可以创建独立的Python环境</p>
<span id="more"></span>

<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>1.创建虚拟环境</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">python -m venv 虚拟环境名</span><br></pre></td></tr></table></figure>

<p><img src="/2024/07/07/live/image-20240706203514916.png" alt="image-20240706203514916"></p>
<p>2.进入目录</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> 虚拟环境名/Scripts</span><br><span class="line">activate.bat</span><br></pre></td></tr></table></figure>

<p><img src="/2024/07/07/live/image-20240706204112177.png" alt="image-20240706204112177"></p>
<p>3.激活虚拟环境后，可以在这个虚拟环境中使用<code>pip install xxx</code>安装某个项目用到的包，如果不同项目使用不同包版本，则创建多个环境，再在环境中安装不同的包。</p>
<p>电脑环境中的包：</p>
<p><img src="/2024/07/07/live/image-20240706204350565.png" alt="image-20240706204350565"> </p>
<p>虚拟环境中的包：安了一个numpy</p>
<img src="/2024/07/07/live/image-20240706204529228.png" alt="image-20240706204529228" style="zoom:67%;"> 



<h1 id="PYENV"><a href="#PYENV" class="headerlink" title="PYENV"></a>PYENV</h1><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p><a href="https://github.com/pyenv-win/pyenv-win#readme">下载地址</a>:Github</p>
<p>下载解压到一个没有中文的文件夹中，将文件夹重命名为pyenv。</p>
<img src="/2024/07/07/live/image-20240706205420323.png" alt="image-20240706205420323" style="zoom:67%;">

<h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><h3 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h3><p>复制这个路径：</p>
<p><img src="/2024/07/07/live/image-20240706205518328.png" alt="image-20240706205518328"></p>
<p>配置系统环境变量：</p>
<p><img src="/2024/07/07/live/image-20240706205707273.png" alt="image-20240706205707273"></p>
<p>在系统环境变量的Path中添加：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">%PYENV%\bin </span><br><span class="line">%PYENV%\shims</span><br></pre></td></tr></table></figure>

<h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>打开cmd，直接输入pyenv</p>
<img src="/2024/07/07/live/image-20240706205935953.png" alt="image-20240706205935953" style="zoom:67%;">

<h2 id="pyenv命令"><a href="#pyenv命令" class="headerlink" title="pyenv命令"></a>pyenv命令</h2><p>查看pyenv-win支持的python版本列表：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pyenv install --list</span><br></pre></td></tr></table></figure>
<p>查看当前python对应版本：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pyenv version</span><br></pre></td></tr></table></figure>
<p>查看电脑安装的所有python版本：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pyenv versions</span><br></pre></td></tr></table></figure>
<p>安装指定版本 || 也可以在一个命令中安装多个版本：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">pyenv install &lt;version&gt; || pyenv install &lt;version&gt; &lt;version&gt;</span><br></pre></td></tr></table></figure>
<p>卸载指定版本：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pyenv uninstall &lt;version&gt;</span><br></pre></td></tr></table></figure>
<p>将python版本设置为全局版本(默认使用的python版本) 注意：必须先安装该版本。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pyenv global &lt;version&gt;</span><br></pre></td></tr></table></figure>
<p>设置本地版本(当在此文件夹中调用python时，都会使用给定的版本。) 注意：必须先安装该版本。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">pyenv <span class="built_in">local</span> &lt;version&gt;</span><br></pre></td></tr></table></figure>
<p>查看python版本来核对：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">python -V</span><br></pre></td></tr></table></figure>

<h2 id="pyenv安装python环境"><a href="#pyenv安装python环境" class="headerlink" title="pyenv安装python环境"></a>pyenv安装python环境</h2><p>1.查看可以安装的版本</p>
<p><img src="/2024/07/07/live/image-20240706210402179.png" alt="image-20240706210402179"></p>
<p>2.安装需要的Python版本</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">pyenv install &lt;version&gt;</span><br></pre></td></tr></table></figure>

<p>解决安装慢、安装超时问题：</p>
<p>打开<code>pyenv/pyenv-win/.versions_cache.xml</code>，将其中的下载地址改成华为云的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://mirrors.huaweicloud.com/python/</span><br></pre></td></tr></table></figure>



<p><img src="/2024/07/07/live/image-20240706221134067.png" alt="image-20240706221134067"></p>
<p>接着就下好了：</p>
<p><img src="/2024/07/07/live/image-20240706221302932.png" alt="image-20240706221302932"></p>
<p>4.设置Python版本</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">pyenv global &lt;version&gt;</span><br></pre></td></tr></table></figure>

<p><img src="/2024/07/07/live/image-20240706224136656.png" alt="image-20240706224136656"></p>
<h1 id="update-alternatives"><a href="#update-alternatives" class="headerlink" title="update-alternatives"></a>update-alternatives</h1><h2 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h2><h2 id="1-查看Python版本"><a href="#1-查看Python版本" class="headerlink" title="1.查看Python版本"></a>1.查看Python版本</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ls</span> /usr/bin/python*</span><br></pre></td></tr></table></figure>

<p><img src="/2024/07/07/live/image-20240707003021725.png" alt="image-20240707003021725"></p>
<p>有2.7和3.11两个版本</p>
<h2 id="2-当前版本"><a href="#2-当前版本" class="headerlink" title="2.当前版本"></a>2.当前版本</h2><img src="/2024/07/07/live/image-20240707003246279.png" alt="image-20240707003246279" style="zoom:80%;">

<h2 id="3-设置默认版本（设置优先级）"><a href="#3-设置默认版本（设置优先级）" class="headerlink" title="3.设置默认版本（设置优先级）"></a>3.设置默认版本（设置优先级）</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">update-alternatives --install /usr/bin/python python /usr/bin/python2 100</span><br><span class="line">update-alternatives --install /usr/bin/python python /usr/bin/python3 150</span><br></pre></td></tr></table></figure>

<p><img src="/2024/07/07/live/image-20240707003543304.png" alt="image-20240707003543304"></p>
<h2 id="4-切换版本"><a href="#4-切换版本" class="headerlink" title="4.切换版本"></a>4.切换版本</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">update-alternatives --config python</span><br></pre></td></tr></table></figure>

<img src="/2024/07/07/live/image-20240707003630386.png" alt="image-20240707003630386" style="zoom:67%;">

<p>输入编号开启手动模式即可</p>
<p><img src="/2024/07/07/live/image-20240707003713895.png" alt="image-20240707003713895"></p>
<p>这样Python版本就换成了2.7</p>
<h2 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h2><p>首先查看一下已安装的Java版本：</p>
<p><img src="/2024/07/07/live/image-20240707005540546.png" alt="image-20240707005540546"></p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>先来安装一个Java1.8 [下载地址](<a href="https://www.oracle.com/java/technologies/javase/javase8-archive-downloads.html">Java Archive Downloads - Java SE 8 (oracle.com)</a>)</p>
<img src="/2024/07/07/live/image-20240707011244573.png" alt="image-20240707011244573" style="zoom:67%;">

<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p /usr/local/java</span><br><span class="line"><span class="built_in">cp</span> jdk-8u251-linux-x64.tar.gz  /usr/local/java</span><br><span class="line">tar -zxvf jdk-8u251-linux-x64.tar.gz</span><br></pre></td></tr></table></figure>



<h3 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h3><p>将解压的jdk放到&#x2F;usr&#x2F;local中：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mv</span> jdk1.8.0_202 /usr/local</span><br></pre></td></tr></table></figure>



<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">vim /etc/profile</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入环境变量 复制到最下面</span></span><br><span class="line">JAVA_HOME=/usr/local/java/jdk1.8.0_251 </span><br><span class="line">PATH=<span class="variable">$PATH</span>:<span class="variable">$HOME</span>/bin:<span class="variable">$JAVA_HOME</span>/bin</span><br><span class="line"><span class="built_in">export</span> JAVA_HOME</span><br><span class="line"><span class="built_in">export</span> PATH</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通知Java目录</span></span><br><span class="line">update-alternatives --install <span class="string">&quot;/usr/bin/java&quot;</span> <span class="string">&quot;java&quot;</span> <span class="string">&quot;/usr/local/jdk1.8.0_202/bin/java&quot;</span> 1</span><br><span class="line">update-alternatives --install <span class="string">&quot;/usr/bin/javac&quot;</span> <span class="string">&quot;javac&quot;</span> <span class="string">&quot;/usr/local/jdk1.8.0_202/bin/javac&quot;</span> 1</span><br><span class="line">update-alternatives --install <span class="string">&quot;/usr/bin/javaws&quot;</span> <span class="string">&quot;javaws&quot;</span> <span class="string">&quot;/usr/local/jdk1.8.0_202/bin/javaws&quot;</span> 1</span><br><span class="line">update-alternatives --install <span class="string">&quot;/usr/bin/javaws&quot;</span> <span class="string">&quot;javaws&quot;</span> <span class="string">&quot;/usr/local/jdk1.8.0_202/bin/javaws&quot;</span> 1</span><br></pre></td></tr></table></figure>

<img src="/2024/07/07/live/image-20240707012540159.png" alt="image-20240707012540159" style="zoom:50%;">

<p><img src="/2024/07/07/live/image-20240707012757430.png" alt="image-20240707012757430"></p>
<h3 id="切换版本"><a href="#切换版本" class="headerlink" title="切换版本"></a>切换版本</h3><p><img src="/2024/07/07/live/image-20240707013016446.png" alt="image-20240707013016446"></p>
]]></content>
      <categories>
        <category>Study Essay</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>网络编程</title>
    <url>/2024/07/05/CInternet/</url>
    <content><![CDATA[<h1 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h1><h2 id="网络基础知识"><a href="#网络基础知识" class="headerlink" title="网络基础知识"></a>网络基础知识</h2><h3 id="网络OSI模型"><a href="#网络OSI模型" class="headerlink" title="网络OSI模型"></a>网络OSI模型</h3><p>网络OSI7层模型（Open Systems Interconnection）即开放系统互联。它是由ISO（Internet Organization for Standardization）制定</p>
<p>OSI时网络通讯的一种通用框架，它分为七层</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>层</th>
</tr>
</thead>
<tbody><tr>
<td>7</td>
<td>应用层（Application）</td>
</tr>
<tr>
<td>6</td>
<td>表示层（Presentation）</td>
</tr>
<tr>
<td>5</td>
<td>会话层（Session）</td>
</tr>
<tr>
<td>4</td>
<td>传输层（Transport）-&gt;TCP&#x2F;UDP</td>
</tr>
<tr>
<td>3</td>
<td>网络层（NetWork）</td>
</tr>
<tr>
<td>2</td>
<td>数据链路层（Data Link）</td>
</tr>
<tr>
<td>1</td>
<td>物理层（Physical）</td>
</tr>
</tbody></table>
<p>但不是所有网络通信都必须经过这7层模型，比如同一网段下两台计算机的交互，只需要经过物理层和数据链路层就够了。</p>
<p>网络上最重要的就是IP，IP就在网络层。</p>
<span id="more"></span>

<h2 id="Windows-Socket"><a href="#Windows-Socket" class="headerlink" title="Windows Socket"></a>Windows Socket</h2><h3 id="什么是套接字（Socket）"><a href="#什么是套接字（Socket）" class="headerlink" title="什么是套接字（Socket）"></a>什么是套接字（Socket）</h3><p>Socket又称套接字，它是TCP&#x2F;IP网络环境下应用程序与底层通信驱动程序之间运行的开发接口.它可以将应用程序与具体的TCP&#x2F;IP隔离开.使得应用程序不需要了解TCP&#x2F;IP的细节，就能够实现传输。</p>
<h3 id="套接字的服务方式和类型"><a href="#套接字的服务方式和类型" class="headerlink" title="套接字的服务方式和类型"></a>套接字的服务方式和类型</h3><p>根据底层协议的不同，Socket开发接口可以提供面向连接和无连接二种服务方式。</p>
<p>在Socketi通信中，套接字分为3种类型。</p>
<p>1.流式套接字.SOCK_STREAM</p>
<p>流式套接字是面向连接的、提供双向、有序、无重复且无记录边界的数据流服务，适用于处理大量数据，可靠性高，但开销也大。</p>
<p>2.数据报式套接字SOCK_DGRAM</p>
<p>UDP，一般应用在传输音视频文件，容许少量丢包</p>
<p>3.原始套接字</p>
<p>其中SOCK_STREAM、SOCK_DGRAM工作在传输层，SOCK_RAW工作在网络层。</p>
<h3 id="构建WinSock应用程序框架"><a href="#构建WinSock应用程序框架" class="headerlink" title="构建WinSock应用程序框架"></a>构建WinSock应用程序框架</h3><p>WinSock包含了两个主要的版本，即Socket1和winsock2，我们一般使用2<br>在使用时，需要包含如下头文件和lib文件<br>#include &lt;WinSock2.h&gt;<br>#pragma comment(lib,”ws2_32.lib”)</p>
<p>还需要初始化WinSocket<br>Int WSAAPI WSAStartup(WORD wVersionRequested &#x2F;&#x2F;版本号,LPWSADATA IpWSAData);		WSAData结构用于存放返回的Socket数据</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;WinSock2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib,<span class="string">&quot;ws2_32.lib&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    WORD wVersion = MAKEWORD(<span class="number">2</span>, <span class="number">2</span>);	 <span class="comment">//版本号</span></span><br><span class="line">    WSADATA wsaData;				<span class="comment">// 一个结构体，用来返回数据</span></span><br><span class="line">    <span class="keyword">if</span> (WSAStartup(wVersion, &amp;wsaData))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;WSAStartup failed&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;WSAStartup successed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>WSAData，存放Winsock返回的初始化信息：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">WSAData</span> &#123;</span></span><br><span class="line">    WORD wVersion;	<span class="comment">// Socket DLL期望用户使用的规范版本</span></span><br><span class="line">    WORD wHighVersion;	<span class="comment">// 可以支持的最高版本</span></span><br><span class="line">    <span class="type">char</span> szDescription[WSADESCRIPTION_LEN+<span class="number">1</span>];	<span class="comment">// 描述字符串</span></span><br><span class="line">    <span class="type">char</span> szSystemStatus[WSASYSSTATUS_LEN+<span class="number">1</span>];	<span class="comment">// 状态字符串</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> iMaxSockets;	<span class="comment">// 套接字的最大编号（WinSock2或稍后的版本忽略了该字段）</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> iMaxUdpDg; <span class="comment">// 忽略</span></span><br><span class="line">    <span class="type">char</span> FAR * lpVendorInfo;	<span class="comment">// 废弃</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="/2024/07/05/CInternet/image-20240708231715068.png" alt="image-20240708231715068"></p>
<h3 id="IP地址的表现形式"><a href="#IP地址的表现形式" class="headerlink" title="IP地址的表现形式"></a>IP地址的表现形式</h3><p>IP地址常用点分法来表示比如192.168.0.1，即4个0-255的整数表示</p>
<p>但是在计算机中不使用点分法来保存IP地址.这样会浪费存诸空间.而且不便于根据IP地址和子网掩码来计算子网信息<br>所以在计算机中使用无符号长整形数来存诸表示IP地址<br>1.网络字节顺序(NetWork Byte Order,NBO)<br>在网络传送中，IP地址被保存为32位的二进制数在低位存储地址中保存数据的高位字节这种存储顺序格式被称为网络字节顺序.数据按照32位的二进制数为一组进行传输。因为采用网络字节顺序，所以数据的传输顺序是由高到低的。<br>在VC中使用In_addr来保存IP地址。 inet_addr和 inet_ntoa</p>
<p>in_addr：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span> UCHAR s_b1,s_b2,s_b3,s_b4; &#125; S_un_b;	<span class="comment">//点分法保存</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span> USHORT s_w1,s_w2; &#125; S_un_w;			<span class="comment">//分两部分保存</span></span><br><span class="line">        ULONG S_addr;								<span class="comment">//保存为32位</span></span><br><span class="line">    &#125; S_un;</span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> s_addr  S_un.S_addr <span class="comment">/* can be used for most tcp &amp; ip code */</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> s_host  S_un.S_un_b.s_b2    <span class="comment">// host on imp</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> s_net   S_un.S_un_b.s_b1    <span class="comment">// network</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> s_imp   S_un.S_un_w.s_w2    <span class="comment">// imp</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> s_impno S_un.S_un_b.s_b4    <span class="comment">// imp #</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> s_lh    S_un.S_un_b.s_b3    <span class="comment">// logical host</span></span></span><br><span class="line">&#125; IN_ADDR, *PIN_ADDR, FAR *LPIN_ADDR;</span><br></pre></td></tr></table></figure>

<p><img src="/2024/07/05/CInternet/image-20240709130551236.png" alt="image-20240709130551236"></p>
<p>2.主机字节顺序(Host Byte Order，HBO)两种格式<br>不同的主机在对IP地址进行存储时使用的格式也不同，所以需要通过下列四个函数<br>来实现主机和网络字节顺序的互转<br>htonl 将主机字节顺序格式IP地址转换成为TCP&#x2F;IP网络字节顺序			Host to Net u_long<br>htons主机转网络u_short型<br>ntohl网络转主机 u_long			Net to Host u_long<br>ntohs网络转主机 u_short</p>
<h3 id="WinSock-TCP-IP连接流程"><a href="#WinSock-TCP-IP连接流程" class="headerlink" title="WinSock TCP&#x2F;IP连接流程"></a>WinSock TCP&#x2F;IP连接流程</h3><table>
<thead>
<tr>
<th>服务端</th>
<th>客户端</th>
</tr>
</thead>
<tbody><tr>
<td>1.建立流式套接字</td>
<td>1.建立流式套接字</td>
</tr>
<tr>
<td>2.套接字：与本地地址绑定</td>
<td></td>
</tr>
<tr>
<td>3.通知TCP服务器准备连接</td>
<td></td>
</tr>
<tr>
<td>4.等待客户端的连接</td>
<td>2.将套接字与远程主机连接</td>
</tr>
<tr>
<td>5.建立连接</td>
<td></td>
</tr>
<tr>
<td>6.在套接字上读写数据</td>
<td>3.在套接字上读写数据</td>
</tr>
<tr>
<td>7.关闭套接字</td>
<td>4.关闭套接字结束对话</td>
</tr>
<tr>
<td>8.关闭最初的套接字，结束服务</td>
<td></td>
</tr>
</tbody></table>
<p><img src="/2024/07/05/CInternet/image-20240709205503926.png" alt="image-20240709205503926"></p>
<p>地址族：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> AF_UNSPEC       0               <span class="comment">// unspecified</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AF_UNIX         1               <span class="comment">// local to host (pipes, portals)</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AF_INET         2               <span class="comment">// internetwork: UDP, TCP, etc.</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AF_IMPLINK      3               <span class="comment">// arpanet imp addresses</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AF_PUP          4               <span class="comment">// pup protocols: e.g. BSP</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AF_CHAOS        5               <span class="comment">// mit CHAOS protocols</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AF_NS           6               <span class="comment">// XEROX NS protocols</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AF_IPX          AF_NS           <span class="comment">// IPX protocols: IPX, SPX, etc.</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AF_ISO          7               <span class="comment">// ISO protocols</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AF_OSI          AF_ISO          <span class="comment">// OSI is ISO</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AF_ECMA         8               <span class="comment">// european computer manufacturers</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AF_DATAKIT      9               <span class="comment">// datakit protocols</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AF_CCITT        10              <span class="comment">// CCITT protocols, X.25 etc</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AF_SNA          11              <span class="comment">// IBM SNA</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AF_DECnet       12              <span class="comment">// DECnet</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AF_DLI          13              <span class="comment">// Direct data link interface</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AF_LAT          14              <span class="comment">// LAT</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AF_HYLINK       15              <span class="comment">// NSC Hyperchannel</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AF_APPLETALK    16              <span class="comment">// AppleTalk</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AF_NETBIOS      17              <span class="comment">// NetBios-style addresses</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AF_VOICEVIEW    18              <span class="comment">// VoiceView</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AF_FIREFOX      19              <span class="comment">// Protocols from Firefox</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AF_UNKNOWN1     20              <span class="comment">// Somebody is using this!</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AF_BAN          21              <span class="comment">// Banyan</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AF_ATM          22              <span class="comment">// Native ATM Services</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AF_INET6        23              <span class="comment">// Internetwork Version 6</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AF_CLUSTER      24              <span class="comment">// Microsoft Wolfpack</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AF_12844        25              <span class="comment">// IEEE 1284.4 WG AF</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AF_IRDA         26              <span class="comment">// IrDA</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AF_NETDES       28              <span class="comment">// Network Designers OSI &amp; gateway</span></span></span><br></pre></td></tr></table></figure>

<p>套接字类型：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SOCK_STREAM     1               <span class="comment">/* stream socket */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SOCK_DGRAM      2               <span class="comment">/* datagram socket */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SOCK_RAW        3               <span class="comment">/* raw-protocol interface */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SOCK_RDM        4               <span class="comment">/* reliably-delivered message */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SOCK_SEQPACKET  5               <span class="comment">/* sequenced packet stream */</span></span></span><br></pre></td></tr></table></figure>

<p>套接字使用的协议：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span>(_WIN32_WINNT &gt;= 0x0501)</span></span><br><span class="line">    IPPROTO_HOPOPTS       = <span class="number">0</span>,  <span class="comment">// IPv6 Hop-by-Hop options</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span><span class="comment">//(_WIN32_WINNT &gt;= 0x0501)</span></span></span><br><span class="line">    IPPROTO_ICMP          = <span class="number">1</span>,</span><br><span class="line">    IPPROTO_IGMP          = <span class="number">2</span>,</span><br><span class="line">    IPPROTO_GGP           = <span class="number">3</span>,</span><br><span class="line"><span class="meta">#<span class="keyword">if</span>(_WIN32_WINNT &gt;= 0x0501)</span></span><br><span class="line">    IPPROTO_IPV4          = <span class="number">4</span>,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span><span class="comment">//(_WIN32_WINNT &gt;= 0x0501)</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span>(_WIN32_WINNT &gt;= 0x0600)</span></span><br><span class="line">    IPPROTO_ST            = <span class="number">5</span>,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span><span class="comment">//(_WIN32_WINNT &gt;= 0x0600)</span></span></span><br><span class="line">    IPPROTO_TCP           = <span class="number">6</span>,</span><br><span class="line"><span class="meta">#<span class="keyword">if</span>(_WIN32_WINNT &gt;= 0x0600)</span></span><br><span class="line">    IPPROTO_CBT           = <span class="number">7</span>,</span><br><span class="line">    IPPROTO_EGP           = <span class="number">8</span>,</span><br><span class="line">    IPPROTO_IGP           = <span class="number">9</span>,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span><span class="comment">//(_WIN32_WINNT &gt;= 0x0600)</span></span></span><br><span class="line">    IPPROTO_PUP           = <span class="number">12</span>,</span><br><span class="line">    IPPROTO_UDP           = <span class="number">17</span>,</span><br><span class="line">    IPPROTO_IDP           = <span class="number">22</span>,</span><br><span class="line"><span class="meta">#<span class="keyword">if</span>(_WIN32_WINNT &gt;= 0x0600)</span></span><br><span class="line">    IPPROTO_RDP           = <span class="number">27</span>,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span><span class="comment">//(_WIN32_WINNT &gt;= 0x0600)</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span>(_WIN32_WINNT &gt;= 0x0501)</span></span><br><span class="line">    IPPROTO_IPV6          = <span class="number">41</span>, <span class="comment">// IPv6 header</span></span><br><span class="line">    IPPROTO_ROUTING       = <span class="number">43</span>, <span class="comment">// IPv6 Routing header</span></span><br><span class="line">    IPPROTO_FRAGMENT      = <span class="number">44</span>, <span class="comment">// IPv6 fragmentation header</span></span><br><span class="line">    IPPROTO_ESP           = <span class="number">50</span>, <span class="comment">// encapsulating security payload</span></span><br><span class="line">    IPPROTO_AH            = <span class="number">51</span>, <span class="comment">// authentication header</span></span><br><span class="line">    IPPROTO_ICMPV6        = <span class="number">58</span>, <span class="comment">// ICMPv6</span></span><br><span class="line">    IPPROTO_NONE          = <span class="number">59</span>, <span class="comment">// IPv6 no next header</span></span><br><span class="line">    IPPROTO_DSTOPTS       = <span class="number">60</span>, <span class="comment">// IPv6 Destination options</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span><span class="comment">//(_WIN32_WINNT &gt;= 0x0501)</span></span></span><br><span class="line"></span><br><span class="line">    IPPROTO_ND            = <span class="number">77</span>,</span><br><span class="line"><span class="meta">#<span class="keyword">if</span>(_WIN32_WINNT &gt;= 0x0501)</span></span><br><span class="line">    IPPROTO_ICLFXBM       = <span class="number">78</span>,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span><span class="comment">//(_WIN32_WINNT &gt;= 0x0501)</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span>(_WIN32_WINNT &gt;= 0x0600)</span></span><br><span class="line">    IPPROTO_PIM           = <span class="number">103</span>,</span><br><span class="line">    IPPROTO_PGM           = <span class="number">113</span>,</span><br><span class="line">    IPPROTO_L2TP          = <span class="number">115</span>,</span><br><span class="line">    IPPROTO_SCTP          = <span class="number">132</span>,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span><span class="comment">//(_WIN32_WINNT &gt;= 0x0600)</span></span></span><br><span class="line">    IPPROTO_RAW           = <span class="number">255</span>,</span><br><span class="line"></span><br><span class="line">    IPPROTO_MAX           = <span class="number">256</span>,</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  These are reserved for internal use by Windows.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">    IPPROTO_RESERVED_RAW  = <span class="number">257</span>,</span><br><span class="line">    IPPROTO_RESERVED_IPSEC  = <span class="number">258</span>,</span><br><span class="line">    IPPROTO_RESERVED_IPSECOFFLOAD  = <span class="number">259</span>,</span><br><span class="line">    IPPROTO_RESERVED_WNV = <span class="number">260</span>,</span><br><span class="line">    IPPROTO_RESERVED_MAX  = <span class="number">261</span></span><br><span class="line">&#125; IPPROTO, *PIPROTO;</span><br></pre></td></tr></table></figure>

<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><h4 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;winsock2.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;ws2_32.lib&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PORT 8080</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFSIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    WSADATA wsaData;</span><br><span class="line">    <span class="type">int</span> iResult;</span><br><span class="line">    SOCKET server_fd, new_socket;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">address</span>;</span></span><br><span class="line">    <span class="type">int</span> addrlen = <span class="keyword">sizeof</span>(address);</span><br><span class="line">    <span class="type">char</span> buffer[BUFSIZE] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *hello = <span class="string">&quot;Hello from server&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化 Winsock</span></span><br><span class="line">    iResult = WSAStartup(MAKEWORD(<span class="number">2</span>, <span class="number">2</span>), &amp;wsaData);</span><br><span class="line">    <span class="keyword">if</span> (iResult != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;WSAStartup failed: %d\n&quot;</span>, iResult);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建socket文件描述符</span></span><br><span class="line">    <span class="keyword">if</span> ((server_fd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>)) == INVALID_SOCKET) &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket failed&quot;</span>);</span><br><span class="line">        WSACleanup();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定socket到端口</span></span><br><span class="line">    address.sin_family = AF_INET;</span><br><span class="line">    address.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">    address.sin_port = htons(PORT);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bind(server_fd, (<span class="keyword">struct</span> sockaddr *)&amp;address, <span class="keyword">sizeof</span>(address)) == SOCKET_ERROR) &#123;</span><br><span class="line">        perror(<span class="string">&quot;bind failed&quot;</span>);</span><br><span class="line">        closesocket(server_fd);</span><br><span class="line">        WSACleanup();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听</span></span><br><span class="line">    <span class="keyword">if</span> (listen(server_fd, <span class="number">3</span>) == SOCKET_ERROR) &#123;</span><br><span class="line">        perror(<span class="string">&quot;listen&quot;</span>);</span><br><span class="line">        closesocket(server_fd);</span><br><span class="line">        WSACleanup();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接受新连接</span></span><br><span class="line">    <span class="keyword">if</span> ((new_socket = accept(server_fd, (<span class="keyword">struct</span> sockaddr *)&amp;address, &amp;addrlen)) == INVALID_SOCKET) &#123;</span><br><span class="line">        perror(<span class="string">&quot;accept&quot;</span>);</span><br><span class="line">        closesocket(server_fd);</span><br><span class="line">        WSACleanup();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取客户端发送的数据</span></span><br><span class="line">    iResult = recv(new_socket, buffer, BUFSIZE, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (iResult &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Received: %s\n&quot;</span>, buffer);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (iResult == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Connection closing...\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        perror(<span class="string">&quot;recv failed&quot;</span>);</span><br><span class="line">        closesocket(new_socket);</span><br><span class="line">        closesocket(server_fd);</span><br><span class="line">        WSACleanup();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送数据到客户端</span></span><br><span class="line">    send(new_socket, hello, <span class="built_in">strlen</span>(hello), <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello message sent\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭socket</span></span><br><span class="line">    closesocket(new_socket);</span><br><span class="line">    closesocket(server_fd);</span><br><span class="line">    WSACleanup();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;winsock2.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;ws2_32.lib&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PORT 8080</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFSIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    WSADATA wsaData;</span><br><span class="line">    <span class="type">int</span> iResult;</span><br><span class="line">    SOCKET client_fd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>;</span></span><br><span class="line">    <span class="type">char</span> buffer[BUFSIZE] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *hello = <span class="string">&quot;Hello from client&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化 Winsock</span></span><br><span class="line">    iResult = WSAStartup(MAKEWORD(<span class="number">2</span>, <span class="number">2</span>), &amp;wsaData);</span><br><span class="line">    <span class="keyword">if</span> (iResult != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;WSAStartup failed: %d\n&quot;</span>, iResult);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建socket文件描述符</span></span><br><span class="line">    <span class="keyword">if</span> ((client_fd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>)) == INVALID_SOCKET) &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket failed&quot;</span>);</span><br><span class="line">        WSACleanup();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置服务器地址</span></span><br><span class="line">    serv_addr.sin_family = AF_INET;</span><br><span class="line">    serv_addr.sin_port = htons(PORT);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将IP地址从字符串转换为网络地址</span></span><br><span class="line">    <span class="keyword">if</span> (inet_pton(AF_INET, <span class="string">&quot;127.0.0.1&quot;</span>, &amp;serv_addr.sin_addr) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;inet_pton failed&quot;</span>);</span><br><span class="line">        closesocket(client_fd);</span><br><span class="line">        WSACleanup();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连接到服务器</span></span><br><span class="line">    <span class="keyword">if</span> (connect(client_fd, (<span class="keyword">struct</span> sockaddr *)&amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr)) == SOCKET_ERROR) &#123;</span><br><span class="line">        perror(<span class="string">&quot;connect failed&quot;</span>);</span><br><span class="line">        closesocket(client_fd);</span><br><span class="line">        WSACleanup();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送数据到服务器</span></span><br><span class="line">    send(client_fd, hello, <span class="built_in">strlen</span>(hello), <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello message sent\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取服务器发送的数据</span></span><br><span class="line">    iResult = recv(client_fd, buffer, BUFSIZE, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (iResult &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Received: %s\n&quot;</span>, buffer);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (iResult == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Connection closed\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        perror(<span class="string">&quot;recv failed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭socket</span></span><br><span class="line">    closesocket(client_fd);</span><br><span class="line">    WSACleanup();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="面向非连接的SOCKET编程"><a href="#面向非连接的SOCKET编程" class="headerlink" title="面向非连接的SOCKET编程"></a>面向非连接的SOCKET编程</h2><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>面向非连接（UDP）的特点：</p>
<p>1.不需要在服务端和客户端之间进建立连接</p>
<p>2.不对收到的数据进行排序</p>
<p>3.对接收到的数据包不发送确认信息，发送端无法知道数据是否被正确接收，也不会重新发送数据</p>
<p>4.传送数据较TCP快，系统开销也少</p>
<h3 id="UDP连接流程"><a href="#UDP连接流程" class="headerlink" title="UDP连接流程"></a>UDP连接流程</h3><table>
<thead>
<tr>
<th>主机流程（UDP）</th>
<th>客户端流程</th>
</tr>
</thead>
<tbody><tr>
<td>1.建立流式套接字</td>
<td>1.建立流式套接字</td>
</tr>
<tr>
<td>2.套接字：与本地地址绑定</td>
<td></td>
</tr>
<tr>
<td>3.在套接字上读&#x2F;写数据</td>
<td>2.在套接字上读&#x2F;写数据</td>
</tr>
<tr>
<td>4.关闭套接字</td>
<td>3.关闭套接字</td>
</tr>
</tbody></table>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><h4 id="服务端-1"><a href="#服务端-1" class="headerlink" title="服务端"></a>服务端</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;winsock2.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;ws2_32.lib&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PORT 8080</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFSIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    WSADATA wsaData;</span><br><span class="line">    <span class="type">int</span> iResult;</span><br><span class="line">    SOCKET server_fd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">address</span>, <span class="title">client_addr</span>;</span></span><br><span class="line">    <span class="type">int</span> addrlen = <span class="keyword">sizeof</span>(client_addr);</span><br><span class="line">    <span class="type">char</span> buffer[BUFSIZE] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *hello = <span class="string">&quot;Hello from server&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化 Winsock</span></span><br><span class="line">    iResult = WSAStartup(MAKEWORD(<span class="number">2</span>, <span class="number">2</span>), &amp;wsaData);</span><br><span class="line">    <span class="keyword">if</span> (iResult != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;WSAStartup failed: %d\n&quot;</span>, iResult);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建socket文件描述符</span></span><br><span class="line">    <span class="keyword">if</span> ((server_fd = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>)) == INVALID_SOCKET) &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket failed&quot;</span>);</span><br><span class="line">        WSACleanup();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定socket到端口</span></span><br><span class="line">    address.sin_family = AF_INET;</span><br><span class="line">    address.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">    address.sin_port = htons(PORT);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bind(server_fd, (<span class="keyword">struct</span> sockaddr *)&amp;address, <span class="keyword">sizeof</span>(address)) == SOCKET_ERROR) &#123;</span><br><span class="line">        perror(<span class="string">&quot;bind failed&quot;</span>);</span><br><span class="line">        closesocket(server_fd);</span><br><span class="line">        WSACleanup();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接收数据</span></span><br><span class="line">    iResult = recvfrom(server_fd, buffer, BUFSIZE, <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr *)&amp;client_addr, &amp;addrlen);</span><br><span class="line">    <span class="keyword">if</span> (iResult &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Received: %s\n&quot;</span>, buffer);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        perror(<span class="string">&quot;recvfrom failed&quot;</span>);</span><br><span class="line">        closesocket(server_fd);</span><br><span class="line">        WSACleanup();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送数据</span></span><br><span class="line">    sendto(server_fd, hello, <span class="built_in">strlen</span>(hello), <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr *)&amp;client_addr, addrlen);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello message sent\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭socket</span></span><br><span class="line">    closesocket(server_fd);</span><br><span class="line">    WSACleanup();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="客户端-1"><a href="#客户端-1" class="headerlink" title="客户端"></a>客户端</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;winsock2.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;ws2_32.lib&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PORT 8080</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFSIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    WSADATA wsaData;</span><br><span class="line">    <span class="type">int</span> iResult;</span><br><span class="line">    SOCKET client_fd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>;</span></span><br><span class="line">    <span class="type">char</span> buffer[BUFSIZE] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *hello = <span class="string">&quot;Hello from client&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化 Winsock</span></span><br><span class="line">    iResult = WSAStartup(MAKEWORD(<span class="number">2</span>, <span class="number">2</span>), &amp;wsaData);</span><br><span class="line">    <span class="keyword">if</span> (iResult != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;WSAStartup failed: %d\n&quot;</span>, iResult);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建socket文件描述符</span></span><br><span class="line">    <span class="keyword">if</span> ((client_fd = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>)) == INVALID_SOCKET) &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket failed&quot;</span>);</span><br><span class="line">        WSACleanup();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置服务器地址</span></span><br><span class="line">    serv_addr.sin_family = AF_INET;</span><br><span class="line">    serv_addr.sin_port = htons(PORT);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将IP地址从字符串转换为网络地址</span></span><br><span class="line">    <span class="keyword">if</span> (inet_pton(AF_INET, <span class="string">&quot;127.0.0.1&quot;</span>, &amp;serv_addr.sin_addr) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;inet_pton failed&quot;</span>);</span><br><span class="line">        closesocket(client_fd);</span><br><span class="line">        WSACleanup();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送数据到服务器</span></span><br><span class="line">    sendto(client_fd, hello, <span class="built_in">strlen</span>(hello), <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr *)&amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello message sent\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接收服务器发送的数据</span></span><br><span class="line">    iResult = recvfrom(client_fd, buffer, BUFSIZE, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (iResult &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Received: %s\n&quot;</span>, buffer);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        perror(<span class="string">&quot;recvfrom failed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭socket</span></span><br><span class="line">    closesocket(client_fd);</span><br><span class="line">    WSACleanup();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="阻塞式模型"><a href="#阻塞式模型" class="headerlink" title="阻塞式模型"></a>阻塞式模型</h2><h3 id="阻塞式"><a href="#阻塞式" class="headerlink" title="阻塞式"></a>阻塞式</h3><p>什么是阻塞式？</p>
<p>1.在创建一个套接字后，默认都是阻塞式的Winsocket的IO函数比如：Send和Recv，必须等待函数完成相应的I&#x2F;O操作后，才能继续</p>
<p>什么是非阻塞式？</p>
<p>1.通过调用ioctlsocket(SOCKET s, long cmd, u_long *arpg)函数，改变该套接字的模式，<br>U_long nNoBlock &#x3D;1;<br>loctlsocket(s,FIONBIO,&amp;nNoBlock);</p>
<p>2.无论操作是否完成，非阻塞式函数都会立即返回。例如，在非阻塞模式下调用recv接收数据时，程序会直接读取网络缓冲区中的数据。无论是否读到数据，函数都会立即返回</p>
<h3 id="阻塞式迭代模式"><a href="#阻塞式迭代模式" class="headerlink" title="阻塞式迭代模式"></a>阻塞式迭代模式</h3><p>1.每次只服务一个连接，只有在服务完当前客户端连接之后，才会继续服务下一个客户端连接</p>
<h4 id="阻塞式迭代模式步骤"><a href="#阻塞式迭代模式步骤" class="headerlink" title="阻塞式迭代模式步骤"></a>阻塞式迭代模式步骤</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.先处理连接 绑定本地地址和监听</span></span><br><span class="line">SOCKET <span class="title function_">Bind_Listen</span><span class="params">(<span class="type">int</span> nBacklog)</span></span><br><span class="line"><span class="comment">// 2.接收一个客户端连接并返回对应的连接的套接字</span></span><br><span class="line">SOCKET <span class="title function_">AcceptConnetion</span><span class="params">(SOCKET hSocket)</span></span><br><span class="line"><span class="comment">// 3.处理一个客户端的连接，实现接收和发送数据</span></span><br><span class="line">BOOL <span class="title function_">ClientConFun</span><span class="params">(SOCKET sd)</span></span><br><span class="line"><span class="comment">// 4.关闭一个连接</span></span><br><span class="line">BOOL <span class="title function_">CloseConnect</span><span class="params">(SOCKET sd)</span></span><br><span class="line"><span class="comment">// 5.服务器主体</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MyTepSerFun</span><span class="params">()</span></span><br></pre></td></tr></table></figure>

<h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><h5 id="服务端-2"><a href="#服务端-2" class="headerlink" title="服务端"></a>服务端</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;winsock2.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;ws2_32.lib&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PORT 8080</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFSIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 先处理连接 绑定本地地址和监听</span></span><br><span class="line">SOCKET <span class="title function_">Bind_Listen</span><span class="params">(<span class="type">int</span> nBacklog)</span> &#123;</span><br><span class="line">    WSADATA wsaData;</span><br><span class="line">    <span class="type">int</span> iResult;</span><br><span class="line">    SOCKET server_fd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">address</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化 Winsock</span></span><br><span class="line">    iResult = WSAStartup(MAKEWORD(<span class="number">2</span>, <span class="number">2</span>), &amp;wsaData);</span><br><span class="line">    <span class="keyword">if</span> (iResult != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;WSAStartup failed: %d\n&quot;</span>, iResult);</span><br><span class="line">        <span class="keyword">return</span> INVALID_SOCKET;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建socket文件描述符</span></span><br><span class="line">    <span class="keyword">if</span> ((server_fd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>)) == INVALID_SOCKET) &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket failed&quot;</span>);</span><br><span class="line">        WSACleanup();</span><br><span class="line">        <span class="keyword">return</span> INVALID_SOCKET;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定socket到端口</span></span><br><span class="line">    address.sin_family = AF_INET;</span><br><span class="line">    address.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">    address.sin_port = htons(PORT);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bind(server_fd, (<span class="keyword">struct</span> sockaddr *)&amp;address, <span class="keyword">sizeof</span>(address)) == SOCKET_ERROR) &#123;</span><br><span class="line">        perror(<span class="string">&quot;bind failed&quot;</span>);</span><br><span class="line">        closesocket(server_fd);</span><br><span class="line">        WSACleanup();</span><br><span class="line">        <span class="keyword">return</span> INVALID_SOCKET;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听</span></span><br><span class="line">    <span class="keyword">if</span> (listen(server_fd, nBacklog) == SOCKET_ERROR) &#123;</span><br><span class="line">        perror(<span class="string">&quot;listen&quot;</span>);</span><br><span class="line">        closesocket(server_fd);</span><br><span class="line">        WSACleanup();</span><br><span class="line">        <span class="keyword">return</span> INVALID_SOCKET;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> server_fd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 接收一个客户端连接并返回对应的连接的套接字</span></span><br><span class="line">SOCKET <span class="title function_">AcceptConnetion</span><span class="params">(SOCKET hSocket)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client_addr</span>;</span></span><br><span class="line">    <span class="type">int</span> addrlen = <span class="keyword">sizeof</span>(client_addr);</span><br><span class="line">    SOCKET new_socket = accept(hSocket, (<span class="keyword">struct</span> sockaddr *)&amp;client_addr, &amp;addrlen);</span><br><span class="line">    <span class="keyword">if</span> (new_socket == INVALID_SOCKET) &#123;</span><br><span class="line">        perror(<span class="string">&quot;accept&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> new_socket;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 处理一个客户端的连接，实现接收和发送数据</span></span><br><span class="line">BOOL <span class="title function_">ClientConFun</span><span class="params">(SOCKET sd)</span> &#123;</span><br><span class="line">    <span class="type">char</span> buffer[BUFSIZE] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *hello = <span class="string">&quot;Hello from server&quot;</span>;</span><br><span class="line">    <span class="type">int</span> iResult;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接收数据</span></span><br><span class="line">    iResult = recv(sd, buffer, BUFSIZE, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (iResult &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Received: %s\n&quot;</span>, buffer);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (iResult == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Connection closing...\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        perror(<span class="string">&quot;recv failed&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送数据</span></span><br><span class="line">    send(sd, hello, <span class="built_in">strlen</span>(hello), <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello message sent\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 关闭一个连接</span></span><br><span class="line">BOOL <span class="title function_">CloseConnect</span><span class="params">(SOCKET sd)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (closesocket(sd) == SOCKET_ERROR) &#123;</span><br><span class="line">        perror(<span class="string">&quot;closesocket&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. 服务器主体</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MyTepSerFun</span><span class="params">()</span> &#123;</span><br><span class="line">    SOCKET server_fd = Bind_Listen(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">if</span> (server_fd == INVALID_SOCKET) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        SOCKET client_socket = AcceptConnetion(server_fd);</span><br><span class="line">        <span class="keyword">if</span> (client_socket != INVALID_SOCKET) &#123;</span><br><span class="line">            ClientConFun(client_socket);</span><br><span class="line">            CloseConnect(client_socket);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    closesocket(server_fd);</span><br><span class="line">    WSACleanup();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    MyTepSerFun();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="客户端-2"><a href="#客户端-2" class="headerlink" title="客户端"></a>客户端</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;winsock2.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;ws2_32.lib&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PORT 8080</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFSIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    WSADATA wsaData;</span><br><span class="line">    <span class="type">int</span> iResult;</span><br><span class="line">    SOCKET client_fd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>;</span></span><br><span class="line">    <span class="type">char</span> buffer[BUFSIZE] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *hello = <span class="string">&quot;Hello from client&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化 Winsock</span></span><br><span class="line">    iResult = WSAStartup(MAKEWORD(<span class="number">2</span>, <span class="number">2</span>), &amp;wsaData);</span><br><span class="line">    <span class="keyword">if</span> (iResult != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;WSAStartup failed: %d\n&quot;</span>, iResult);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建socket文件描述符</span></span><br><span class="line">    <span class="keyword">if</span> ((client_fd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>)) == INVALID_SOCKET) &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket failed&quot;</span>);</span><br><span class="line">        WSACleanup();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置服务器地址</span></span><br><span class="line">    serv_addr.sin_family = AF_INET;</span><br><span class="line">    serv_addr.sin_port = htons(PORT);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将IP地址从字符串转换为网络地址</span></span><br><span class="line">    <span class="keyword">if</span> (inet_pton(AF_INET, <span class="string">&quot;127.0.0.1&quot;</span>, &amp;serv_addr.sin_addr) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;inet_pton failed&quot;</span>);</span><br><span class="line">        closesocket(client_fd);</span><br><span class="line">        WSACleanup();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连接到服务器</span></span><br><span class="line">    <span class="keyword">if</span> (connect(client_fd, (<span class="keyword">struct</span> sockaddr *)&amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr)) == SOCKET_ERROR) &#123;</span><br><span class="line">        perror(<span class="string">&quot;connect failed&quot;</span>);</span><br><span class="line">        closesocket(client_fd);</span><br><span class="line">        WSACleanup();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送数据到服务器</span></span><br><span class="line">    send(client_fd, hello, <span class="built_in">strlen</span>(hello), <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello message sent\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接收服务器发送的数据</span></span><br><span class="line">    iResult = recv(client_fd, buffer, BUFSIZE, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (iResult &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Received: %s\n&quot;</span>, buffer);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (iResult == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Connection closed\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        perror(<span class="string">&quot;recv failed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭socket</span></span><br><span class="line">    closesocket(client_fd);</span><br><span class="line">    WSACleanup();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="阻塞式并发连接模式"><a href="#阻塞式并发连接模式" class="headerlink" title="阻塞式并发连接模式"></a>阻塞式并发连接模式</h3><p>1.通过多线程，可以同时服务多个连接，每一个线程处理一个客户端连接</p>
<p>和迭代模式基本相同，只是在于处理客户端连接上，需要用到多线程处理多线程来处理客户端连接，以给予服务端同时处理业务的能力。</p>
<h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><p>主要是针对服务端的代码，所以这里只写服务端</p>
<h5 id="服务端-3"><a href="#服务端-3" class="headerlink" title="服务端"></a>服务端</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;winsock2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;process.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;ws2_32.lib&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PORT 8080</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFSIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程函数，处理客户端连接</span></span><br><span class="line"><span class="type">unsigned</span> __stdcall <span class="title function_">ClientThread</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">    SOCKET client_socket = *(SOCKET *)arg;</span><br><span class="line">    <span class="type">char</span> buffer[BUFSIZE] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *hello = <span class="string">&quot;Hello from server&quot;</span>;</span><br><span class="line">    <span class="type">int</span> iResult;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接收数据</span></span><br><span class="line">    iResult = recv(client_socket, buffer, BUFSIZE, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (iResult &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Received: %s\n&quot;</span>, buffer);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (iResult == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Connection closing...\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        perror(<span class="string">&quot;recv failed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送数据</span></span><br><span class="line">    send(client_socket, hello, <span class="built_in">strlen</span>(hello), <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello message sent\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭连接</span></span><br><span class="line">    closesocket(client_socket);</span><br><span class="line">    <span class="built_in">free</span>(arg);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绑定本地地址和监听</span></span><br><span class="line">SOCKET <span class="title function_">Bind_Listen</span><span class="params">(<span class="type">int</span> nBacklog)</span> &#123;</span><br><span class="line">    WSADATA wsaData;</span><br><span class="line">    <span class="type">int</span> iResult;</span><br><span class="line">    SOCKET server_fd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">address</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化 Winsock</span></span><br><span class="line">    iResult = WSAStartup(MAKEWORD(<span class="number">2</span>, <span class="number">2</span>), &amp;wsaData);</span><br><span class="line">    <span class="keyword">if</span> (iResult != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;WSAStartup failed: %d\n&quot;</span>, iResult);</span><br><span class="line">        <span class="keyword">return</span> INVALID_SOCKET;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建socket文件描述符</span></span><br><span class="line">    <span class="keyword">if</span> ((server_fd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>)) == INVALID_SOCKET) &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket failed&quot;</span>);</span><br><span class="line">        WSACleanup();</span><br><span class="line">        <span class="keyword">return</span> INVALID_SOCKET;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定socket到端口</span></span><br><span class="line">    address.sin_family = AF_INET;</span><br><span class="line">    address.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">    address.sin_port = htons(PORT);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bind(server_fd, (<span class="keyword">struct</span> sockaddr *)&amp;address, <span class="keyword">sizeof</span>(address)) == SOCKET_ERROR) &#123;</span><br><span class="line">        perror(<span class="string">&quot;bind failed&quot;</span>);</span><br><span class="line">        closesocket(server_fd);</span><br><span class="line">        WSACleanup();</span><br><span class="line">        <span class="keyword">return</span> INVALID_SOCKET;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听</span></span><br><span class="line">    <span class="keyword">if</span> (listen(server_fd, nBacklog) == SOCKET_ERROR) &#123;</span><br><span class="line">        perror(<span class="string">&quot;listen&quot;</span>);</span><br><span class="line">        closesocket(server_fd);</span><br><span class="line">        WSACleanup();</span><br><span class="line">        <span class="keyword">return</span> INVALID_SOCKET;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> server_fd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 服务器主体</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MyTepSerFun</span><span class="params">()</span> &#123;</span><br><span class="line">    SOCKET server_fd = Bind_Listen(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">if</span> (server_fd == INVALID_SOCKET) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client_addr</span>;</span></span><br><span class="line">        <span class="type">int</span> addrlen = <span class="keyword">sizeof</span>(client_addr);</span><br><span class="line">        SOCKET *client_socket = (SOCKET *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(SOCKET));</span><br><span class="line">        *client_socket = accept(server_fd, (<span class="keyword">struct</span> sockaddr *)&amp;client_addr, &amp;addrlen);</span><br><span class="line">        <span class="keyword">if</span> (*client_socket == INVALID_SOCKET) &#123;</span><br><span class="line">            perror(<span class="string">&quot;accept&quot;</span>);</span><br><span class="line">            <span class="built_in">free</span>(client_socket);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建线程处理客户端连接</span></span><br><span class="line">        _beginthreadex(<span class="literal">NULL</span>, <span class="number">0</span>, ClientThread, (<span class="type">void</span> *)client_socket, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    closesocket(server_fd);</span><br><span class="line">    WSACleanup();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    MyTepSerFun();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="非阻塞式"><a href="#非阻塞式" class="headerlink" title="非阻塞式"></a>非阻塞式</h2><h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;winsock2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;process.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;ws2_32.lib&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PORT 8080</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFSIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程函数，处理客户端连接</span></span><br><span class="line"><span class="type">unsigned</span> __stdcall <span class="title function_">ClientThread</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">    SOCKET client_socket = *(SOCKET *)arg;</span><br><span class="line">    <span class="type">char</span> buffer[BUFSIZE] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *hello = <span class="string">&quot;Hello from server&quot;</span>;</span><br><span class="line">    <span class="type">int</span> iResult;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置为非阻塞模式</span></span><br><span class="line">    u_long iMode = <span class="number">1</span>;</span><br><span class="line">    iResult = ioctlsocket(client_socket, FIONBIO, &amp;iMode);</span><br><span class="line">    <span class="keyword">if</span> (iResult != NO_ERROR) &#123;</span><br><span class="line">        perror(<span class="string">&quot;ioctlsocket failed&quot;</span>);</span><br><span class="line">        closesocket(client_socket);</span><br><span class="line">        <span class="built_in">free</span>(arg);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 接收数据</span></span><br><span class="line">        iResult = recv(client_socket, buffer, BUFSIZE, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (iResult &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Received: %s\n&quot;</span>, buffer);</span><br><span class="line">            <span class="comment">// 发送数据</span></span><br><span class="line">            send(client_socket, hello, <span class="built_in">strlen</span>(hello), <span class="number">0</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Hello message sent\n&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (iResult == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Connection closing...\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (WSAGetLastError() == WSAEWOULDBLOCK) &#123;</span><br><span class="line">                <span class="comment">// 没有数据可读，继续循环</span></span><br><span class="line">                Sleep(<span class="number">100</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                perror(<span class="string">&quot;recv failed&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭连接</span></span><br><span class="line">    closesocket(client_socket);</span><br><span class="line">    <span class="built_in">free</span>(arg);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绑定本地地址和监听</span></span><br><span class="line">SOCKET <span class="title function_">Bind_Listen</span><span class="params">(<span class="type">int</span> nBacklog)</span> &#123;</span><br><span class="line">    WSADATA wsaData;</span><br><span class="line">    <span class="type">int</span> iResult;</span><br><span class="line">    SOCKET server_fd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">address</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化 Winsock</span></span><br><span class="line">    iResult = WSAStartup(MAKEWORD(<span class="number">2</span>, <span class="number">2</span>), &amp;wsaData);</span><br><span class="line">    <span class="keyword">if</span> (iResult != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;WSAStartup failed: %d\n&quot;</span>, iResult);</span><br><span class="line">        <span class="keyword">return</span> INVALID_SOCKET;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建socket文件描述符</span></span><br><span class="line">    <span class="keyword">if</span> ((server_fd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>)) == INVALID_SOCKET) &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket failed&quot;</span>);</span><br><span class="line">        WSACleanup();</span><br><span class="line">        <span class="keyword">return</span> INVALID_SOCKET;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定socket到端口</span></span><br><span class="line">    address.sin_family = AF_INET;</span><br><span class="line">    address.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">    address.sin_port = htons(PORT);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bind(server_fd, (<span class="keyword">struct</span> sockaddr *)&amp;address, <span class="keyword">sizeof</span>(address)) == SOCKET_ERROR) &#123;</span><br><span class="line">        perror(<span class="string">&quot;bind failed&quot;</span>);</span><br><span class="line">        closesocket(server_fd);</span><br><span class="line">        WSACleanup();</span><br><span class="line">        <span class="keyword">return</span> INVALID_SOCKET;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听</span></span><br><span class="line">    <span class="keyword">if</span> (listen(server_fd, nBacklog) == SOCKET_ERROR) &#123;</span><br><span class="line">        perror(<span class="string">&quot;listen&quot;</span>);</span><br><span class="line">        closesocket(server_fd);</span><br><span class="line">        WSACleanup();</span><br><span class="line">        <span class="keyword">return</span> INVALID_SOCKET;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> server_fd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 服务器主体</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MyTepSerFun</span><span class="params">()</span> &#123;</span><br><span class="line">    SOCKET server_fd = Bind_Listen(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">if</span> (server_fd == INVALID_SOCKET) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client_addr</span>;</span></span><br><span class="line">        <span class="type">int</span> addrlen = <span class="keyword">sizeof</span>(client_addr);</span><br><span class="line">        SOCKET *client_socket = (SOCKET *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(SOCKET));</span><br><span class="line">        *client_socket = accept(server_fd, (<span class="keyword">struct</span> sockaddr *)&amp;client_addr, &amp;addrlen);</span><br><span class="line">        <span class="keyword">if</span> (*client_socket == INVALID_SOCKET) &#123;</span><br><span class="line">            <span class="keyword">if</span> (WSAGetLastError() == WSAEWOULDBLOCK) &#123;</span><br><span class="line">                <span class="comment">// 没有连接请求，继续循环</span></span><br><span class="line">                Sleep(<span class="number">100</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                perror(<span class="string">&quot;accept&quot;</span>);</span><br><span class="line">                <span class="built_in">free</span>(client_socket);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建线程处理客户端连接</span></span><br><span class="line">        _beginthreadex(<span class="literal">NULL</span>, <span class="number">0</span>, ClientThread, (<span class="type">void</span> *)client_socket, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    closesocket(server_fd);</span><br><span class="line">    WSACleanup();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    MyTepSerFun();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Select模型"><a href="#Select模型" class="headerlink" title="Select模型"></a>Select模型</h2><p>Select模型对应的是一个函数</p>
<p>从字面意思理解，<strong>select可从诸多连接中检测出可读的（accpet函数），也就是有响应的连接；也可以从诸多连接中检测出可写的（recv、send函数），也就是可以发送消息的连接。</strong></p>
<img src="/2024/07/05/CInternet/image-20240717223748067.png" alt="image-20240717223748067" style="zoom: 50%;">

<h3 id="select模型逻辑"><a href="#select模型逻辑" class="headerlink" title="select模型逻辑"></a>select模型逻辑</h3><p>select模型逻辑步骤如下：</p>
<ol>
<li>将所有的socket装进一个数组中</li>
<li>通过select函数遍历socket数组，取出有响应（可读、可写）的socket放进另一个数组</li>
<li>对存入有响应的socket数组处理</li>
</ol>
<h3 id="函数和结构体"><a href="#函数和结构体" class="headerlink" title="函数和结构体"></a>函数和结构体</h3><p>Select函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">select</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="type">int</span> nfds, 		<span class="comment">//直接为0</span></span></span><br><span class="line"><span class="params">    fd_set *readfds, <span class="comment">//套接字集合，针对读操作accept, recv</span></span></span><br><span class="line"><span class="params">    fd_set *writefds,<span class="comment">//针对写操作，如connect send等</span></span></span><br><span class="line"><span class="params">    fd_set *exceptfds,<span class="comment">//针对异常</span></span></span><br><span class="line"><span class="params">    <span class="keyword">struct</span> timeval *timeout<span class="comment">//超时设置，为NULL就是一直等</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>

<p>返回值 1，如果超时，返回值 0，出现错误，返回值Socket_ERROR</p>
<p>fd_set结构体</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">fd_set</span>&#123;</span></span><br><span class="line">    u_int fd_count; <span class="comment">/* How many SET */</span></span><br><span class="line">    SOCKET fd_array[FD_SETSIZE]; <span class="comment">/* An array of SOCKETs*/</span></span><br><span class="line">&#125;fd_set;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FDZ_SETSIZE 64</span></span><br></pre></td></tr></table></figure>

<p>因为<code>#define FDZ_SETSIZE 64</code>所以最大不能超过64个，代表着可以并发处理64个套接字</p>
<p>如果想装更多的socket，可以通过在<strong>winsock2.h头文件前声明宏</strong>，给一个更大的值：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> FD_SETSIZE 128</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;WinSock2.h&gt;</span></span></span><br></pre></td></tr></table></figure>

<p><strong>四个操作fd_set的操作宏</strong></p>
<table>
<thead>
<tr>
<th>操作宏</th>
<th>作用</th>
<th>代码</th>
</tr>
</thead>
<tbody><tr>
<td>FD_ZERO</td>
<td>将客户端socket集合清零</td>
<td><code>FD_ZERO(&amp;clientSockets);</code></td>
</tr>
<tr>
<td>FD_SET</td>
<td>添加一个socket(超过默认值大小不再处理)</td>
<td><code>FD_SET(socketListen, &amp;clientSockets);</code></td>
</tr>
<tr>
<td>FD_CLR</td>
<td>从集合中删除指定的socket一定要close，手动释放</td>
<td><code>FD_CLR(socketListen,&amp;clientSockets);</code><br><code>closesocket(socketListen);</code></td>
</tr>
<tr>
<td>FD_ISSET</td>
<td>查询socket是否在集合中，不存在返回0，存在返回非0</td>
<td><code>FD_ISSET(socketListen, &amp;clientSockets);</code></td>
</tr>
</tbody></table>
<p>getsockopt函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">getsockopt</span><span class="params">(</span></span><br><span class="line"><span class="params">    SOCKET s;<span class="comment">//套接字</span></span></span><br><span class="line"><span class="params">    <span class="type">int</span> level;<span class="comment">//选顶的等级包括SOL_SOCKET IPPROTO_TCP</span></span></span><br><span class="line"><span class="params">    <span class="type">int</span> optname;<span class="comment">//SOCKET选顶的名称SO_ERROR SO_ACCEPTCONN</span></span></span><br><span class="line"><span class="params">    <span class="type">char</span> FAR *optval;<span class="comment">//用于接收的缓冲区</span></span></span><br><span class="line"><span class="params">    <span class="type">int</span> FAR *optlen <span class="comment">//大小</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>

<p>成功返回0；失败返回SOCKET_ERROR</p>
<h3 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 0. 初始化</span></span><br><span class="line">    WORD wsVersion = MAKEWORD(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">    WSADATA wsaData = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    WSAStartup(wsVersion, &amp;wsaData);</span><br><span class="line">    <span class="comment">// 1. 创建套接字</span></span><br><span class="line">    SOCKET sSocket = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (SOCKET_ERROR == sSocket) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;套接字闯创建失败!\n&quot;</span> );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;套接字闯创建成功!\n&quot;</span> );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2. 绑定套接字</span></span><br><span class="line">    sockaddr_in sockAddrInfo = &#123;<span class="number">0</span>&#125;;    <span class="comment">// 初始化</span></span><br><span class="line">    sockAddrInfo.sin_addr.S_un.S_addr = inet_addr(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">    sockAddrInfo.sin_port = htons(<span class="number">2118</span>); <span class="comment">// 端口</span></span><br><span class="line">    sockAddrInfo.sin_family = AF_INET; <span class="comment">// 地址族规范</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> bRes = bind(sSocket, (sockaddr*)&amp;sockAddrInfo, <span class="keyword">sizeof</span>(sockAddrInfo));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (SOCKET_ERROR == bRes) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;绑定失败!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;绑定成功!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3. 监听套接字</span></span><br><span class="line">    <span class="type">int</span> lRes = listen(sSocket, <span class="number">5</span>);</span><br><span class="line">    <span class="keyword">if</span> (SOCKET_ERROR == lRes) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;监听失败!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;监听成功!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fd_set fdSocket; <span class="comment">// 定义</span></span><br><span class="line">    FD_ZERO(&amp;fdSocket); <span class="comment">// 初始化</span></span><br><span class="line">    FD_SET(sSocket, &amp;fdSocket); <span class="comment">// 将当前服务器创建的socket放入集合中</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        fd_set readfds = fdSocket; <span class="comment">// 定义可读的集合</span></span><br><span class="line">        fd_set writefds = fdSocket; <span class="comment">// 定义可写的集合</span></span><br><span class="line">        <span class="comment">// fd_set exceptfds = fdSocket;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取select函数的返回值</span></span><br><span class="line">        <span class="type">int</span> iRes = select(<span class="number">0</span>, &amp;readfds, &amp;writefds, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="comment">// 如果返回值大于0则说明不存在无响应、错误的情况，继续向下</span></span><br><span class="line">        <span class="keyword">if</span> (iRes &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 遍历可写集合，给每个socket发送Hello</span></span><br><span class="line">            <span class="keyword">for</span> (u_int i = <span class="number">0</span>; i &lt; writefds.fd_count; i++) &#123;</span><br><span class="line">                send(readfds.fd_array[i], <span class="string">&quot;Hello&quot;</span>, <span class="number">6</span>, <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 遍历可读集合</span></span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; readfds.fd_count; i++) &#123;</span><br><span class="line">                <span class="comment">// 如果socket为当前服务器创建的scoket则进入accept等待消息</span></span><br><span class="line">                <span class="keyword">if</span> (readfds.fd_array[i] == sSocket) &#123;</span><br><span class="line">                    sockaddr_in s = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">                    <span class="type">int</span> l = <span class="keyword">sizeof</span>(s);</span><br><span class="line">                    SOCKET aSocket = accept(sSocket, (sockaddr*)&amp;s, &amp;l);</span><br><span class="line">                    <span class="keyword">if</span> (INVALID_SOCKET == aSocket)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    FD_SET(aSocket, &amp;fdSocket);</span><br><span class="line">                    <span class="comment">// inet_ntoa获取IP</span></span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;Accpet Client IP: %s \n&quot;</span>, inet_ntoa(s.sin_addr));</span><br><span class="line">                    <span class="comment">// 如果不是，则进入接收消息</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="type">char</span> buf[<span class="number">100</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">                    <span class="type">int</span> iRecv = recv(readfds.fd_array[i], buf, <span class="keyword">sizeof</span>(buf), <span class="number">0</span>);</span><br><span class="line">                    <span class="comment">// 判断接收消息的返回值，大于0则表示接收成功。</span></span><br><span class="line">                    <span class="keyword">if</span> (iRecv &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;Recv: %s \n&quot;</span>, buf);</span><br><span class="line">                        <span class="comment">// 否则就关闭连接、关闭套接字</span></span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        SOCKET tSocket = readfds.fd_array[i];</span><br><span class="line">                        FD_CLR(tSocket, &amp;fdSocket);</span><br><span class="line">                        shutdown(tSocket, SD_BOTH);</span><br><span class="line">                        closesocket(tSocket);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    closesocket(sSocket);</span><br><span class="line"></span><br><span class="line">    WSACleanup();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="WSAAsyncSelect模型"><a href="#WSAAsyncSelect模型" class="headerlink" title="WSAAsyncSelect模型"></a>WSAAsyncSelect模型</h2><p>WSAAsyncSelect模式允许以windows消息的形式接收网络事件通知。这个模式是为了适应windows消息驱动环境而设置的，对性能要求不高的网络应用程序可采用此模式。</p>
<p>优缺点：WSAAsyncSelect模型最突出的特点是<strong>与windows的消息驱动机制融在了一起</strong>，这使得<strong>开发带GUI界面的网络程序</strong>变得很简单。但是如果连接增加，单个WINDOWS函数处理上千个客户请求时，服务器性能势必发受到影响。</p>
<p>WSAAsyncSelect()函数自动把套接字设为非阻塞模式，并且为套接字绑定一个窗口句柄，当有网络事件发生时，便向这个窗口发送消息。</p>
<p>语法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> WSAAPI <span class="title">WSAAsyncSelect</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    [in] SOCKET s, 		<span class="comment">//标识需要事件通知的套接字的描述符</span></span></span></span><br><span class="line"><span class="params"><span class="function">    [in] HWND   hWnd,	<span class="comment">//标识在发生网络事件时接收消息的窗口的句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">    [in] u_int  wMsg,	<span class="comment">//发生网络事件时要接收的消息</span></span></span></span><br><span class="line"><span class="params"><span class="function">    [in] <span class="type">long</span>   lEvent	<span class="comment">//位掩码，指定应用程序感兴趣的网络事件的组合</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>  <strong>lEvent</strong>参数:</p>
<table>
<thead>
<tr>
<th>值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>FD_READ</td>
<td>欲接收 读准备好 的通知.</td>
</tr>
<tr>
<td>FD_WRITE</td>
<td>欲接收 写准备好 的通知.</td>
</tr>
<tr>
<td>FD_OOB</td>
<td>欲接收 带边数据到达 的通知.</td>
</tr>
<tr>
<td>FD_ACCEPT</td>
<td>欲接收 将要连接 的通知.</td>
</tr>
<tr>
<td>FD_CONNECT</td>
<td>欲接收 已连接好 的通知.</td>
</tr>
<tr>
<td>FD_CLOSE</td>
<td>欲接收 套接口关闭 的通知.</td>
</tr>
</tbody></table>
<h3 id="服务端示例"><a href="#服务端示例" class="headerlink" title="服务端示例"></a>服务端示例</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;winsock2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;ws2_32.lib&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PORT 8080  <span class="comment">// 定义服务器监听的端口号</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WM_SOCKET WM_USER + 1  <span class="comment">// 定义自定义消息，用于处理socket事件</span></span></span><br><span class="line"></span><br><span class="line">LRESULT CALLBACK <span class="title function_">WndProc</span><span class="params">(HWND, UINT, WPARAM, LPARAM)</span>;  <span class="comment">// 声明窗口过程函数</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> WINAPI <span class="title function_">WinMain</span><span class="params">(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, <span class="type">int</span> nCmdShow)</span> &#123;</span><br><span class="line">    WNDCLASSEX wcex;</span><br><span class="line">    HWND hwnd;</span><br><span class="line">    MSG msg;</span><br><span class="line">    SOCKET server_fd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">address</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化 Winsock</span></span><br><span class="line">    WSADATA wsaData;</span><br><span class="line">    <span class="type">int</span> iResult = WSAStartup(MAKEWORD(<span class="number">2</span>, <span class="number">2</span>), &amp;wsaData);</span><br><span class="line">    <span class="keyword">if</span> (iResult != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;WSAStartup failed: %d\n&quot;</span>, iResult);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册窗口类</span></span><br><span class="line">    wcex.cbSize = <span class="keyword">sizeof</span>(WNDCLASSEX);</span><br><span class="line">    wcex.style = CS_HREDRAW | CS_VREDRAW;</span><br><span class="line">    wcex.lpfnWndProc = WndProc;</span><br><span class="line">    wcex.cbClsExtra = <span class="number">0</span>;</span><br><span class="line">    wcex.cbWndExtra = <span class="number">0</span>;</span><br><span class="line">    wcex.hInstance = hInstance;</span><br><span class="line">    wcex.hIcon = LoadIcon(<span class="literal">NULL</span>, IDI_APPLICATION);</span><br><span class="line">    wcex.hCursor = LoadCursor(<span class="literal">NULL</span>, IDC_ARROW);</span><br><span class="line">    wcex.hbrBackground = (HBRUSH)(COLOR_WINDOW + <span class="number">1</span>);</span><br><span class="line">    wcex.lpszMenuName = <span class="literal">NULL</span>;</span><br><span class="line">    wcex.lpszClassName = <span class="string">&quot;WSAAsyncSelectExample&quot;</span>;</span><br><span class="line">    wcex.hIconSm = LoadIcon(<span class="literal">NULL</span>, IDI_APPLICATION);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!RegisterClassEx(&amp;wcex)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;RegisterClassEx failed: %d\n&quot;</span>, GetLastError());</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建窗口</span></span><br><span class="line">    hwnd = CreateWindow(<span class="string">&quot;WSAAsyncSelectExample&quot;</span>, <span class="string">&quot;WSAAsyncSelect Example&quot;</span>, WS_OVERLAPPEDWINDOW,</span><br><span class="line">                        CW_USEDEFAULT, <span class="number">0</span>, CW_USEDEFAULT, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, hInstance, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!hwnd) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;CreateWindow failed: %d\n&quot;</span>, GetLastError());</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ShowWindow(hwnd, nCmdShow);</span><br><span class="line">    UpdateWindow(hwnd);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建socket</span></span><br><span class="line">    <span class="keyword">if</span> ((server_fd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>)) == INVALID_SOCKET) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;socket failed: %d\n&quot;</span>, WSAGetLastError());</span><br><span class="line">        WSACleanup();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定socket</span></span><br><span class="line">    address.sin_family = AF_INET;</span><br><span class="line">    address.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">    address.sin_port = htons(PORT);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bind(server_fd, (<span class="keyword">struct</span> sockaddr *)&amp;address, <span class="keyword">sizeof</span>(address)) == SOCKET_ERROR) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;bind failed: %d\n&quot;</span>, WSAGetLastError());</span><br><span class="line">        closesocket(server_fd);</span><br><span class="line">        WSACleanup();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听</span></span><br><span class="line">    <span class="keyword">if</span> (listen(server_fd, <span class="number">3</span>) == SOCKET_ERROR) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;listen failed: %d\n&quot;</span>, WSAGetLastError());</span><br><span class="line">        closesocket(server_fd);</span><br><span class="line">        WSACleanup();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置WSAAsyncSelect</span></span><br><span class="line">    <span class="keyword">if</span> (WSAAsyncSelect(server_fd, hwnd, WM_SOCKET, FD_ACCEPT | FD_READ | FD_CLOSE) == SOCKET_ERROR) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;WSAAsyncSelect failed: %d\n&quot;</span>, WSAGetLastError());</span><br><span class="line">        closesocket(server_fd);</span><br><span class="line">        WSACleanup();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 消息循环</span></span><br><span class="line">    <span class="keyword">while</span> (GetMessage(&amp;msg, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">0</span>)) &#123;</span><br><span class="line">        TranslateMessage(&amp;msg);</span><br><span class="line">        DispatchMessage(&amp;msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    closesocket(server_fd);</span><br><span class="line">    WSACleanup();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (<span class="type">int</span>)msg.wParam;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LRESULT CALLBACK <span class="title function_">WndProc</span><span class="params">(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)</span> &#123;</span><br><span class="line">    SOCKET client_fd;</span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">1024</span>];</span><br><span class="line">    <span class="type">int</span> iResult;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (msg) &#123;</span><br><span class="line">        <span class="keyword">case</span> WM_SOCKET:</span><br><span class="line">            <span class="keyword">if</span> (WSAGETSELECTERROR(lParam)) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Socket error: %d\n&quot;</span>, WSAGETSELECTERROR(lParam));</span><br><span class="line">                closesocket((SOCKET)wParam);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">switch</span> (WSAGETSELECTEVENT(lParam)) &#123;</span><br><span class="line">                <span class="keyword">case</span> FD_ACCEPT:</span><br><span class="line">                    <span class="comment">// 接受新连接</span></span><br><span class="line">                    client_fd = accept((SOCKET)wParam, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">                    <span class="keyword">if</span> (client_fd == INVALID_SOCKET) &#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;accept failed: %d\n&quot;</span>, WSAGetLastError());</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// 为新连接的socket设置WSAAsyncSelect</span></span><br><span class="line">                        <span class="keyword">if</span> (WSAAsyncSelect(client_fd, hwnd, WM_SOCKET, FD_READ | FD_CLOSE) == SOCKET_ERROR) &#123;</span><br><span class="line">                            <span class="built_in">printf</span>(<span class="string">&quot;WSAAsyncSelect failed: %d\n&quot;</span>, WSAGetLastError());</span><br><span class="line">                            closesocket(client_fd);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> FD_READ:</span><br><span class="line">                    <span class="comment">// 读取数据</span></span><br><span class="line">                    iResult = recv((SOCKET)wParam, buffer, <span class="keyword">sizeof</span>(buffer), <span class="number">0</span>);</span><br><span class="line">                    <span class="keyword">if</span> (iResult &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        buffer[iResult] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;Received: %s\n&quot;</span>, buffer);</span><br><span class="line">                        send((SOCKET)wParam, buffer, iResult, <span class="number">0</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (iResult == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;Connection closed\n&quot;</span>);</span><br><span class="line">                        closesocket((SOCKET)wParam);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;recv failed: %d\n&quot;</span>, WSAGetLastError());</span><br><span class="line">                        closesocket((SOCKET)wParam);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> FD_CLOSE:</span><br><span class="line">                    <span class="comment">// 连接关闭</span></span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;Connection closed\n&quot;</span>);</span><br><span class="line">                    closesocket((SOCKET)wParam);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> WM_DESTROY:</span><br><span class="line">            <span class="comment">// 窗口关闭消息</span></span><br><span class="line">            PostQuitMessage(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> DefWindowProc(hwnd, msg, wParam, lParam);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>Cpp</tag>
        <tag>Internet Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>Win32API</title>
    <url>/2024/07/05/Win32API/</url>
    <content><![CDATA[<h1 id="Win32API"><a href="#Win32API" class="headerlink" title="Win32API"></a>Win32API</h1><span id="more"></span>

<h2 id="字符编码"><a href="#字符编码" class="headerlink" title="字符编码"></a>字符编码</h2><h3 id="ASCII-码表"><a href="#ASCII-码表" class="headerlink" title="ASCII 码表"></a>ASCII 码表</h3><table>
<thead>
<tr>
<th><strong>ASCII值</strong></th>
<th><strong>控制字符</strong></th>
<th><strong>ASCII值</strong></th>
<th><strong>控制字符</strong></th>
<th><strong>ASCII值</strong></th>
<th><strong>控制字符</strong></th>
<th><strong>ASCII值</strong></th>
<th><strong>控制字符</strong></th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>NUL</td>
<td>32</td>
<td>(space)</td>
<td>64</td>
<td>@</td>
<td>96</td>
<td>、</td>
</tr>
<tr>
<td>1</td>
<td>SOH</td>
<td>33</td>
<td>！</td>
<td>65</td>
<td>A</td>
<td>97</td>
<td>a</td>
</tr>
<tr>
<td>2</td>
<td>STX</td>
<td>34</td>
<td>”</td>
<td>66</td>
<td>B</td>
<td>98</td>
<td>b</td>
</tr>
<tr>
<td>3</td>
<td>ETX</td>
<td>35</td>
<td>#</td>
<td>67</td>
<td>C</td>
<td>99</td>
<td>c</td>
</tr>
<tr>
<td>4</td>
<td>EOT</td>
<td>36</td>
<td>$</td>
<td>68</td>
<td>D</td>
<td>100</td>
<td>d</td>
</tr>
<tr>
<td>5</td>
<td>ENQ</td>
<td>37</td>
<td>%</td>
<td>69</td>
<td>E</td>
<td>101</td>
<td>e</td>
</tr>
<tr>
<td>6</td>
<td>ACK</td>
<td>38</td>
<td>&amp;</td>
<td>70</td>
<td>F</td>
<td>102</td>
<td>f</td>
</tr>
<tr>
<td>7</td>
<td>BEL</td>
<td>39</td>
<td>‘</td>
<td>71</td>
<td>G</td>
<td>103</td>
<td>g</td>
</tr>
<tr>
<td>8</td>
<td>BS</td>
<td>40</td>
<td>(</td>
<td>72</td>
<td>H</td>
<td>104</td>
<td>h</td>
</tr>
<tr>
<td>9</td>
<td>HT</td>
<td>41</td>
<td>)</td>
<td>73</td>
<td>I</td>
<td>105</td>
<td>i</td>
</tr>
<tr>
<td>10</td>
<td>LF</td>
<td>42</td>
<td>*</td>
<td>74</td>
<td>J</td>
<td>106</td>
<td>j</td>
</tr>
<tr>
<td>11</td>
<td>VT</td>
<td>43</td>
<td>+</td>
<td>75</td>
<td>K</td>
<td>107</td>
<td>k</td>
</tr>
<tr>
<td>12</td>
<td>FF</td>
<td>44</td>
<td>,</td>
<td>76</td>
<td>L</td>
<td>108</td>
<td>l</td>
</tr>
<tr>
<td>13</td>
<td>CR</td>
<td>45</td>
<td>-</td>
<td>77</td>
<td>M</td>
<td>109</td>
<td>m</td>
</tr>
<tr>
<td>14</td>
<td>SO</td>
<td>46</td>
<td>.</td>
<td>78</td>
<td>N</td>
<td>110</td>
<td>n</td>
</tr>
<tr>
<td>15</td>
<td>SI</td>
<td>47</td>
<td>&#x2F;</td>
<td>79</td>
<td>O</td>
<td>111</td>
<td>o</td>
</tr>
<tr>
<td>16</td>
<td>DLE</td>
<td>48</td>
<td>0</td>
<td>80</td>
<td>P</td>
<td>112</td>
<td>p</td>
</tr>
<tr>
<td>17</td>
<td>DCI</td>
<td>49</td>
<td>1</td>
<td>81</td>
<td>Q</td>
<td>113</td>
<td>q</td>
</tr>
<tr>
<td>18</td>
<td>DC2</td>
<td>50</td>
<td>2</td>
<td>82</td>
<td>R</td>
<td>114</td>
<td>r</td>
</tr>
<tr>
<td>19</td>
<td>DC3</td>
<td>51</td>
<td>3</td>
<td>83</td>
<td>X</td>
<td>115</td>
<td>s</td>
</tr>
<tr>
<td>20</td>
<td>DC4</td>
<td>52</td>
<td>4</td>
<td>84</td>
<td>T</td>
<td>116</td>
<td>t</td>
</tr>
<tr>
<td>21</td>
<td>NAK</td>
<td>53</td>
<td>5</td>
<td>85</td>
<td>U</td>
<td>117</td>
<td>u</td>
</tr>
<tr>
<td>22</td>
<td>SYN</td>
<td>54</td>
<td>6</td>
<td>86</td>
<td>V</td>
<td>118</td>
<td>v</td>
</tr>
<tr>
<td>23</td>
<td>TB</td>
<td>55</td>
<td>7</td>
<td>87</td>
<td>W</td>
<td>119</td>
<td>w</td>
</tr>
<tr>
<td>24</td>
<td>CAN</td>
<td>56</td>
<td>8</td>
<td>88</td>
<td>X</td>
<td>120</td>
<td>x</td>
</tr>
<tr>
<td>25</td>
<td>EM</td>
<td>57</td>
<td>9</td>
<td>89</td>
<td>Y</td>
<td>121</td>
<td>y</td>
</tr>
<tr>
<td>26</td>
<td>SUB</td>
<td>58</td>
<td>:</td>
<td>90</td>
<td>Z</td>
<td>122</td>
<td>z</td>
</tr>
<tr>
<td>27</td>
<td>ESC</td>
<td>59</td>
<td>;</td>
<td>91</td>
<td>[</td>
<td>123</td>
<td>{</td>
</tr>
<tr>
<td>28</td>
<td>FS</td>
<td>60</td>
<td>&lt;</td>
<td>92</td>
<td>\</td>
<td>124</td>
<td>|</td>
</tr>
<tr>
<td>29</td>
<td>GS</td>
<td>61</td>
<td>&#x3D;</td>
<td>93</td>
<td>]</td>
<td>125</td>
<td>}</td>
</tr>
<tr>
<td>30</td>
<td>RS</td>
<td>62</td>
<td>&gt;</td>
<td>94</td>
<td>^</td>
<td>126</td>
<td>~</td>
</tr>
<tr>
<td>31</td>
<td>US</td>
<td>63</td>
<td>?</td>
<td>95</td>
<td>—</td>
<td>127</td>
<td>DEL</td>
</tr>
</tbody></table>
<h3 id="ASCII扩展码表"><a href="#ASCII扩展码表" class="headerlink" title="ASCII扩展码表"></a>ASCII扩展码表</h3><table>
<thead>
<tr>
<th><strong>十进制</strong></th>
<th><strong>十六进制</strong></th>
<th><strong>字符</strong></th>
<th><strong>十进制</strong></th>
<th><strong>十六进制</strong></th>
<th><strong>字符</strong></th>
</tr>
</thead>
<tbody><tr>
<td>128</td>
<td>80</td>
<td>Ç</td>
<td>192</td>
<td>C0</td>
<td>└</td>
</tr>
<tr>
<td>129</td>
<td>81</td>
<td>ü</td>
<td>193</td>
<td>C1</td>
<td>┴</td>
</tr>
<tr>
<td>130</td>
<td>82</td>
<td>é</td>
<td>194</td>
<td>C2</td>
<td>┬</td>
</tr>
<tr>
<td>131</td>
<td>83</td>
<td>â</td>
<td>195</td>
<td>C3</td>
<td>├</td>
</tr>
<tr>
<td>132</td>
<td>84</td>
<td>ä</td>
<td>196</td>
<td>C4</td>
<td>─</td>
</tr>
<tr>
<td>133</td>
<td>85</td>
<td>à</td>
<td>197</td>
<td>C5</td>
<td>┼</td>
</tr>
<tr>
<td>134</td>
<td>86</td>
<td>å</td>
<td>198</td>
<td>C6</td>
<td>╞</td>
</tr>
<tr>
<td>135</td>
<td>87</td>
<td>ç</td>
<td>199</td>
<td>C7</td>
<td>╟</td>
</tr>
<tr>
<td>136</td>
<td>88</td>
<td>ê</td>
<td>200</td>
<td>C8</td>
<td>╚</td>
</tr>
<tr>
<td>137</td>
<td>89</td>
<td>ë</td>
<td>201</td>
<td>C9</td>
<td>╔</td>
</tr>
<tr>
<td>138</td>
<td>8A</td>
<td>è</td>
<td>202</td>
<td>CA</td>
<td>╩</td>
</tr>
<tr>
<td>139</td>
<td>8B</td>
<td>ï</td>
<td>203</td>
<td>CB</td>
<td>╦</td>
</tr>
<tr>
<td>140</td>
<td>8C</td>
<td>î</td>
<td>204</td>
<td>CC</td>
<td>╠</td>
</tr>
<tr>
<td>141</td>
<td>8D</td>
<td>ì</td>
<td>205</td>
<td>CD</td>
<td>═</td>
</tr>
<tr>
<td>142</td>
<td>8E</td>
<td>Ä</td>
<td>206</td>
<td>CE</td>
<td>╬</td>
</tr>
<tr>
<td>143</td>
<td>8F</td>
<td>Å</td>
<td>207</td>
<td>CF</td>
<td>╧</td>
</tr>
<tr>
<td>144</td>
<td>90</td>
<td>É</td>
<td>208</td>
<td>D0</td>
<td>╨</td>
</tr>
<tr>
<td>145</td>
<td>91</td>
<td>æ</td>
<td>209</td>
<td>D1</td>
<td>╤</td>
</tr>
<tr>
<td>146</td>
<td>92</td>
<td>Æ</td>
<td>210</td>
<td>D2</td>
<td>╥</td>
</tr>
<tr>
<td>147</td>
<td>93</td>
<td>ô</td>
<td>211</td>
<td>D3</td>
<td>╙</td>
</tr>
<tr>
<td>148</td>
<td>94</td>
<td>ö</td>
<td>212</td>
<td>D4</td>
<td>Ô</td>
</tr>
<tr>
<td>149</td>
<td>95</td>
<td>ò</td>
<td>213</td>
<td>D5</td>
<td>╒</td>
</tr>
<tr>
<td>150</td>
<td>96</td>
<td>û</td>
<td>214</td>
<td>D6</td>
<td>╓</td>
</tr>
<tr>
<td>151</td>
<td>97</td>
<td>ù</td>
<td>215</td>
<td>D7</td>
<td>╫</td>
</tr>
<tr>
<td>152</td>
<td>98</td>
<td>ÿ</td>
<td>216</td>
<td>D8</td>
<td>╪</td>
</tr>
<tr>
<td>153</td>
<td>99</td>
<td>Ö</td>
<td>217</td>
<td>D9</td>
<td>┘</td>
</tr>
<tr>
<td>154</td>
<td>9A</td>
<td>Ü</td>
<td>218</td>
<td>DA</td>
<td>┌</td>
</tr>
<tr>
<td>155</td>
<td>9B</td>
<td>¢</td>
<td>219</td>
<td>DB</td>
<td>█</td>
</tr>
<tr>
<td>156</td>
<td>9C</td>
<td>£</td>
<td>220</td>
<td>DC</td>
<td>▄</td>
</tr>
<tr>
<td>157</td>
<td>9D</td>
<td>¥</td>
<td>221</td>
<td>DD</td>
<td>▌</td>
</tr>
<tr>
<td>158</td>
<td>9E</td>
<td>?</td>
<td>222</td>
<td>DE</td>
<td>?</td>
</tr>
<tr>
<td>159</td>
<td>9F</td>
<td>ƒ</td>
<td>223</td>
<td>DF</td>
<td>?</td>
</tr>
<tr>
<td>160</td>
<td>A0</td>
<td>á</td>
<td>224</td>
<td>E0</td>
<td>α</td>
</tr>
<tr>
<td>161</td>
<td>A1</td>
<td>í</td>
<td>225</td>
<td>E1</td>
<td>ß</td>
</tr>
<tr>
<td>162</td>
<td>A2</td>
<td>ó</td>
<td>226</td>
<td>E2</td>
<td>Γ</td>
</tr>
<tr>
<td>163</td>
<td>A3</td>
<td>ú</td>
<td>227</td>
<td>E3</td>
<td>π</td>
</tr>
<tr>
<td>164</td>
<td>A4</td>
<td>ñ</td>
<td>228</td>
<td>E4</td>
<td>Σ</td>
</tr>
<tr>
<td>165</td>
<td>A5</td>
<td>Ñ</td>
<td>229</td>
<td>E5</td>
<td>σ</td>
</tr>
<tr>
<td>166</td>
<td>A6</td>
<td>ª</td>
<td>230</td>
<td>E6</td>
<td>µ</td>
</tr>
<tr>
<td>167</td>
<td>A7</td>
<td>º</td>
<td>231</td>
<td>E7</td>
<td>τ</td>
</tr>
<tr>
<td>168</td>
<td>A8</td>
<td>¿</td>
<td>232</td>
<td>E8</td>
<td>Φ</td>
</tr>
<tr>
<td>169</td>
<td>A9</td>
<td>?</td>
<td>233</td>
<td>E9</td>
<td>Θ</td>
</tr>
<tr>
<td>170</td>
<td>AA</td>
<td>¬</td>
<td>234</td>
<td>EA</td>
<td>Ω</td>
</tr>
<tr>
<td>171</td>
<td>AB</td>
<td>½</td>
<td>235</td>
<td>EB</td>
<td>δ</td>
</tr>
<tr>
<td>172</td>
<td>AC</td>
<td>¼</td>
<td>236</td>
<td>EC</td>
<td>∞</td>
</tr>
<tr>
<td>173</td>
<td>AD</td>
<td>¡</td>
<td>237</td>
<td>ED</td>
<td>φ</td>
</tr>
<tr>
<td>174</td>
<td>AE</td>
<td>«</td>
<td>238</td>
<td>EE</td>
<td>ε</td>
</tr>
<tr>
<td>175</td>
<td>AF</td>
<td>»</td>
<td>239</td>
<td>EF</td>
<td>∩</td>
</tr>
<tr>
<td>176</td>
<td>B0</td>
<td>?</td>
<td>240</td>
<td>F0</td>
<td>≡</td>
</tr>
<tr>
<td>177</td>
<td>B1</td>
<td>?</td>
<td>241</td>
<td>F1</td>
<td>±</td>
</tr>
<tr>
<td>178</td>
<td>B2</td>
<td>▓</td>
<td>242</td>
<td>F2</td>
<td>≥</td>
</tr>
<tr>
<td>179</td>
<td>B3</td>
<td>│</td>
<td>243</td>
<td>F3</td>
<td>≤</td>
</tr>
<tr>
<td>180</td>
<td>B4</td>
<td>┤</td>
<td>244</td>
<td>F4</td>
<td>?</td>
</tr>
<tr>
<td>181</td>
<td>B5</td>
<td>╡</td>
<td>245</td>
<td>F5</td>
<td>?</td>
</tr>
<tr>
<td>182</td>
<td>B6</td>
<td>╢</td>
<td>246</td>
<td>F6</td>
<td>÷</td>
</tr>
<tr>
<td>183</td>
<td>B7</td>
<td>╖</td>
<td>247</td>
<td>F7</td>
<td>≈</td>
</tr>
<tr>
<td>184</td>
<td>B8</td>
<td>╕</td>
<td>248</td>
<td>F8</td>
<td>≈</td>
</tr>
<tr>
<td>185</td>
<td>B9</td>
<td>╣</td>
<td>249</td>
<td>F9</td>
<td>?</td>
</tr>
<tr>
<td>186</td>
<td>BA</td>
<td>║</td>
<td>250</td>
<td>FA</td>
<td>·</td>
</tr>
<tr>
<td>187</td>
<td>BB</td>
<td>╗</td>
<td>251</td>
<td>FB</td>
<td>√</td>
</tr>
<tr>
<td>188</td>
<td>BC</td>
<td>╝</td>
<td>252</td>
<td>FC</td>
<td>?</td>
</tr>
<tr>
<td>189</td>
<td>BD</td>
<td>╜</td>
<td>253</td>
<td>FD</td>
<td>²</td>
</tr>
<tr>
<td>190</td>
<td>BE</td>
<td>╛</td>
<td>FE</td>
<td>■</td>
<td></td>
</tr>
<tr>
<td>191</td>
<td>BF</td>
<td>┐</td>
<td>255</td>
<td>FF</td>
<td>ÿ</td>
</tr>
</tbody></table>
<h3 id="Unicode字符集"><a href="#Unicode字符集" class="headerlink" title="Unicode字符集"></a>Unicode字符集</h3><p>UNICODE编码方案，世界上所有的文字符号都能从这张表中找到。Unicode编码范围是0~0x10FFFF，能容纳1114111个字符。</p>
<p>但是Unicode只是一个字符集，它规定了每个字符对应的二进制，但是没有规定如何存储。</p>
<p>Unicode的存储方式有UTF-8和UTF-16</p>
<h4 id="UTF-8"><a href="#UTF-8" class="headerlink" title="UTF-8"></a>UTF-8</h4><p>UTF-8是变长字符编码。</p>
<table>
<thead>
<tr>
<th>Unicode编码（HEX）</th>
<th>UTF-8字节流（BIN）</th>
</tr>
</thead>
<tbody><tr>
<td>000000 - 00007F</td>
<td>0xxxxxxx</td>
</tr>
<tr>
<td>000080 - 0007FF</td>
<td>110xxxxx 10xxxxxx</td>
</tr>
<tr>
<td>000800 - 00FFFF</td>
<td>1110xxxx 10xxxxxx 10xxxxxx</td>
</tr>
<tr>
<td>010000 - 10FFFF</td>
<td>11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</td>
</tr>
</tbody></table>
<h4 id="UTF-16"><a href="#UTF-16" class="headerlink" title="UTF-16"></a>UTF-16</h4><p>UTF-16编码以16位无符号整数为单位，（是以16位为一个单位，不表示一个字符就有16位）。这要看字符的Unicode编码处于什么范围而定，有可能是2个字节，有可能是4个字节。现在机器上的Unicode编码一般指的是UTF-16编码</p>
<h3 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h3><p>BOM，BYTE Order Mark，字符排列标志。</p>
<table>
<thead>
<tr>
<th>编码方式</th>
<th>BOM</th>
</tr>
</thead>
<tbody><tr>
<td>UTF-8</td>
<td>EF BB BF</td>
</tr>
<tr>
<td>UTF-16LE（小端对齐</td>
<td>FF FE</td>
</tr>
<tr>
<td>UTF-16BE（大端对齐</td>
<td>FE FF</td>
</tr>
</tbody></table>
<h3 id="C语言中的宽字符"><a href="#C语言中的宽字符" class="headerlink" title="C语言中的宽字符"></a>C语言中的宽字符</h3><h4 id="宽字符"><a href="#宽字符" class="headerlink" title="宽字符"></a>宽字符</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">wchar_t</span> wch[] = <span class="string">&quot;宽字符&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>打印宽字符：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;locale.h&gt;</span>				<span class="comment">//添加头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	setlocale(LC_ALL, <span class="string">&quot;&quot;</span>);		<span class="comment">// 控制台使用默认编码</span></span><br><span class="line">	<span class="type">wchar_t</span> wch[] = <span class="string">L&quot;宽字符&quot;</span>;</span><br><span class="line">	wprintf(<span class="string">L&quot;%s\n&quot;</span>, wch);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="相关函数"><a href="#相关函数" class="headerlink" title="相关函数"></a>相关函数</h4><table>
<thead>
<tr>
<th>char</th>
<th>wchar_t</th>
<th>多字节字符型 &#x2F; 宽字节字符型</th>
</tr>
</thead>
<tbody><tr>
<td>printf</td>
<td>wprintf</td>
<td>打印到控制台</td>
</tr>
<tr>
<td>strlen</td>
<td>wcslen</td>
<td>获取长度</td>
</tr>
<tr>
<td>strcpy</td>
<td>wcscpy</td>
<td>字符串复制</td>
</tr>
<tr>
<td>strcat</td>
<td>wcscat</td>
<td>字符串拼接</td>
</tr>
<tr>
<td>strcmp</td>
<td>wcscmp</td>
<td>字符串比较</td>
</tr>
<tr>
<td>strstr</td>
<td>wcsstr</td>
<td>字符串查找</td>
</tr>
</tbody></table>
<h3 id="Win32-API中的宽字符"><a href="#Win32-API中的宽字符" class="headerlink" title="Win32 API中的宽字符"></a>Win32 API中的宽字符</h3><h4 id="Win32-API"><a href="#Win32-API" class="headerlink" title="Win32 API"></a>Win32 API</h4><p>API，Application Process Interface应用程序接口，也就是Windows提供的封装好的一些函数</p>
<p>几个重要DLL：</p>
<p>&lt;1&gt;Kernel32.dll最核心的功能模块，比如管理内存、进程和线程相关的函数等。<br>&lt;2&gt;User32.dll是Vindows用户界面相关应用程序接口，如创建窗口和发送消息等。<br>&lt;3&gt;GDl32.dll全称是Graphical Device Interface(图形设备接口)，包含用于画图和显示文本的函数。</p>
<p>在Win32中写代码最好用TCHAR来写，利于跨平台使用</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">CHAR ch[] = <span class="string">&quot;&quot;</span>;				<span class="comment">//char</span></span><br><span class="line">WCHAR wch[] = <span class="string">L&quot;&quot;</span>;			<span class="comment">//wchar_t</span></span><br><span class="line"></span><br><span class="line">TCHAR tch[] = TEXT(<span class="string">&quot;&quot;</span>);		<span class="comment">// 依赖于程序默认的编码，是ASCII就是ASCII，是Unicode就是Unicode</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">指针类型</span><br><span class="line">PSTR pszStr = <span class="string">&quot;&quot;</span>;				<span class="comment">//char*</span></span><br><span class="line">PWSTR pwszStr = <span class="string">L&quot;&quot;</span>;			<span class="comment">//wchar_t*</span></span><br><span class="line"></span><br><span class="line">PTSTR ptszStr = TEXT(<span class="string">&quot;&quot;</span>);		<span class="comment">//兼容</span></span><br></pre></td></tr></table></figure>

<h4 id="MessageBox-API"><a href="#MessageBox-API" class="headerlink" title="MessageBox API"></a>MessageBox API</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">CHAR chTitle[] = <span class="string">&quot;标题&quot;</span>;</span><br><span class="line">CHAR chText[] = <span class="string">&quot;内容&quot;</span>;</span><br><span class="line">MessageBoxA(<span class="number">0</span>,chText,chTitle,MB_YESNO);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">WCHAR wchTitle[] = <span class="string">L&quot;标题&quot;</span>;</span><br><span class="line">WCHAR wchText[] = <span class="string">L&quot;内容&quot;</span>;</span><br><span class="line">MessageBoxW(<span class="number">0</span>,wchText,wchTitle,MB_YESNO);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">TCHAR chTitle[] = TEXT(<span class="string">&quot;标题&quot;</span>);</span><br><span class="line">TCHAR chText[] = TEXT(<span class="string">&quot;内容&quot;</span>);</span><br><span class="line">MessageBox(<span class="number">0</span>,chText,chTitle,MB_YESNO);</span><br></pre></td></tr></table></figure>

<h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><h3 id="进程的创建"><a href="#进程的创建" class="headerlink" title="进程的创建"></a>进程的创建</h3><p>任何进程都是别的进程创建的：由CreateProcess()这个函数创建</p>
<p>进程创建过程</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、映射EXE文件</span><br><span class="line">2、创建内核对象EPROCESS</span><br><span class="line">3、映射系统DLL(ntdll.dll)</span><br><span class="line">4、创建线程内核对象ETHREAD</span><br><span class="line">5、系统启动线程</span><br><span class="line">		映射DLL(ntdl.LdrInitializeThunk)</span><br><span class="line">		线程开始执行</span><br></pre></td></tr></table></figure>

<h3 id="创建进程"><a href="#创建进程" class="headerlink" title="创建进程"></a>创建进程</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">BOOL <span class="title function_">CreateChildProcess</span><span class="params">(PTCHAR szChildProcessName, PTCHAR szCommandLine)</span></span><br><span class="line">&#123;</span><br><span class="line">	STARTUPINFO si;					<span class="comment">// 记录程序有多大</span></span><br><span class="line">	PROCESS_INFORMATION pi;</span><br><span class="line"></span><br><span class="line">	ZeroMemory(&amp;pi, <span class="keyword">sizeof</span>(pi));</span><br><span class="line">	ZeroMemory(&amp;si, <span class="keyword">sizeof</span>(si));</span><br><span class="line">	si.cb = <span class="keyword">sizeof</span>(si);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建子进程，返回成功与失败</span></span><br><span class="line">	<span class="keyword">if</span> (!CreateProcess(</span><br><span class="line">		szChildProcessName,		<span class="comment">// 对象名称</span></span><br><span class="line">		szCommandLine,			<span class="comment">// 命令行</span></span><br><span class="line">		<span class="literal">NULL</span>,					<span class="comment">// 不继承进程句柄</span></span><br><span class="line">		<span class="literal">NULL</span>,					<span class="comment">// 不继承线程句柄</span></span><br><span class="line">		FALSE,					<span class="comment">// 不继承句柄</span></span><br><span class="line">		<span class="number">0</span>,						<span class="comment">// 没有创建标志</span></span><br><span class="line">		<span class="literal">NULL</span>,					<span class="comment">// 使用父进程环境变量</span></span><br><span class="line">		<span class="literal">NULL</span>,					<span class="comment">// 使用父进程目录作为当前目录，可以自己设置目录</span></span><br><span class="line">		&amp;si,					<span class="comment">// STARTUPINFO结构体详细信息</span></span><br><span class="line">		&amp;pi)					<span class="comment">// PROCESS_INFORMATION结构体进程信息</span></span><br><span class="line">		)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;CreatChildProcess Error:%d \n&quot;</span>, GetLastError);</span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	CloseHandle(pi.hProcess);</span><br><span class="line">	CloseHandle(pi.hThread);</span><br><span class="line">	<span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	TCHAR szApplicationName[] = TEXT(<span class="string">&quot;C:\\Program Files (x86)\\Microsoft\\Edge\\Application\\msedge.exe&quot;</span>);</span><br><span class="line">	TCHAR szCmdline[] = TEXT(<span class="string">&quot;https://baidu.com&quot;</span>);</span><br><span class="line">	CreateChildProcess(szApplicationName, <span class="literal">NULL</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="句柄表"><a href="#句柄表" class="headerlink" title="句柄表"></a>句柄表</h3><p>句柄表存储的就是一种映射关系，每个进程的内核对象对应一个句柄，用户不能直接访问内核对象（如果用户给了一个错误的内核地址会蓝屏）。为了防止访问错误的内核对象地址，Windows在用户层和内核层中间加了一个句柄表，用户通过访问句柄表来访问内核对象，句柄表相当于一道内核层外的防火墙。</p>
<img src="/2024/07/05/Win32API/image-20240304202133292.png" alt="image-20240304202133292" style="zoom:67%;">

<p>句柄表是一张私有的表，只针对当前的进程才有意义。</p>
<p><img src="/2024/07/05/Win32API/image-20240304222323428.png" alt="image-20240304222323428"></p>
<p>如果是CloseHandle的话，内核对象不会死，而是内核对象的计数器减一（当有多个对象都运行了内核对象A）。如果所有的进程都把内核对象杀掉，也就是内核对象的计数变成0的时候，这个内核对象就会被销毁。</p>
<p>进程里有线程，线程不死，进程就不会死；如果进程里的唯一线程死了，进程就死了。</p>
<h3 id="进程相关API"><a href="#进程相关API" class="headerlink" title="进程相关API"></a>进程相关API</h3><h4 id="ID与句柄表"><a href="#ID与句柄表" class="headerlink" title="ID与句柄表"></a>ID与句柄表</h4><p>进程ID——PID，使用程序将进程ID打印出来为16进制，比如0x2914，转换成十进制是10516，也就是这里的资源管理器</p>
<img src="/2024/07/05/Win32API/image-20240305100538731.png" alt="image-20240305100538731" style="zoom:50%;">

<p>句柄表</p>
<p>句柄表是一个程序私有的，如果通过另一个程序关掉另一个程序，不能使用被关闭进程的句柄表，因为这个句柄表是私有的，程序A无法通过程序B的句柄表关闭程序B。</p>
<p>比如，程序A的句柄是0xf0,<img src="/2024/07/05/Win32API/image-20240305145458857.png" alt="image-20240305145458857" style="zoom:67%;"></p>
<p>此时如果用程序B来关闭程序A：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	HANDLE hProcess;</span><br><span class="line">	hProcess = (HANDLE)<span class="number">0xf0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!TerminateProcess(hProcess, <span class="number">1</span>))</span><br><span class="line">	&#123;				</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;终止程序失败 %d \n&quot;</span>, GetLastError());		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">终止程序失败：6</span><br></pre></td></tr></table></figure>

<p><img src="/2024/07/05/Win32API/image-20240305150145954.png" alt="image-20240305150145954" style="zoom:33%;"> 返回这个值说明句柄无效，因为0xf0是A的私有句柄</p>
<p>但是，进程ID（dwProcessID）是公有的，所以还是可以通过使用PID来终止程序。</p>
<h3 id="以挂起形式创建进程"><a href="#以挂起形式创建进程" class="headerlink" title="以挂起形式创建进程"></a>以挂起形式创建进程</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">BOOL <span class="title function_">CreateProcess</span><span class="params">(</span></span><br><span class="line"><span class="params">	LPCTSTR lpApplicationName.						<span class="comment">//name of exeutable module</span></span></span><br><span class="line"><span class="params">	LPTSTR lpCommandLine,							<span class="comment">//command line string</span></span></span><br><span class="line"><span class="params">	LPSECURITY_ATTRIBUTES lpProcessAttributes,		<span class="comment">//SD</span></span></span><br><span class="line"><span class="params">	LPSECURITY_ATTRIBUTES lpThreadAttributes,		<span class="comment">//SD</span></span></span><br><span class="line"><span class="params">	BOOL bInheritHandles,							<span class="comment">//handle inheritance option</span></span></span><br><span class="line"><span class="params">	**DWORD dwCreationFlags,**							<span class="comment">//creation flags</span></span></span><br><span class="line"><span class="params">	LPVOID lpEnvironment,							<span class="comment">//new environment block</span></span></span><br><span class="line"><span class="params">	LPCTSTR lpCurrentDirectory,						<span class="comment">//current directory name</span></span></span><br><span class="line"><span class="params">	LPSTARTUPINFO lpStartupInfo,					<span class="comment">//startup information</span></span></span><br><span class="line"><span class="params">	LPPROCESS_INFOMATION lpProcessInformation		<span class="comment">//process information</span></span></span><br><span class="line"><span class="params">)</span></span><br></pre></td></tr></table></figure>

<p>在dwCreationFlags中，如果值为0，那么父进程和子进程是共用一个控制台的，如果要父进程和子进程分别打开一个控制台，那么需要将dwCreationFlags设置为<code>CREATE_NEW_CONSOLE</code>。**其中有一个值为<code>CREATE_SUSPENDED:</code>**以挂起的形式创建一个进程</p>
<h3 id="模块目录与工作目录"><a href="#模块目录与工作目录" class="headerlink" title="模块目录与工作目录"></a>模块目录与工作目录</h3><p>两个API：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">GetModuleFileName		<span class="comment">//获取模块路径</span></span><br><span class="line">GetCurrentDirectory		<span class="comment">//获取工作路径</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span>(disable:6031)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> strModule[<span class="number">256</span>];</span><br><span class="line">	GetModuleFileName(<span class="literal">NULL</span>, strModule, <span class="number">256</span>);</span><br><span class="line"></span><br><span class="line">	<span class="type">char</span> strWork[<span class="number">1000</span>];</span><br><span class="line">	<span class="type">int</span> i = <span class="number">1000</span>;</span><br><span class="line">	GetCurrentDirectory(<span class="number">1000</span>, strWork);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;模块路径：%s\n工作路径：%s\n&quot;</span>, strModule, strWork);</span><br><span class="line"></span><br><span class="line">	getchar();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">模块路径：C:\Users\23394\Desktop\code\C C++\win32AP\Debug\win32AP.exe</span><br><span class="line">工作路径：C:\Users\23394\Desktop\code\C C++\win32AP</span><br></pre></td></tr></table></figure>

<p>模块路径就是exe所在位置，工作路径由创建这个模块的父进程填写</p>
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><h3 id="线程-1"><a href="#线程-1" class="headerlink" title="线程"></a>线程</h3><p>线程是附属在进程上的执行实体，是代码的执行流程</p>
<p>一个进程可以包含多个线程，但一个进程至少包含一个线程</p>
<h3 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h3><p><strong>CreateThread</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">HANDLE <span class="title function_">CreateThread</span><span class="params">(</span></span><br><span class="line"><span class="params">  [in, optional]  LPSECURITY_ATTRIBUTES   lpThreadAttributes,</span></span><br><span class="line"><span class="params">  [in]            SIZE_T                  dwStackSize,</span></span><br><span class="line"><span class="params">  [in]            LPTHREAD_START_ROUTINE  lpStartAddress,</span></span><br><span class="line"><span class="params">  [in, optional]  __drv_aliasesMem LPVOID lpParameter,</span></span><br><span class="line"><span class="params">  [in]            DWORD                   dwCreationFlags,</span></span><br><span class="line"><span class="params">  [out, optional] LPDWORD                 lpThreadId</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>

<p><strong>创建一个线程：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">DWORD WINAPI <span class="title function_">ThreadProc</span><span class="params">(LPVOID lpParameter)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		Sleep(<span class="number">1000</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;++++++++++%d\n&quot;</span>, i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	HANDLE hThread;</span><br><span class="line"></span><br><span class="line">	hThread = CreateThread(<span class="literal">NULL</span>,<span class="number">0</span>, ThreadProc,<span class="literal">NULL</span>,<span class="number">0</span>,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	CloseHandle(hThread);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		Sleep(<span class="number">1000</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;----------%d\n&quot;</span>, i);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中<code>DWORD WINAPI ThreadProc(LPVOID lpParameter)</code>这个函数可以没有返回值和参数，但是在使用时需要强制转换成<code>(LPTHREAD_START_ROUTINE)</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> WINAPI <span class="title function_">ThreadProc</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		Sleep(<span class="number">1000</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;++++++++++%d\n&quot;</span>, i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	HANDLE hThread;</span><br><span class="line"></span><br><span class="line">	hThread = CreateThread(<span class="literal">NULL</span>,<span class="number">0</span>, (LPTHREAD_START_ROUTINE)ThreadProc,<span class="literal">NULL</span>,<span class="number">0</span>,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	CloseHandle(hThread);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		Sleep(<span class="number">1000</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;----------%d\n&quot;</span>, i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>线程也可以传入参数，参数可以是任何类型，只要自己强制转换一个类型即可</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">DWORD WINAPI <span class="title function_">ThreadProc</span><span class="params">(LPVOID lpParameter)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span>* p = (<span class="type">int</span>*)lpParameter;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; *p; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		Sleep(<span class="number">500</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;++++++++++%d\n&quot;</span>, i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	n = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span>* np = &amp;n;</span><br><span class="line"></span><br><span class="line">	HANDLE hThread;</span><br><span class="line">	hThread = CreateThread(<span class="literal">NULL</span>,<span class="number">0</span>, ThreadProc,(LPTHREAD_START_ROUTINE)np, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	CloseHandle(hThread);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		Sleep(<span class="number">1000</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;----------%d\n&quot;</span>, i);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上函数通过闯传入一个int类型指针，先强转成LPTHREAD_START_ROUTINE类型，传入一个指针，再在线程中将这个指针转换成自己需要的类型即可。</p>
<h3 id="线程控制"><a href="#线程控制" class="headerlink" title="线程控制"></a>线程控制</h3><p>让自己停下来<code>Sleep()</code>，停止当前线程。<br>让别的线程停下来<code>SuspendThread(hThread)</code><br>线程恢复<code>ResumeThread</code></p>
<p>线程挂起几次就要继续几次，如果挂起两次，就要继续两次才能继续执行。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">handles</span> &#123;</span></span><br><span class="line">	HANDLE h1;</span><br><span class="line">	HANDLE h2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">DWORD WINAPI <span class="title function_">ThreadProc1</span><span class="params">(LPVOID lpParameter)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span>* p = (<span class="type">int</span>*)lpParameter;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; *p; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		Sleep(<span class="number">500</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;----------%d\n&quot;</span>, i+<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DWORD WINAPI <span class="title function_">ThreadProc2</span><span class="params">(LPVOID lpParameter)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span>* p = (<span class="type">int</span>*)lpParameter;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; *p; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		Sleep(<span class="number">500</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;++++++++++%d\n&quot;</span>, i+<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DWORD WINAPI <span class="title function_">ThreadProc3</span><span class="params">(LPVOID lpParameter)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">handles</span>* <span class="title">hp</span> =</span> (handles*)lpParameter;</span><br><span class="line">	SuspendThread(hp-&gt;h1);</span><br><span class="line">	Sleep(<span class="number">5000</span>);</span><br><span class="line">	ResumeThread(hp-&gt;h1);</span><br><span class="line">	SuspendThread(hp-&gt;h2);</span><br><span class="line">	Sleep(<span class="number">5000</span>);</span><br><span class="line">	ResumeThread(hp-&gt;h2);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	n = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span>* np = &amp;n;</span><br><span class="line"></span><br><span class="line">	HANDLE hThread1;</span><br><span class="line">	hThread1 = CreateThread(<span class="literal">NULL</span>,<span class="number">0</span>, ThreadProc1,(LPTHREAD_START_ROUTINE)np, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> l;</span><br><span class="line">	l = <span class="number">30</span>;</span><br><span class="line">	<span class="type">int</span>* lp = &amp;l;</span><br><span class="line"></span><br><span class="line">	HANDLE hThread2;</span><br><span class="line">	hThread2 = CreateThread(<span class="literal">NULL</span>, <span class="number">0</span>, ThreadProc2, (LPTHREAD_START_ROUTINE)lp, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">handles</span> <span class="title">Handles</span>;</span></span><br><span class="line">	Handles.h1 = hThread1;</span><br><span class="line">	Handles.h2 = hThread2;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">handles</span>* <span class="title">ph</span> =</span> &amp;Handles;</span><br><span class="line"></span><br><span class="line">	HANDLE hThread3;</span><br><span class="line">	hThread3 = CreateThread(<span class="literal">NULL</span>, <span class="number">0</span>, ThreadProc3, (LPTHREAD_START_ROUTINE)ph, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">	Sleep(<span class="number">200000000</span>);</span><br><span class="line"></span><br><span class="line">	CloseHandle(hThread1);</span><br><span class="line">	CloseHandle(hThread2);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上是一个线程交替的实例。</p>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">++++++++++1</span><br><span class="line">++++++++++2</span><br><span class="line">++++++++++3</span><br><span class="line">++++++++++4</span><br><span class="line">++++++++++5</span><br><span class="line">++++++++++6</span><br><span class="line">++++++++++7</span><br><span class="line">++++++++++8</span><br><span class="line">++++++++++9</span><br><span class="line">----------1</span><br><span class="line">----------2</span><br><span class="line">----------3</span><br><span class="line">----------4</span><br><span class="line">----------5</span><br><span class="line">----------6</span><br><span class="line">----------7</span><br><span class="line">----------8</span><br><span class="line">----------9</span><br><span class="line">++++++++++10</span><br><span class="line">----------10</span><br><span class="line">++++++++++11</span><br><span class="line">++++++++++12</span><br><span class="line">++++++++++13</span><br><span class="line">++++++++++14</span><br><span class="line">++++++++++15</span><br><span class="line">++++++++++16</span><br><span class="line">++++++++++17</span><br><span class="line">++++++++++18</span><br><span class="line">++++++++++19</span><br><span class="line">++++++++++20</span><br><span class="line">++++++++++21</span><br><span class="line">++++++++++22</span><br><span class="line">++++++++++23</span><br><span class="line">++++++++++24</span><br><span class="line">++++++++++25</span><br><span class="line">++++++++++26</span><br><span class="line">++++++++++27</span><br><span class="line">++++++++++28</span><br><span class="line">++++++++++29</span><br><span class="line">++++++++++30</span><br></pre></td></tr></table></figure>

<h3 id="等待线程中的API"><a href="#等待线程中的API" class="headerlink" title="等待线程中的API"></a>等待线程中的API</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&lt;<span class="number">1</span>&gt;WaitForSingleObject();</span><br><span class="line">&lt;<span class="number">2</span>&gt;WaitForMultiplePbjects();</span><br><span class="line">&lt;<span class="number">3</span>&gt;GetExitCodeThread();</span><br></pre></td></tr></table></figure>

<h4 id="WaitForSingleObject等待单个线程"><a href="#WaitForSingleObject等待单个线程" class="headerlink" title="WaitForSingleObject等待单个线程"></a>WaitForSingleObject等待单个线程</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">DWORD <span class="title function_">WaitForSingleObject</span><span class="params">(</span></span><br><span class="line"><span class="params">	HANDLE hHandle,			<span class="comment">//handle to object	对象句柄</span></span></span><br><span class="line"><span class="params">	DWORD dwMilliseconds	<span class="comment">//time-out interval 超时时间间隔</span></span></span><br><span class="line"><span class="params">)</span></span><br></pre></td></tr></table></figure>

<p>执行这个函数的时候，这个函数所在的当前线程会阻塞，等待WaitForSingleObject中传入的线程执行完毕后，WaitForSingleObject后面的程序才会执行。</p>
<img src="/2024/07/05/Win32API/image-20240305222427024.png" alt="image-20240305222427024" style="zoom:50%;">

<h4 id="WaitForMultiplePbjects等待多个线程"><a href="#WaitForMultiplePbjects等待多个线程" class="headerlink" title="WaitForMultiplePbjects等待多个线程"></a>WaitForMultiplePbjects等待多个线程</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">DWORD <span class="title function_">WaitForMultipleObjects</span><span class="params">(</span></span><br><span class="line"><span class="params">	DWORD        nCount,			<span class="comment">//等待几个线程对象</span></span></span><br><span class="line"><span class="params">	<span class="type">const</span> HANDLE *lpHandles,		<span class="comment">//线程数组</span></span></span><br><span class="line"><span class="params">	BOOL         bWaitAll,			<span class="comment">//等待模式 TRUE/FALSE前者为全部线程状态都发生改变，后者为有任意一个线程状态发生改变</span></span></span><br><span class="line"><span class="params">	DWORD        dwMilliseconds		<span class="comment">//超时时间，一直等待为INFINITE</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span>(disable:6387)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">DWORD WINAPI <span class="title function_">ThreadProc1</span><span class="params">(LPVOID lpParameter)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span>* p = (<span class="type">int</span>*)lpParameter;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; *p; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		Sleep(<span class="number">25</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;----------%d\n&quot;</span>, i+<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DWORD WINAPI <span class="title function_">ThreadProc2</span><span class="params">(LPVOID lpParameter)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span>* p = (<span class="type">int</span>*)lpParameter;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; *p; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		Sleep(<span class="number">25</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;++++++++++%d\n&quot;</span>, i+<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	n = <span class="number">100</span>;</span><br><span class="line">	<span class="type">int</span>* np = &amp;n;</span><br><span class="line"></span><br><span class="line">	HANDLE harrThreadArray[<span class="number">2</span>];</span><br><span class="line">	harrThreadArray[<span class="number">0</span>] = CreateThread(<span class="literal">NULL</span>, <span class="number">0</span>, ThreadProc1, (LPTHREAD_START_ROUTINE)np, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> l;</span><br><span class="line">	l = <span class="number">50</span>;</span><br><span class="line">	<span class="type">int</span>* lp = &amp;l;</span><br><span class="line"></span><br><span class="line">	harrThreadArray[<span class="number">1</span>] = CreateThread(<span class="literal">NULL</span>, <span class="number">0</span>, ThreadProc2, (LPTHREAD_START_ROUTINE)lp, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//WaitForSingleObject(hThread1,INFINITE);</span></span><br><span class="line">	WaitForMultipleObjects(<span class="number">2</span>, harrThreadArray, TRUE, INFINITE);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;线程执行完毕\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;其他程序...&quot;</span>);</span><br><span class="line"></span><br><span class="line">	CloseHandle(harrThreadArray[<span class="number">0</span>]);</span><br><span class="line">	CloseHandle(harrThreadArray[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="GetExitCodeThread读取线程返回值"><a href="#GetExitCodeThread读取线程返回值" class="headerlink" title="GetExitCodeThread读取线程返回值"></a>GetExitCodeThread读取线程返回值</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">BOOL <span class="title function_">GetExitCodeThread</span><span class="params">(</span></span><br><span class="line"><span class="params">	HANDLE  hThread,</span></span><br><span class="line"><span class="params">	LPDWORD lpExitCode</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span>(disable:6387)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">DWORD WINAPI <span class="title function_">ThreadProc1</span><span class="params">(LPVOID lpParameter)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span>* p = (<span class="type">int</span>*)lpParameter;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; *p; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		Sleep(<span class="number">25</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;----------%d\n&quot;</span>, i+<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DWORD WINAPI <span class="title function_">ThreadProc2</span><span class="params">(LPVOID lpParameter)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span>* p = (<span class="type">int</span>*)lpParameter;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; *p; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		Sleep(<span class="number">25</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;++++++++++%d\n&quot;</span>, i+<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	n = <span class="number">100</span>;</span><br><span class="line">	<span class="type">int</span>* np = &amp;n;</span><br><span class="line"></span><br><span class="line">	HANDLE harrThreadArray[<span class="number">2</span>];</span><br><span class="line">	harrThreadArray[<span class="number">0</span>] = CreateThread(<span class="literal">NULL</span>, <span class="number">0</span>, ThreadProc1, (LPTHREAD_START_ROUTINE)np, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> l;</span><br><span class="line">	l = <span class="number">50</span>;</span><br><span class="line">	<span class="type">int</span>* lp = &amp;l;</span><br><span class="line"></span><br><span class="line">	harrThreadArray[<span class="number">1</span>] = CreateThread(<span class="literal">NULL</span>, <span class="number">0</span>, ThreadProc2, (LPTHREAD_START_ROUTINE)lp, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	DWORD dwResultArray[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">	WaitForMultipleObjects(<span class="number">2</span>, harrThreadArray, TRUE, INFINITE);</span><br><span class="line">	GetExitCodeThread(harrThreadArray[<span class="number">0</span>], &amp;dwResultArray[<span class="number">0</span>]);</span><br><span class="line">	GetExitCodeThread(harrThreadArray[<span class="number">1</span>], &amp;dwResultArray[<span class="number">1</span>]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;线程执行完毕\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;线程1执行完毕返回：%d；线程2执行完毕返回：%d\n&quot;</span>, dwResultArray[<span class="number">0</span>], dwResultArray[<span class="number">1</span>]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;其他程序...&quot;</span>);</span><br><span class="line"></span><br><span class="line">	CloseHandle(harrThreadArray[<span class="number">0</span>]);</span><br><span class="line">	CloseHandle(harrThreadArray[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2024/07/05/Win32API/image-20240305224608996.png" alt="image-20240305224608996" style="zoom:33%;">

<h4 id="CONTEXT线程上下文"><a href="#CONTEXT线程上下文" class="headerlink" title="CONTEXT线程上下文"></a>CONTEXT线程上下文</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DECLSPEC_NOINITALL</span> _<span class="title">CONTEXT</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// The flags values within this flag control the contents of</span></span><br><span class="line">    <span class="comment">// a CONTEXT record.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// If the context record is used as an input parameter, then</span></span><br><span class="line">    <span class="comment">// for each portion of the context record controlled by a flag</span></span><br><span class="line">    <span class="comment">// whose value is set, it is assumed that that portion of the</span></span><br><span class="line">    <span class="comment">// context record contains valid context. If the context record</span></span><br><span class="line">    <span class="comment">// is being used to modify a threads context, then only that</span></span><br><span class="line">    <span class="comment">// portion of the threads context will be modified.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// If the context record is used as an IN OUT parameter to capture</span></span><br><span class="line">    <span class="comment">// the context of a thread, then only those portions of the thread&#x27;s</span></span><br><span class="line">    <span class="comment">// context corresponding to set flags will be returned.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// The context record is never used as an OUT only parameter.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    DWORD ContextFlags;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// This section is specified/returned if CONTEXT_DEBUG_REGISTERS is</span></span><br><span class="line">    <span class="comment">// set in ContextFlags.  Note that CONTEXT_DEBUG_REGISTERS is NOT</span></span><br><span class="line">    <span class="comment">// included in CONTEXT_FULL.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    DWORD   Dr0;</span><br><span class="line">    DWORD   Dr1;</span><br><span class="line">    DWORD   Dr2;</span><br><span class="line">    DWORD   Dr3;</span><br><span class="line">    DWORD   Dr6;</span><br><span class="line">    DWORD   Dr7;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// This section is specified/returned if the</span></span><br><span class="line">    <span class="comment">// ContextFlags word contians the flag CONTEXT_FLOATING_POINT.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    FLOATING_SAVE_AREA FloatSave;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// This section is specified/returned if the</span></span><br><span class="line">    <span class="comment">// ContextFlags word contians the flag CONTEXT_SEGMENTS.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    DWORD   SegGs;</span><br><span class="line">    DWORD   SegFs;</span><br><span class="line">    DWORD   SegEs;</span><br><span class="line">    DWORD   SegDs;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// This section is specified/returned if the</span></span><br><span class="line">    <span class="comment">// ContextFlags word contians the flag CONTEXT_INTEGER.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    DWORD   Edi;</span><br><span class="line">    DWORD   Esi;</span><br><span class="line">    DWORD   Ebx;</span><br><span class="line">    DWORD   Edx;</span><br><span class="line">    DWORD   Ecx;</span><br><span class="line">    DWORD   Eax;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// This section is specified/returned if the</span></span><br><span class="line">    <span class="comment">// ContextFlags word contians the flag CONTEXT_CONTROL.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    DWORD   Ebp;</span><br><span class="line">    DWORD   Eip;</span><br><span class="line">    DWORD   SegCs;              <span class="comment">// MUST BE SANITIZED</span></span><br><span class="line">    DWORD   EFlags;             <span class="comment">// MUST BE SANITIZED</span></span><br><span class="line">    DWORD   Esp;</span><br><span class="line">    DWORD   SegSs;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// This section is specified/returned if the ContextFlags word</span></span><br><span class="line">    <span class="comment">// contains the flag CONTEXT_EXTENDED_REGISTERS.</span></span><br><span class="line">    <span class="comment">// The format and contexts are processor specific</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    BYTE    ExtendedRegisters[MAXIMUM_SUPPORTED_EXTENSION];</span><br><span class="line"></span><br><span class="line">&#125; CONTEXT;</span><br></pre></td></tr></table></figure>

<p>这个结构体中存储了所有的寄存器，这也就是为什么当单核CPU能够循环执行多个线程，因为被挂起的线程会在挂起时将所有寄存器的数据都存在这个结构体中。</p>
<img src="/2024/07/05/Win32API/image-20240305230138707.png" alt="image-20240305230138707" style="zoom:33%;">

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span>(disable:6387)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">DWORD WINAPI <span class="title function_">ThreadProc1</span><span class="params">(LPVOID lpParameter)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span>* p = (<span class="type">int</span>*)lpParameter;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; *p; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		Sleep(<span class="number">25</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;----------%d\n&quot;</span>, i+<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DWORD WINAPI <span class="title function_">ThreadProc2</span><span class="params">(LPVOID lpParameter)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span>* p = (<span class="type">int</span>*)lpParameter;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; *p; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		Sleep(<span class="number">25</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;++++++++++%d\n&quot;</span>, i+<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	n = <span class="number">100</span>;</span><br><span class="line">	<span class="type">int</span>* np = &amp;n;</span><br><span class="line"></span><br><span class="line">	HANDLE harrThreadArray[<span class="number">2</span>];</span><br><span class="line">	harrThreadArray[<span class="number">0</span>] = CreateThread(<span class="literal">NULL</span>, <span class="number">0</span>, ThreadProc1, (LPTHREAD_START_ROUTINE)np, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> l;</span><br><span class="line">	l = <span class="number">50</span>;</span><br><span class="line">	<span class="type">int</span>* lp = &amp;l;</span><br><span class="line"></span><br><span class="line">	harrThreadArray[<span class="number">1</span>] = CreateThread(<span class="literal">NULL</span>, <span class="number">0</span>, ThreadProc2, (LPTHREAD_START_ROUTINE)lp, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	Sleep(<span class="number">100</span>);</span><br><span class="line">	SuspendThread(harrThreadArray[<span class="number">0</span>]);</span><br><span class="line">	CONTEXT context;</span><br><span class="line">	context.ContextFlags = CONTEXT_INTEGER;</span><br><span class="line">	GetThreadContext(harrThreadArray[<span class="number">0</span>], &amp;context);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%x %x\n&quot;</span>, context.Eax, context.Ecx);</span><br><span class="line">	ResumeThread(harrThreadArray[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">	DWORD dwResultArray[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">	WaitForMultipleObjects(<span class="number">2</span>, harrThreadArray, TRUE, INFINITE);</span><br><span class="line">	GetExitCodeThread(harrThreadArray[<span class="number">0</span>], &amp;dwResultArray[<span class="number">0</span>]);</span><br><span class="line">	GetExitCodeThread(harrThreadArray[<span class="number">1</span>], &amp;dwResultArray[<span class="number">1</span>]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;线程执行完毕\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;线程1执行完毕返回：%d；线程2执行完毕返回：%d\n&quot;</span>, dwResultArray[<span class="number">0</span>], dwResultArray[<span class="number">1</span>]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;其他程序...&quot;</span>);</span><br><span class="line"></span><br><span class="line">	CloseHandle(harrThreadArray[<span class="number">0</span>]);</span><br><span class="line">	CloseHandle(harrThreadArray[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="SetThreadContext"><a href="#SetThreadContext" class="headerlink" title="SetThreadContext"></a>SetThreadContext</h4><p>在挂起线程时，还可以使用SetThreadContext改变寄存器中的数值。</p>
<h3 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h3><h4 id="临界资源"><a href="#临界资源" class="headerlink" title="临界资源"></a>临界资源</h4><p>当两个线程同时要访问一个全局变量的时候，可能出现同时访问的情况，导致线程安全受影响。</p>
<h4 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h4><p>一段使用临界资源的代码称为临界区。</p>
<h4 id="线程锁"><a href="#线程锁" class="headerlink" title="线程锁"></a>线程锁</h4><p>Windows实现线程锁的方法：<img src="/2024/07/05/Win32API/image-20240305233145434.png" alt="image-20240305233145434" style="zoom:50%;"></p>
<h4 id="调用API"><a href="#调用API" class="headerlink" title="调用API"></a>调用API</h4><p>临界区之实现线程锁：</p>
<p>&lt;1&gt;创建全局变量</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">CRITICAL_SECTION cs;		<span class="comment">//可以理解成一个令牌</span></span><br></pre></td></tr></table></figure>

<p>&lt;2&gt;初始化全局变量</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">InitializeCriticalSection(&amp;cs);</span><br></pre></td></tr></table></figure>

<p>&lt;3&gt;实现临界区</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">EnterCriticalSection(&amp;cs);		<span class="comment">//进入临界区</span></span><br><span class="line">	<span class="comment">//使用临界资源</span></span><br><span class="line">LeaveCriticalSection(&amp;cs);		<span class="comment">//离开临界区</span></span><br></pre></td></tr></table></figure>

<p>比如这样一段买票的代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> ticket = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">DWORD WINAPI <span class="title function_">ThreadProcess</span><span class="params">(LPVOID lpParameter)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">while</span> (ticket &gt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;还有%d张票	&quot;</span>, ticket);</span><br><span class="line">		ticket--;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;卖出一张，还剩%d张\n&quot;</span>, ticket);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	HANDLE hThreadArr[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">	hThreadArr[<span class="number">0</span>] = CreateThread(<span class="literal">NULL</span>, <span class="number">0</span>, ThreadProcess, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">	hThreadArr[<span class="number">1</span>] = CreateThread(<span class="literal">NULL</span>, <span class="number">0</span>, ThreadProcess, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">	WaitForMultipleObjects(<span class="number">2</span>, hThreadArr, TRUE, INFINITE);</span><br><span class="line">	CloseHandle(hThreadArr[<span class="number">0</span>]);</span><br><span class="line">	CloseHandle(hThreadArr[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有些时候会出现这么个情况</p>
<p><img src="/2024/07/05/Win32API/image-20240305235438634.png" alt="image-20240305235438634"></p>
<p>说明两个线程A在阻塞时线程B停在了它不该停的地方</p>
<p>更改代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">CRITICAL_SECTION cs;</span><br><span class="line"><span class="type">int</span> ticket = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">DWORD WINAPI <span class="title function_">ThreadProcess</span><span class="params">(LPVOID lpParameter)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span>* pt = (<span class="type">int</span>*)lpParameter;</span><br><span class="line"></span><br><span class="line">	EnterCriticalSection(&amp;cs);</span><br><span class="line">	<span class="keyword">while</span> (ticket &gt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Thread:%d	还有%d张票	\n&quot;</span>, *pt, ticket);</span><br><span class="line">		ticket--;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;		卖出一张，还剩%d张\n&quot;</span>, ticket);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;--------------------------\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	LeaveCriticalSection(&amp;cs);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	InitializeCriticalSection(&amp;cs);</span><br><span class="line">	HANDLE hThreadArr[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> ThreadC[<span class="number">2</span>];</span><br><span class="line">	ThreadC[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	ThreadC[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span>* pThread[<span class="number">2</span>];</span><br><span class="line">	pThread[<span class="number">0</span>] = &amp;ThreadC[<span class="number">0</span>];</span><br><span class="line">	pThread[<span class="number">1</span>] = &amp;ThreadC[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">	hThreadArr[<span class="number">0</span>] = CreateThread(<span class="literal">NULL</span>, <span class="number">0</span>, ThreadProcess, (LPTHREAD_START_ROUTINE)pThread[<span class="number">0</span>], <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">	hThreadArr[<span class="number">1</span>] = CreateThread(<span class="literal">NULL</span>, <span class="number">0</span>, ThreadProcess, (LPTHREAD_START_ROUTINE)pThread[<span class="number">1</span>], <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">	WaitForMultipleObjects(<span class="number">2</span>, hThreadArr, TRUE, INFINITE);</span><br><span class="line">	CloseHandle(hThreadArr[<span class="number">0</span>]);</span><br><span class="line">	CloseHandle(hThreadArr[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2024/07/05/Win32API/image-20240306141752501.png" alt="image-20240306141752501" style="zoom:50%;">

<p>当线程1执行时进入临界区，那么线程2就无法访问临界资源，直到线程1离开了临界区（归还令牌）后，线程2才能够访问临界资源，但是当线程2再拿着ticket&#x3D;0进来的时候，已经不满足条件，就直接跳过了。</p>
<h2 id="互斥体"><a href="#互斥体" class="headerlink" title="互斥体"></a>互斥体</h2><h3 id="互斥体-1"><a href="#互斥体-1" class="headerlink" title="互斥体"></a>互斥体</h3><p>内核级临界资源怎么办？</p>
<p>假设A进程的B线程和C进程的D线程，同时使用的是内核级的临界资源（内核对象：线程、文件、进程…）该怎么让这个访问是安全的？使用线程锁的方式明显不行，因为线程锁仅能控制同进程中的多线程。</p>
<img src="/2024/07/05/Win32API/image2021-5-27_16-8-12.png" alt="images/download/attachments/1015833/image2021-5-27_16-8-12.png" style="zoom:50%;">

<p>那么这时候我们就需要一个<strong>能够放在内核中的令牌</strong>来控制，而实现这个作用的，我们称之为<strong>互斥体</strong>。</p>
<img src="/2024/07/05/Win32API/image2021-5-27_16-10-43.png" alt="images/download/attachments/1015833/image2021-5-27_16-10-43.png" style="zoom:50%;">

<h3 id="创建互斥体"><a href="#创建互斥体" class="headerlink" title="创建互斥体"></a>创建互斥体</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">HANDLE <span class="title function_">CreateMutex</span><span class="params">(</span></span><br><span class="line"><span class="params">  LPSECURITY_ATTRIBUTES lpMutexAttributes,  <span class="comment">// SD 安全属性，包含安全描述符</span></span></span><br><span class="line"><span class="params">  BOOL bInitialOwner,                       <span class="comment">// initial owner 是否希望互斥体创建出来就有信号，或者说就可以使用.如果希望的话就为FALSE；官方解释为如果该值为TRUE则表示当前进程拥有该互斥体所有权</span></span></span><br><span class="line"><span class="params">  LPCTSTR lpName                            <span class="comment">// object name 互斥体的名字，随便起，不同程序之间靠这个名字使用互斥体</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>

<p>由线程A创建了一个互斥体：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	HANDLE cm = CreateMutex(<span class="literal">NULL</span>,TRUE,<span class="string">&quot;nMutex&quot;</span>);</span><br><span class="line"></span><br><span class="line">	WaitForSingleObject(cm, INFINITE);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">13</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Process:A Thread:X -&gt;%d++++++++++\n&quot;</span>, i + <span class="number">1</span>);</span><br><span class="line">		Sleep(<span class="number">1000</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ReleaseMutex(cm);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在B进程中使用了这个互斥体：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	HANDLE tMutex = CreateMutex(<span class="literal">NULL</span>, TRUE, <span class="string">L&quot;nMutex&quot;</span>);</span><br><span class="line"></span><br><span class="line">	WaitForSingleObject(tMutex, INFINITE);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">12</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Process:B Thread:Y -&gt;%d----------\n&quot;</span>, i + <span class="number">1</span>);</span><br><span class="line">		Sleep(<span class="number">1000</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这两个不同进程的不同线程通过<code>nMutex</code>这个互斥体名字进行访问。</p>
<p>当进程A启动后再启动进程B：</p>
<img src="/2024/07/05/Win32API/image-20240306152912660.png" alt="image-20240306152912660" style="zoom:30%;">

<p>发现进程A先执行，进程B被阻塞了。</p>
<h3 id="互斥体实现禁止多开"><a href="#互斥体实现禁止多开" class="headerlink" title="互斥体实现禁止多开"></a>互斥体实现禁止多开</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 创建互斥体</span></span><br><span class="line">    HANDLE cm = CreateMutex(<span class="literal">NULL</span>, TRUE, <span class="string">&quot;XYZ&quot;</span>);</span><br><span class="line">    <span class="comment">// 判断互斥体是否创建失败</span></span><br><span class="line">    <span class="keyword">if</span> (cm != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// 判断互斥体是否已经存在，如果存在则表示程序被多次打开</span></span><br><span class="line">        <span class="keyword">if</span> (GetLastError() == ERROR_ALREADY_EXISTS) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;该程序已经开启了，请勿再次开启！&quot;</span>);</span><br><span class="line">            getchar();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 等待互斥体状态发生变化，也就是有信号或为互斥体拥有者，获取令牌</span></span><br><span class="line">            WaitForSingleObject(cm, INFINITE);</span><br><span class="line">            <span class="comment">// 操作资源</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Process: A Thread: B -- %d \n&quot;</span>, i);</span><br><span class="line">                Sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 释放令牌</span></span><br><span class="line">            ReleaseMutex(cm);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;CreateMutex 创建失败! 错误代码: %d\n&quot;</span>, GetLastError());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2024/07/05/Win32API/image-20240306153359061.png" alt="image-20240306153359061"></p>
<p>当已经运行一个程序时，再打开第二个会显示程序已开启。</p>
<h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><h3 id="通知类型"><a href="#通知类型" class="headerlink" title="通知类型"></a>通知类型</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">HANDLE <span class="title function_">CreateEvent</span><span class="params">(</span></span><br><span class="line"><span class="params">  LPSECURITY_ATTRIBUTES lpEventAttributes, <span class="comment">// SD 安全属性，包含安全描述符</span></span></span><br><span class="line"><span class="params">  BOOL bManualReset,                       <span class="comment">// reset type 如果你希望当前事件类型是通知类型则写TRUE，反之FALSE</span></span></span><br><span class="line"><span class="params">  BOOL bInitialState,                      <span class="comment">// initial state 初始状态，决定创建出来时候是否有信号，有为TRUE，没有为FALSE</span></span></span><br><span class="line"><span class="params">  LPCTSTR lpName                           <span class="comment">// object name 事件名字</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="生产者与消费者"><a href="#生产者与消费者" class="headerlink" title="生产者与消费者"></a>生产者与消费者</h3><p>要求：生产者生产一个产品，消费者消耗一个产品。如果不使用通知实现，使用互斥体的话：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">HANDLE hEven;</span><br><span class="line">HANDLE hMutex;</span><br><span class="line"><span class="type">int</span> produce;</span><br><span class="line"></span><br><span class="line">DWORD WINAPI <span class="title function_">ProduceThread</span><span class="params">(LPVOID lpParameter)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span>* pProduceCount = (<span class="type">int</span>*)lpParameter;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; *pProduceCount; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		WaitForSingleObject(hMutex, INFINITE);</span><br><span class="line">		produce = <span class="number">1</span>;	<span class="comment">// 生产了一个产品</span></span><br><span class="line">		<span class="type">long</span> ProduceThreadID = GetCurrentThreadId();</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;生产者%ul生产了一个产品\n&quot;</span>, ProduceThreadID);</span><br><span class="line">		ReleaseMutex(hMutex);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DWORD WINAPI <span class="title function_">ConsumptionThread</span><span class="params">(LPVOID lpParameter)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span>* pProduceCount = (<span class="type">int</span>*)lpParameter;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; *pProduceCount; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		WaitForSingleObject(hMutex, INFINITE);</span><br><span class="line">		produce = <span class="number">0</span>;	<span class="comment">// 生产了一个产品</span></span><br><span class="line">		<span class="type">long</span> ConsumptionThreadID = GetCurrentThreadId();</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;	消费者%ul消费了一个产品\n&quot;</span>, ConsumptionThreadID);</span><br><span class="line">		ReleaseMutex(hMutex);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> produceCount = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span>* pProduce = &amp;produceCount;</span><br><span class="line"></span><br><span class="line">	hMutex = CreateMutex(<span class="literal">NULL</span>, FALSE, <span class="literal">NULL</span>);		<span class="comment">// 创建互斥体,起始状态为阻塞</span></span><br><span class="line"></span><br><span class="line">	HANDLE hPCThread[<span class="number">2</span>];</span><br><span class="line">	hPCThread[<span class="number">0</span>] = CreateThread(<span class="literal">NULL</span>, <span class="number">0</span>, ProduceThread, (LPTHREAD_START_ROUTINE)pProduce, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">	hPCThread[<span class="number">1</span>] = CreateThread(<span class="literal">NULL</span>, <span class="number">0</span>, ConsumptionThread, (LPTHREAD_START_ROUTINE)pProduce, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	WaitForMultipleObjects(<span class="number">2</span>, hPCThread, TRUE, INFINITE);</span><br><span class="line">	CloseHandle(hPCThread[<span class="number">0</span>]);</span><br><span class="line">	CloseHandle(hPCThread[<span class="number">1</span>]);</span><br><span class="line">	CloseHandle(hMutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.先创建一个互斥体</span><br><span class="line">2.创建两个线程</span><br><span class="line">3.在线程中等待互斥体</span><br><span class="line">4.互斥体锁线程后就能实现生产一次，消费一次</span><br><span class="line"></span><br><span class="line">但是，这样生产和消费的顺序可能搞反</span><br></pre></td></tr></table></figure>

<p>出现了先消费、后生产的情况：</p>
<p><img src="/2024/07/05/Win32API/image-20240306163350154.png" alt="image-20240306163350154"></p>
<p>因此可以加条件判断现在有没有产品：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">HANDLE hEven;</span><br><span class="line">HANDLE hMutex;</span><br><span class="line"><span class="type">int</span> produce;</span><br><span class="line"></span><br><span class="line">DWORD WINAPI <span class="title function_">ProduceThread</span><span class="params">(LPVOID lpParameter)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span>* pProduceCount = (<span class="type">int</span>*)lpParameter;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; *pProduceCount; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		WaitForSingleObject(hMutex, INFINITE);</span><br><span class="line">		<span class="keyword">if</span> (produce == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			produce = <span class="number">1</span>;	<span class="comment">// 生产了一个产品</span></span><br><span class="line">			<span class="type">long</span> ProduceThreadID = GetCurrentThreadId();</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;生产者%ld生产了一个产品\n&quot;</span>, ProduceThreadID);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			i--;</span><br><span class="line">		&#125;</span><br><span class="line">		ReleaseMutex(hMutex);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DWORD WINAPI <span class="title function_">ConsumptionThread</span><span class="params">(LPVOID lpParameter)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span>* pProduceCount = (<span class="type">int</span>*)lpParameter;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; *pProduceCount; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		WaitForSingleObject(hMutex, INFINITE);</span><br><span class="line">		<span class="keyword">if</span> (produce == <span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			produce = <span class="number">0</span>;	<span class="comment">// 消费了一个产品</span></span><br><span class="line">			<span class="type">long</span> ConsumptionThreadID = GetCurrentThreadId();</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;	消费者%ul消费了一个产品\n&quot;</span>, ConsumptionThreadID);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			i--;</span><br><span class="line">		&#125;</span><br><span class="line">		ReleaseMutex(hMutex);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> produceCount = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span>* pProduce = &amp;produceCount;</span><br><span class="line"></span><br><span class="line">	hMutex = CreateMutex(<span class="literal">NULL</span>, FALSE, <span class="literal">NULL</span>);		<span class="comment">// 创建互斥体,起始状态为阻塞</span></span><br><span class="line"></span><br><span class="line">	HANDLE hPCThread[<span class="number">2</span>];</span><br><span class="line">	hPCThread[<span class="number">0</span>] = CreateThread(<span class="literal">NULL</span>, <span class="number">0</span>, ProduceThread, (LPTHREAD_START_ROUTINE)pProduce, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">	hPCThread[<span class="number">1</span>] = CreateThread(<span class="literal">NULL</span>, <span class="number">0</span>, ConsumptionThread, (LPTHREAD_START_ROUTINE)pProduce, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	WaitForMultipleObjects(<span class="number">2</span>, hPCThread, TRUE, INFINITE);</span><br><span class="line">	CloseHandle(hPCThread[<span class="number">0</span>]);</span><br><span class="line">	CloseHandle(hPCThread[<span class="number">1</span>]);</span><br><span class="line">	CloseHandle(hMutex);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就可以实现先生产、后消费。</p>
<p>但是，如果在else{i–}这里查看到底浪费了多少次循环：</p>
<p><img src="/2024/07/05/Win32API/image-20240306171259764.png" alt="image-20240306171259764" style="zoom:50%;"><img src="/2024/07/05/Win32API/image-20240306171019818.png" alt="image-20240306171019818" style="zoom:40%;"></p>
<p>输出———的地方就是浪费的时间，占用了计算资源</p>
<h4 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h4><p>所以通过通知来优化这个程序：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 容器</span></span><br><span class="line"><span class="type">int</span> container = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 次数</span></span><br><span class="line"><span class="type">int</span> count = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 事件</span></span><br><span class="line">HANDLE eventA;</span><br><span class="line">HANDLE eventB;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产者</span></span><br><span class="line">DWORD WINAPI <span class="title function_">ThreadProc</span><span class="params">(LPVOID lpParameter)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="comment">// 等待事件，修改事件A状态</span></span><br><span class="line">        WaitForSingleObject(eventA, INFINITE);</span><br><span class="line">        <span class="comment">// 获取当前进程ID</span></span><br><span class="line">        <span class="type">int</span> threadId = GetCurrentThreadId();</span><br><span class="line">        <span class="comment">// 生产存放进容器</span></span><br><span class="line">        container = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Thread: %d, Build: %d \n&quot;</span>, threadId, container);</span><br><span class="line">        <span class="comment">// 给eventB设置信号</span></span><br><span class="line">        SetEvent(eventB);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费者</span></span><br><span class="line">DWORD WINAPI <span class="title function_">ThreadProcB</span><span class="params">(LPVOID lpParameter)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="comment">// 等待事件，修改事件B状态</span></span><br><span class="line">        WaitForSingleObject(eventB, INFINITE);</span><br><span class="line">        <span class="comment">// 获取当前进程ID</span></span><br><span class="line">        <span class="type">int</span> threadId = GetCurrentThreadId();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Thread: %d, Consume: %d \n&quot;</span>, threadId, container);</span><br><span class="line">        <span class="comment">// 消费</span></span><br><span class="line">        container = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 给eventA设置信号</span></span><br><span class="line">        SetEvent(eventA);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 创建事件</span></span><br><span class="line">    <span class="comment">// 线程同步的前提是互斥</span></span><br><span class="line">    <span class="comment">// 顺序按照先生产后消费，所以事件A设置信号，事件B需要通过生产者线程来设置信号</span></span><br><span class="line">    eventA = CreateEvent(<span class="literal">NULL</span>, FALSE, TRUE, <span class="literal">NULL</span>);</span><br><span class="line">    eventB = CreateEvent(<span class="literal">NULL</span>, FALSE, FALSE, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建2个线程</span></span><br><span class="line">    HANDLE hThread[<span class="number">2</span>];</span><br><span class="line">    hThread[<span class="number">0</span>] = CreateThread(<span class="literal">NULL</span>, <span class="literal">NULL</span>, ThreadProc, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">    hThread[<span class="number">1</span>] = CreateThread(<span class="literal">NULL</span>, <span class="literal">NULL</span>, ThreadProcB, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    WaitForMultipleObjects(<span class="number">2</span>, hThread, TRUE, INFINITE);</span><br><span class="line">    CloseHandle(hThread[<span class="number">0</span>]);</span><br><span class="line">    CloseHandle(hThread[<span class="number">1</span>]);</span><br><span class="line">    <span class="comment">// 事件类型也是内核对象，所以也需要关闭句柄</span></span><br><span class="line">    CloseHandle(eventA);</span><br><span class="line">    CloseHandle(eventB);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样通过事件先让生产者执行，然后让生产者告诉消费者来消费，再由消费者告诉生产者生产的顺序执行，就合理利用了计算资源。</p>
<h2 id="窗口"><a href="#窗口" class="headerlink" title="窗口"></a>窗口</h2><h3 id="窗口的本质"><a href="#窗口的本质" class="headerlink" title="窗口的本质"></a>窗口的本质</h3><img src="/2024/07/05/Win32API/image-20240306185445689.png" alt="image-20240306185445689" style="zoom:50%;">

<p>ntoskrnl.exe和win32k.exe是系统提供的两个模块，kernel32.dll、user32.dl、gdi32.dll可以看成是接口</p>
<p>如果要使用user32.dll绘制窗口，就是GUI，使用gdi32.dll绘制窗口就是GDI。</p>
<p>在创建窗口中使用的句柄是<code>HWND</code>，这个句柄是全局句柄，是公有的。</p>
<h3 id="绘图"><a href="#绘图" class="headerlink" title="绘图"></a>绘图</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span>(disable:6031)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	HWND hwnd;</span><br><span class="line">	HDC hdc;</span><br><span class="line">	HPEN hpen;</span><br><span class="line">	HBRUSH hbrush;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//1. 设备对象</span></span><br><span class="line">	hwnd = (HWND)<span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//2. 获取对象上下文</span></span><br><span class="line">	hdc = GetDC(hwnd);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//3. 创建画笔 设直线条属性</span></span><br><span class="line">	hpen = CreatePen(PS_SOLID, <span class="number">5</span>, RGB(<span class="number">0xff</span>, <span class="number">0x45</span>, <span class="number">0x10</span>));</span><br><span class="line">	hbrush = (HBRUSH)GetStockObject(DC_BRUSH);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//4. 关联 如果不关联，会仍然使用系统提供的画笔</span></span><br><span class="line">	SelectObject(hdc, hpen);</span><br><span class="line">	SetDCBrushColor(hdc, RGB(<span class="number">0xc0</span>, <span class="number">0x30</span>, <span class="number">0x00</span>));</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	<span class="comment">//5. 画</span></span><br><span class="line">	LineTo(hdc, <span class="number">2560</span>, <span class="number">1600</span>);</span><br><span class="line">	Rectangle(hdc, <span class="number">200</span>, <span class="number">200</span>, <span class="number">600</span>, <span class="number">800</span>);</span><br><span class="line">	getchar();</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//6. 释放资源</span></span><br><span class="line">	DeleteObject(hpen);</span><br><span class="line">	ReleaseDC(hwnd, hdc);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2024/07/05/Win32API/image-20240306200851412.png" alt="image-20240306200851412" style="zoom:50%;">

<h2 id="Windows程序"><a href="#Windows程序" class="headerlink" title="Windows程序"></a>Windows程序</h2><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><img src="/2024/07/05/Win32API/image-20240306203415711.png" alt="image-20240306203415711" style="zoom:50%;">

<p>入口函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> APIENTRY <span class="title function_">WinMain</span><span class="params">(HINSTANCE hInstance, 		<span class="comment">//指向模块的句柄</span></span></span><br><span class="line"><span class="params">                     HINSTANCE hPrevInstance, 	<span class="comment">//永远为空</span></span></span><br><span class="line"><span class="params">                     PSTR szCmdLine, </span></span><br><span class="line"><span class="params">                     <span class="type">int</span> iCmdShow)</span>			   <span class="comment">//以最大化还是最小化还是隐藏等形式运行</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>窗口程序没有控制台打印输出，可以输出到调试里面</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span>(disable:4996)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> APIENTRY <span class="title function_">WinMain</span><span class="params">(HINSTANCE hInstance, HINSTANCE hPrevInstance, PSTR szCmdLine, <span class="type">int</span> iCmdShow)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> szOutBuff[<span class="number">0x80</span>];</span><br><span class="line">	DWORD dwAddr = (DWORD)hInstance;</span><br><span class="line">	<span class="built_in">sprintf</span>(szOutBuff, <span class="string">&quot;Buff: %d\n&quot;</span>, dwAddr);</span><br><span class="line">	OutputDebugString(szOutBuff);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2024/07/05/Win32API/image-20240307213505432.png" alt="image-20240307213505432" style="zoom:50%;">

<p>第一步，定义窗口是什么样的</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span>(disable:4996)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span>(disable:28251)</span></span><br><span class="line">LRESULT CALLBACK <span class="title function_">WindowProc</span><span class="params">(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> APIENTRY <span class="title function_">WinMain</span><span class="params">(HINSTANCE hInstance, HINSTANCE hPrevInstance, PSTR szCmdLine, <span class="type">int</span> iCmdShow)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> szOutBuff[<span class="number">0x80</span>];</span><br><span class="line">	<span class="comment">// 1.第一步：定义窗口是什么样的</span></span><br><span class="line">	TCHAR className[] = TEXT(<span class="string">&quot;Window Application&quot;</span>);			<span class="comment">//创建一个字符串，存储窗口名称</span></span><br><span class="line">	WNDCLASS wndclass = &#123; <span class="number">0</span> &#125;;								<span class="comment">//使用WNDCLASS类定义一个窗体，创建一个对象并初始化</span></span><br><span class="line">	wndclass.hbrBackground = (HBRUSH)COLOR_BACKGROUND;		<span class="comment">//窗口背景色-&gt;要转成画刷形式的</span></span><br><span class="line">	wndclass.lpszClassName = className;						<span class="comment">//窗口的名字</span></span><br><span class="line">	wndclass.hInstance = hInstance;							<span class="comment">//当前窗口属于哪个程序，就是属于本程序，所以把hInstance传进来</span></span><br><span class="line">	wndclass.lpfnWndProc = WindowProc;</span><br><span class="line">	RegisterClass(&amp;wndclass);										<span class="comment">//将刚才定义好的wndclass类告诉系统一声</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 2.第二步：创建并显示窗口、</span></span><br><span class="line">	HWND hwnd = CreateWindow(</span><br><span class="line">		className,							<span class="comment">//与上面定义的窗口关联</span></span><br><span class="line">		TEXT(<span class="string">&quot;My First Window&quot;</span>),			<span class="comment">//窗体名字</span></span><br><span class="line">		WS_OVERLAPPEDWINDOW,				<span class="comment">//窗体风格</span></span><br><span class="line">		<span class="number">200</span>,								<span class="comment">//相对于父窗口的x坐标</span></span><br><span class="line">		<span class="number">100</span>,								<span class="comment">//相对于父窗口的y坐标</span></span><br><span class="line">		<span class="number">600</span>,								<span class="comment">//窗体的宽度</span></span><br><span class="line">		<span class="number">400</span>,								<span class="comment">//窗体的高度	</span></span><br><span class="line">		<span class="literal">NULL</span>,								<span class="comment">//父窗口</span></span><br><span class="line">		<span class="literal">NULL</span>,								<span class="comment">//是否有菜单</span></span><br><span class="line">		hInstance,							<span class="comment">//当前窗口是属于哪个模块的</span></span><br><span class="line">		<span class="literal">NULL</span>								<span class="comment">//附加数据，先不管，填空</span></span><br><span class="line">		);</span><br><span class="line">	<span class="keyword">if</span> (hwnd == <span class="literal">NULL</span>)						<span class="comment">//创建失败就返回</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">sprintf</span>(szOutBuff, <span class="string">&quot;Error: %d\n&quot;</span>, GetLastError());</span><br><span class="line">		OutputDebugString(szOutBuff);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-10</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ShowWindow(hwnd,SW_SHOW);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 3.第三步：接收消息并处理</span></span><br><span class="line">	MSG msg;</span><br><span class="line">	BOOL bRet;</span><br><span class="line">	<span class="keyword">while</span> ((bRet = GetMessage(&amp;msg, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">0</span>)) != <span class="number">0</span>) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (bRet == <span class="number">-1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">sprintf</span>(szOutBuff, <span class="string">&quot;Error: %d\n&quot;</span>, GetLastError());</span><br><span class="line">			OutputDebugString(szOutBuff);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">// 转换消息</span></span><br><span class="line">			TranslateMessage(&amp;msg);</span><br><span class="line">			<span class="comment">// 分发消息 为了调用消息处理函数将这个消息处理掉</span></span><br><span class="line">			DispatchMessage(&amp;msg);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//消息处理函数</span></span><br><span class="line">LRESULT CALLBACK <span class="title function_">WindowProc</span><span class="params">(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> DefWindowProc(hwnd, uMsg, wParam, lParam);<span class="comment">//调用一下默认的消息处理函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2024/07/05/Win32API/image-20240307224351324.png" alt="image-20240307224351324"></p>
<h3 id="消息处理"><a href="#消息处理" class="headerlink" title="消息处理"></a>消息处理</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//消息处理函数</span></span><br><span class="line">LRESULT CALLBACK <span class="title function_">WindowProc</span><span class="params">(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/*char szOutBuff[0x80];</span></span><br><span class="line"><span class="comment">	sprintf(szOutBuff, &quot;消息类型: %d\n&quot;, GetLastError());</span></span><br><span class="line"><span class="comment">	OutputDebugString(szOutBuff);*/</span></span><br><span class="line">	<span class="keyword">switch</span> (uMsg)				<span class="comment">//想要的消息使用switch接收，其他的交给默认消息处理函数</span></span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">case</span> WM_DESTROY:</span><br><span class="line">	&#123;</span><br><span class="line">		PostQuitMessage(<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">case</span> WM_CHAR:</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//MessageBox(0,TEXT(&quot;456&quot;),TEXT(&quot;123&quot;),MB_OK);</span></span><br><span class="line">		<span class="type">char</span> szOutBuff[<span class="number">0x80</span>];</span><br><span class="line">		<span class="built_in">sprintf</span>(szOutBuff, <span class="string">&quot;按键:%x - %x - %c\n&quot;</span>, uMsg, wParam, wParam);</span><br><span class="line">		OutputDebugString(szOutBuff);</span><br><span class="line">	&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> DefWindowProc(hwnd, uMsg, wParam, lParam);<span class="comment">//调用默认的消息处理函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="子窗口控件"><a href="#子窗口控件" class="headerlink" title="子窗口控件"></a>子窗口控件</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span>(disable:4996)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span>(disable:28251)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IDC_EDIT_1 0x100</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IDC_BUTTON_1 0x101</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IDC_BUTTON_2 0x102</span></span><br><span class="line"></span><br><span class="line">LRESULT CALLBACK <span class="title function_">WindowProc</span><span class="params">(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)</span>;</span><br><span class="line"></span><br><span class="line">HINSTANCE g_hInstance;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> APIENTRY <span class="title function_">WinMain</span><span class="params">(HINSTANCE hInstance, HINSTANCE hPrevInstance, PSTR szCmdLine, <span class="type">int</span> iCmdShow)</span></span><br><span class="line">&#123;</span><br><span class="line">    g_hInstance = hInstance;</span><br><span class="line">    <span class="type">char</span> szOutBuff[<span class="number">0x80</span>];</span><br><span class="line">    <span class="comment">// 1.第一步：定义窗口是什么样的</span></span><br><span class="line">    TCHAR className[] = TEXT(<span class="string">&quot;Window Application&quot;</span>);            <span class="comment">//创建一个字符串，存储窗口名称</span></span><br><span class="line">    WNDCLASS wndclass = &#123; <span class="number">0</span> &#125;;                                <span class="comment">//使用WNDCLASS类定义一个窗体，创建一个对象并初始化</span></span><br><span class="line">    wndclass.hbrBackground = (HBRUSH)COLOR_BACKGROUND;        <span class="comment">//窗口背景色-&gt;要转成画刷形式的</span></span><br><span class="line">    wndclass.lpszClassName = className;                        <span class="comment">//窗口的名字</span></span><br><span class="line">    wndclass.hInstance = hInstance;                            <span class="comment">//当前窗口属于哪个程序，就是属于本程序，所以把hInstance传进来</span></span><br><span class="line">    wndclass.lpfnWndProc = WindowProc;</span><br><span class="line">    RegisterClass(&amp;wndclass);                                        <span class="comment">//将刚才定义好的wndclass类告诉系统一声</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.第二步：创建并显示窗口、</span></span><br><span class="line">    HWND hwnd = CreateWindow(</span><br><span class="line">        className,                            <span class="comment">//与上面定义的窗口关联</span></span><br><span class="line">        TEXT(<span class="string">&quot;My First Window&quot;</span>),            <span class="comment">//窗体名字</span></span><br><span class="line">        WS_OVERLAPPEDWINDOW,                <span class="comment">//窗体风格</span></span><br><span class="line">        <span class="number">200</span>,                                <span class="comment">//相对于父窗口的x坐标</span></span><br><span class="line">        <span class="number">100</span>,                                <span class="comment">//相对于父窗口的y坐标</span></span><br><span class="line">        <span class="number">600</span>,                                <span class="comment">//窗体的宽度</span></span><br><span class="line">        <span class="number">400</span>,                                <span class="comment">//窗体的高度    </span></span><br><span class="line">        <span class="literal">NULL</span>,                                <span class="comment">//父窗口</span></span><br><span class="line">        <span class="literal">NULL</span>,                                <span class="comment">//是否有菜单</span></span><br><span class="line">        hInstance,                            <span class="comment">//当前窗口是属于哪个模块的</span></span><br><span class="line">        <span class="literal">NULL</span>                                <span class="comment">//附加数据，先不管，填空</span></span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">if</span> (hwnd == <span class="literal">NULL</span>)                        <span class="comment">//创建失败就返回</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">sprintf</span>(szOutBuff, <span class="string">&quot;Error: %d\n&quot;</span>, GetLastError());</span><br><span class="line">        OutputDebugString(szOutBuff);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ShowWindow(hwnd, SW_SHOW);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.第三步：接收消息并处理</span></span><br><span class="line">    MSG msg;</span><br><span class="line">    BOOL bRet;</span><br><span class="line">    <span class="keyword">while</span> ((bRet = GetMessage(&amp;msg, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">0</span>)) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (bRet == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">sprintf</span>(szOutBuff, <span class="string">&quot;Error: %d\n&quot;</span>, GetLastError());</span><br><span class="line">            OutputDebugString(szOutBuff);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 转换消息</span></span><br><span class="line">            TranslateMessage(&amp;msg);</span><br><span class="line">            <span class="comment">// 分发消息 为了调用消息处理函数将这个消息处理掉</span></span><br><span class="line">            DispatchMessage(&amp;msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//消息处理函数</span></span><br><span class="line">LRESULT CALLBACK <span class="title function_">WindowProc</span><span class="params">(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> szOutBuff[<span class="number">0x80</span>];</span><br><span class="line">    <span class="comment">/*sprintf(szOutBuff, &quot;消息类型: %d\n&quot;, GetLastError());</span></span><br><span class="line"><span class="comment">    OutputDebugString(szOutBuff);*/</span></span><br><span class="line">    <span class="keyword">switch</span> (uMsg)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> WM_DESTROY:</span><br><span class="line">    &#123;</span><br><span class="line">        PostQuitMessage(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> WM_CREATE:</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//当创建了父窗口开始画子窗口</span></span><br><span class="line">        CreateWindow(</span><br><span class="line">            TEXT(<span class="string">&quot;EDIT&quot;</span>),                        <span class="comment">// Windows就知道这是一个文本框</span></span><br><span class="line">            <span class="string">&quot;&quot;</span>,                            <span class="comment">//    文本框不需要标题，所以给空</span></span><br><span class="line">            WS_CHILD | WS_VISIBLE | WS_VSCROLL | ES_MULTILINE,        <span class="comment">// 保证子窗口创建出来的时候在上层可见</span></span><br><span class="line">            <span class="number">10</span>,</span><br><span class="line">            <span class="number">10</span>,</span><br><span class="line">            <span class="number">200</span>,</span><br><span class="line">            <span class="number">100</span>,</span><br><span class="line">            hwnd,</span><br><span class="line">            (HMENU)IDC_EDIT_1,                        <span class="comment">//将宏定义的ID转换为HMENU类型</span></span><br><span class="line">            g_hInstance,</span><br><span class="line">            <span class="literal">NULL</span></span><br><span class="line">        );</span><br><span class="line">        CreateWindow(</span><br><span class="line">            TEXT(<span class="string">&quot;BUTTON&quot;</span>),                        <span class="comment">// 按钮</span></span><br><span class="line">            TEXT(<span class="string">&quot;设置&quot;</span>),</span><br><span class="line">            WS_CHILD | WS_VISIBLE,</span><br><span class="line">            <span class="number">300</span>,</span><br><span class="line">            <span class="number">300</span>,</span><br><span class="line">            <span class="number">100</span>,</span><br><span class="line">            <span class="number">30</span>,</span><br><span class="line">            hwnd,</span><br><span class="line">            (HMENU)IDC_BUTTON_1,                        <span class="comment">//将宏定义的ID转换为HMENU类型</span></span><br><span class="line">            g_hInstance,</span><br><span class="line">            <span class="literal">NULL</span></span><br><span class="line">        );</span><br><span class="line">        CreateWindow(</span><br><span class="line">            TEXT(<span class="string">&quot;BUTTON&quot;</span>),                        <span class="comment">// 按钮</span></span><br><span class="line">            TEXT(<span class="string">&quot;获取&quot;</span>),</span><br><span class="line">            WS_CHILD | WS_VISIBLE,</span><br><span class="line">            <span class="number">300</span>,</span><br><span class="line">            <span class="number">250</span>,</span><br><span class="line">            <span class="number">100</span>,</span><br><span class="line">            <span class="number">30</span>,</span><br><span class="line">            hwnd,</span><br><span class="line">            (HMENU)IDC_BUTTON_2,                        <span class="comment">//将宏定义的ID转换为HMENU类型</span></span><br><span class="line">            g_hInstance,</span><br><span class="line">            <span class="literal">NULL</span></span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> WM_COMMAND:</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (LOWORD(wParam))</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> IDC_BUTTON_1:</span><br><span class="line">        &#123;</span><br><span class="line">            SetDlgItemText(hwnd, IDC_EDIT_1, TEXT(<span class="string">&quot;123&quot;</span>));</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> IDC_BUTTON_2:</span><br><span class="line">        &#123;</span><br><span class="line">             GetDlgItemText(hwnd, IDC_EDIT_1,szOutBuff,<span class="number">100</span>);</span><br><span class="line">             MessageBox(hwnd, szOutBuff, szOutBuff, MB_OK);</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> DefWindowProc(hwnd, uMsg, wParam, lParam);<span class="comment">//调用一下默认的消息处理函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>一个文本框、两个按钮。</p>
<h2 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h2><h3 id="卷相关API"><a href="#卷相关API" class="headerlink" title="卷相关API"></a>卷相关API</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;1&gt;获取卷</span><br><span class="line">GetLogicalDrives()</span><br><span class="line"></span><br><span class="line">&lt;2&gt;获取一个所卷的盘符的字符串</span><br><span class="line">GetLogicalDrives()</span><br><span class="line"></span><br><span class="line">&lt;3&gt;获取卷的类型</span><br><span class="line">GetLogicalDrives()</span><br><span class="line"></span><br><span class="line">&lt;4&gt;获取卷的类型</span><br><span class="line">GetVolumelnformation()</span><br></pre></td></tr></table></figure>

<h3 id="目录相关API"><a href="#目录相关API" class="headerlink" title="目录相关API"></a>目录相关API</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;1&gt;创建目录</span><br><span class="line">CreateDirectory();</span><br><span class="line"></span><br><span class="line">&lt;2&gt;删除目录</span><br><span class="line">RemoveDirectory</span><br><span class="line"></span><br><span class="line">&lt;3&gt;修改目录名称</span><br><span class="line">MoveFile();</span><br><span class="line"></span><br><span class="line">&lt;4&gt;获取程序当前目录</span><br><span class="line">GetCurrentDirectory();</span><br><span class="line"></span><br><span class="line">&lt;5&gt;设置程序当前目录</span><br><span class="line">SetCurrentDirectory</span><br></pre></td></tr></table></figure>

<h2 id="动态链接库"><a href="#动态链接库" class="headerlink" title="动态链接库"></a>动态链接库</h2><h3 id="动态链接库-1"><a href="#动态链接库-1" class="headerlink" title="动态链接库"></a>动态链接库</h3><p>动态链接库（Dynamic Link Library，缩写DLL），是微软咋Windows操作系统中，实现共享函数库的一种方式，这些库函数的扩展名是.dll或.ocx</p>
<h3 id="创建动态链接库"><a href="#创建动态链接库" class="headerlink" title="创建动态链接库"></a>创建动态链接库</h3><p>首先要告诉编译器，如果定义两个函数，这两个函数是要给别人用的</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> _declspec(dllexport) 调用约定 返回类型 函数名(参数列表)</span><br></pre></td></tr></table></figure>

<p>比如这两个函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Plus</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> X + y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">Sub</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> x - y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果是自己用这两个函数，那么声明函数的时候直接：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Plus</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">Sub</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>;</span><br></pre></td></tr></table></figure>

<p>如果是要创建DLL，那么声明的时候使用：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> _declspec(dllexport) __sdtcall <span class="type">int</span> <span class="title function_">Plus</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> _declspec(dllexport) __sdtcall <span class="type">int</span> <span class="title function_">Sub</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>;</span><br></pre></td></tr></table></figure>

<p>声明时也可以使用.def文件：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">EXPORTS</span><br><span class="line">函数名 @编号</span><br><span class="line">函数名 @编号 NONAME</span><br></pre></td></tr></table></figure>

<p>使用序号导出的好处：名字是一段程序最精炼的注释，通过名字可能直接猜测到函数的功能，通过使用序号，可以达到隐藏的目的。</p>
<h3 id="使用DLL"><a href="#使用DLL" class="headerlink" title="使用DLL"></a>使用DLL</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1.定义函数指针</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">int</span><span class="params">(_cdecl* lpPlus)</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">int</span><span class="params">(_cdecl* lpSub)</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.声明函数指针变量</span></span><br><span class="line">lpPlus myPlus;</span><br><span class="line">lpSub mySub;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//3.动态加载dll到内存中</span></span><br><span class="line">	HINSTANCE hModule = LoadLibrary(<span class="string">&quot;C:\\Users\\23394\\Desktop\\code\\C C++\\Dll1\\Debug\\Dll1.dll&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.获取函数地址</span></span><br><span class="line">	myPlus = (lpPlus)GetProcAddress(hModule, <span class="string">&quot;plus&quot;</span>);</span><br><span class="line">	mySub = (lpSub)GetProcAddress(hModule, <span class="string">&quot;sub&quot;</span>);</span><br><span class="line"><span class="comment">//5.调用函数</span></span><br><span class="line">	<span class="type">int</span> x = myPlus(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">	<span class="type">int</span> y = mySub(<span class="number">5</span>, <span class="number">2</span>);</span><br><span class="line"><span class="comment">//6.释放动态链接库</span></span><br><span class="line">	FreeLibrary(hModule);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// MyDLL.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// dllmain.cpp : 定义 DLL 应用程序的入口点。</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;pch.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">plus</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sub</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> x - y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">BOOL APIENTRY <span class="title function_">DllMain</span><span class="params">( HMODULE hModule,</span></span><br><span class="line"><span class="params">                       DWORD  ul_reason_for_call,</span></span><br><span class="line"><span class="params">                       LPVOID lpReserved</span></span><br><span class="line"><span class="params">                     )</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (ul_reason_for_call)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> DLL_PROCESS_ATTACH:</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;DLL_PROCESS_ATTACH\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> DLL_THREAD_ATTACH:</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;DLL_THREAD_ATTACH\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> DLL_THREAD_DETACH:</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;DLL_THREAD_DETACH\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> DLL_PROCESS_DETACH:</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;DLL_PROCESS_DETACH\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>pch.h中添加：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> _declspec(dllexport) <span class="type">int</span> <span class="title function_">plus</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> _declspec(dllexport) <span class="type">int</span> <span class="title function_">sub</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>;</span><br></pre></td></tr></table></figure>

<p>编译完成后生成一个DLL</p>
<p>创建一个新项目，使用这个DLL</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">int</span><span class="params">(_cdecl* lpPlus)</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">int</span><span class="params">(_cdecl* lpSub)</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span>;</span><br><span class="line"></span><br><span class="line">lpPlus myPlus;</span><br><span class="line">lpSub mySub;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	HINSTANCE hModule = LoadLibrary(<span class="string">&quot;C:\\Users\\23394\\Desktop\\code\\C C++\\Dll1\\Debug\\Dll1.dll&quot;</span>);		<span class="comment">// 这里填DLL的路径（绝对路径或相对路径）</span></span><br><span class="line"></span><br><span class="line">	myPlus = (lpPlus)GetProcAddress(hModule, <span class="string">&quot;plus&quot;</span>);</span><br><span class="line">	mySub = (lpSub)GetProcAddress(hModule, <span class="string">&quot;sub&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> x = myPlus(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">	<span class="type">int</span> y = mySub(<span class="number">5</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">	FreeLibrary(hModule);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="隐式链接"><a href="#隐式链接" class="headerlink" title="隐式链接"></a>隐式链接</h3><h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><p>步骤1：将<code>.dll</code> <code>.lib</code>文件放到工程目录下面</p>
<p>步骤2：将&#96;#pragma comment(lib,”DLL名.lib”)添加到调用文件中</p>
<p>步骤3：加入函数的声明</p>
<h4 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib,<span class="string">&quot;C:\\Users\\23394\\Desktop\\code\\C C++\\win32AP\\Dll1.lib&quot;</span>)<span class="comment">//填写lib文件的路径</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//声明函数，这个声明跟在dll中的pch头文件中的声明一样</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="type">int</span> __declspec(dllimport) plus(<span class="type">int</span> x, <span class="type">int</span> y);</span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="type">int</span> __declspec(dllimport) sub(<span class="type">int</span> x, <span class="type">int</span> y);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//直接使用函数即可</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;plus(1, 2):%d, sub(3, 1):%d&quot;</span>, plus(<span class="number">1</span>, <span class="number">2</span>), sub(<span class="number">3</span>, <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="DLL入口函数"><a href="#DLL入口函数" class="headerlink" title="DLL入口函数"></a>DLL入口函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">BOOL APIENTRY <span class="title function_">DLLMain</span><span class="params">(HANDLE hModule, 	<span class="comment">//dll被加载到了哪个进程中，返回一个句柄</span></span></span><br><span class="line"><span class="params">						DWORD ul_reason_for_call, <span class="comment">//dll被调用的原因</span></span></span><br><span class="line"><span class="params">						LPVOID lpReserved)</span></span><br></pre></td></tr></table></figure>

<p>参数：DWORD ul_reason_for_call</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>当LoadLibrary时，DLL_PROCESS_ATTACH	(LoadLibrary)</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>当FreeLibrary时，DLL_PROCESS_DETACH	(FreeLibrary)</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>当在线程中加载dll时，DLL_THREAD_ATTACH</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span>当加载这个dll的线程结束的时候也会再次加载这个dll，此时传递的参数就是DLL_THREAD_DETACH</span><br></pre></td></tr></table></figure>

<h2 id="远程线程"><a href="#远程线程" class="headerlink" title="远程线程"></a>远程线程</h2><h3 id="CreateRemoteThread"><a href="#CreateRemoteThread" class="headerlink" title="CreateRemoteThread"></a>CreateRemoteThread</h3><p>创建远程线程，就是在另一个进程中创建一个新的线程。比如我的进程是Demo.exe，那么可以在一个IE.exe中创建一个新的线程让他跑起来。</p>
<h3 id="远程线程函数"><a href="#远程线程函数" class="headerlink" title="远程线程函数"></a>远程线程函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">HANDLE <span class="title function_">CreateRemoteThread</span><span class="params">(</span></span><br><span class="line"><span class="params">  [in]  HANDLE                 hProcess,		<span class="comment">//在哪个进程中创建这个线程，需要传递一个进程句柄</span></span></span><br><span class="line"><span class="params">  [in]  LPSECURITY_ATTRIBUTES  lpThreadAttributes,</span></span><br><span class="line"><span class="params">  [in]  SIZE_T                 dwStackSize,</span></span><br><span class="line"><span class="params">  [in]  LPTHREAD_START_ROUTINE lpStartAddress,</span></span><br><span class="line"><span class="params">  [in]  LPVOID                 lpParameter,</span></span><br><span class="line"><span class="params">  [in]  DWORD                  dwCreationFlags,</span></span><br><span class="line"><span class="params">  [out] LPDWORD                lpThreadId</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>

<p>这个函数与创建线程的函数基本相同，只是多了第一个参数，也就是要在哪个进程中创建这个线程。</p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>首先创建一个程序，里面创建一个线程</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">DWORD WINAPI <span class="title function_">ThreadProc</span><span class="params">(LPVOID lpParameter)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		Sleep(<span class="number">1000</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;-----%d-----\n&quot;</span>, i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	HANDLE hThread;</span><br><span class="line">	hThread = CreateThread(<span class="literal">NULL</span>, <span class="number">0</span>, ThreadProc, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">	CloseHandle(hThread);</span><br><span class="line"></span><br><span class="line">	getchar();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个线程在getchar处阻塞。</p>
<p>再写远程线程的程序：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">BOOL <span class="title function_">MyCreateRemoteThread</span><span class="params">(DWORD dwProcessId, DWORD dwProcessAddr)</span> &#123;</span><br><span class="line">	DWORD dwThreadId;</span><br><span class="line">	HANDLE hProcess;</span><br><span class="line">	HANDLE hThread;</span><br><span class="line">	<span class="comment">// 1. 获取进程句柄</span></span><br><span class="line">	hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwProcessId);</span><br><span class="line">	<span class="comment">// 判断OpenProcess是否执行成功</span></span><br><span class="line">	<span class="keyword">if</span> (hProcess == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		OutputDebugString(<span class="string">&quot;OpenProcess failed! \n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 2. 创建远程线程</span></span><br><span class="line">	hThread = CreateRemoteThread(</span><br><span class="line">		hProcess,							<span class="comment">// handle to process</span></span><br><span class="line">		<span class="literal">NULL</span>,								<span class="comment">// SD</span></span><br><span class="line">		<span class="number">0</span>,									<span class="comment">// initial stack size</span></span><br><span class="line">		(LPTHREAD_START_ROUTINE)dwProcessAddr,    <span class="comment">// thread function</span></span><br><span class="line">		<span class="literal">NULL</span>,								<span class="comment">// thread argument</span></span><br><span class="line">		<span class="number">0</span>,									<span class="comment">// creation option</span></span><br><span class="line">		&amp;dwThreadId							<span class="comment">// thread identifier</span></span><br><span class="line">	);</span><br><span class="line">	<span class="comment">// 判断CreateRemoteThread是否执行成功</span></span><br><span class="line">	<span class="keyword">if</span> (hThread == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		OutputDebugString(<span class="string">&quot;CreateRemoteThread failed! \n&quot;</span>);</span><br><span class="line">		CloseHandle(hProcess);</span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 3. 关闭</span></span><br><span class="line">	CloseHandle(hThread);</span><br><span class="line">	CloseHandle(hProcess);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 返回</span></span><br><span class="line">	<span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	MyCreateRemoteThread(<span class="number">39772</span>, <span class="number">0x6117B0</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>MyCreateRemoteThread函数中的第一个参数，传入的是要创建远程线程的程序的PID，也就是上面那个程序的PID；第二个参数是第一个程序中创建的线程的地址。</p>
<h2 id="远程线程注入"><a href="#远程线程注入" class="headerlink" title="远程线程注入"></a>远程线程注入</h2><h3 id="注入"><a href="#注入" class="headerlink" title="注入"></a>注入</h3><p>什么是注入<br>所谓注入就是在第三方进程不知道或者不允许的情况下将模块或者代码写入对方进程空间，并设法执行的技术。</p>
<p>在安全领域，“注入”是非常重要的一种技术手段，注入与反注入也一直处于不断变化的，而且也愈来愈激烈的对抗当中。</p>
<p>已知的注入方式：</p>
<p>远程线程注入、APC注入、消息钩子注入、注册表注入、导入表注入、输入法注入等等。</p>
<p>事例：</p>
<p>远程线程注入程序.exe：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Test.cpp : Defines the entry point for the console application.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tlhelp32.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span>(disable:4996)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span>(disable:6031)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// LoadDll需要两个参数一个参数是进程ID，一个是DLL文件的路径</span></span><br><span class="line">BOOL <span class="title function_">LoadDll</span><span class="params">(DWORD dwProcessID, <span class="type">const</span> <span class="type">char</span>* szDllPathName)</span> &#123;</span><br><span class="line"></span><br><span class="line">	BOOL bRet;</span><br><span class="line">	HANDLE hProcess;</span><br><span class="line">	HANDLE hThread;</span><br><span class="line">	DWORD dwLength;</span><br><span class="line">	DWORD dwLoadAddr;</span><br><span class="line">	LPVOID lpAllocAddr;</span><br><span class="line">	DWORD dwThreadID;</span><br><span class="line">	HMODULE hModule;</span><br><span class="line"></span><br><span class="line">	bRet = <span class="number">0</span>;</span><br><span class="line">	dwLoadAddr = <span class="number">0</span>;</span><br><span class="line">	hProcess = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 1. 获取进程句柄  被注入的进程的句柄</span></span><br><span class="line">	hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwProcessID);</span><br><span class="line">	<span class="keyword">if</span> (hProcess == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		OutputDebugString(<span class="string">&quot;OpenProcess failed! \n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 2. 获取DLL文件路径的长度，并在最后+1，因为要加上0结尾的长度</span></span><br><span class="line">	dwLength = <span class="built_in">strlen</span>(szDllPathName) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 3. 在目标进程分配内存  在被注入的进程中分别配一段空间，存储DLL的地址</span></span><br><span class="line">	lpAllocAddr = VirtualAllocEx(hProcess, <span class="literal">NULL</span>, dwLength, MEM_COMMIT, PAGE_READWRITE);</span><br><span class="line">	<span class="keyword">if</span> (lpAllocAddr == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		OutputDebugString(<span class="string">&quot;VirtualAllocEx failed! \n&quot;</span>);</span><br><span class="line">		CloseHandle(hProcess);</span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 4. 拷贝DLL路径名字到被注入进程的内存</span></span><br><span class="line">	bRet = WriteProcessMemory(hProcess, lpAllocAddr, reinterpret_cast&lt;LPCVOID&gt;(szDllPathName), dwLength, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (!bRet) &#123;</span><br><span class="line">		OutputDebugString(<span class="string">&quot;WriteProcessMemory failed! \n&quot;</span>);</span><br><span class="line">		CloseHandle(hProcess);</span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 5. 获取模块句柄</span></span><br><span class="line">	<span class="comment">// LoadLibrary这个函数是在kernel32.dll这个模块中的，所以需要先获取kernel32.dll这个模块的句柄</span></span><br><span class="line">	hModule = GetModuleHandle(<span class="string">&quot;kernel32.dll&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (!hModule) &#123;</span><br><span class="line">		OutputDebugString(<span class="string">&quot;GetModuleHandle failed! \n&quot;</span>);</span><br><span class="line">		CloseHandle(hProcess);</span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 6. 获取LoadLibraryA函数地址</span></span><br><span class="line">	dwLoadAddr = reinterpret_cast&lt;DWORD&gt;(GetProcAddress(hModule, <span class="string">&quot;LoadLibraryA&quot;</span>));</span><br><span class="line">	<span class="keyword">if</span> (!dwLoadAddr) &#123;</span><br><span class="line">		OutputDebugString(<span class="string">&quot;GetProcAddress failed! \n&quot;</span>);</span><br><span class="line">		CloseHandle(hModule);</span><br><span class="line">		CloseHandle(hProcess);</span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 7. 创建远程线程，加载DLL</span></span><br><span class="line">	hThread = CreateRemoteThread(hProcess, <span class="literal">NULL</span>, <span class="number">0</span>, reinterpret_cast&lt;LPTHREAD_START_ROUTINE&gt;(dwLoadAddr), lpAllocAddr, <span class="number">0</span>, &amp;dwThreadID);</span><br><span class="line">	<span class="keyword">if</span> (!hThread) &#123;</span><br><span class="line">		OutputDebugString(<span class="string">&quot;CreateRemoteThread failed! \n&quot;</span>); </span><br><span class="line">		DWORD dwError = GetLastError();</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;CreateRemoteThread failed with error: %d\n&quot;</span>, dwError);</span><br><span class="line"></span><br><span class="line">		CloseHandle(hModule);</span><br><span class="line">		CloseHandle(hProcess);</span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 8. 关闭进程句柄</span></span><br><span class="line">	CloseHandle(hThread);</span><br><span class="line">	CloseHandle(hProcess);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DWORD <span class="title function_">GetProcessIdByName</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* processName)</span> &#123;</span><br><span class="line">	HANDLE hSnap;</span><br><span class="line">	PROCESSENTRY32 pe32;</span><br><span class="line">	DWORD processId = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	hSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (hSnap == INVALID_HANDLE_VALUE) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Failed to create snapshot\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	pe32.dwSize = <span class="keyword">sizeof</span>(PROCESSENTRY32);</span><br><span class="line">	<span class="keyword">if</span> (!Process32First(hSnap, &amp;pe32)) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Failed to get the first process\n&quot;</span>);</span><br><span class="line">		CloseHandle(hSnap);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">strcmp</span>(pe32.szExeFile, processName) == <span class="number">0</span>) &#123;</span><br><span class="line">			processId = pe32.th32ProcessID;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!Process32Next(hSnap, &amp;pe32)) &#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	CloseHandle(hSnap);</span><br><span class="line">	<span class="keyword">return</span> processId;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> </span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 通过进程名获取进程PID</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span>* processName = <span class="string">&quot;被注入程序.exe&quot;</span>;</span><br><span class="line">	DWORD processId = GetProcessIdByName(processName);</span><br><span class="line">	<span class="keyword">if</span> (processId == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Failed to find the process\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Process ID: %lu\n&quot;</span>, processId);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 注入DLL</span></span><br><span class="line">	LoadDll(processId, <span class="string">&quot;./远程线程注入dll.dll&quot;</span>);</span><br><span class="line">	getchar();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>被注入程序.exe：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span>(disaboe:6031)</span></span><br><span class="line"></span><br><span class="line">DWORD WINAPI <span class="title function_">ThreadProc</span><span class="params">(LPVOID lpParameter)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		Sleep(<span class="number">1000</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;-----%d-----\n&quot;</span>, i + <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	HANDLE hThread;</span><br><span class="line">	hThread = CreateThread(<span class="literal">NULL</span>, <span class="number">0</span>, ThreadProc, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">	CloseHandle(hThread);</span><br><span class="line"></span><br><span class="line">	getchar();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注入的DLL：</p>
<p>pch.h头文件：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> PCH_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PCH_H</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加要在此处预编译的标头</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;framework.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//PCH_H</span></span></span><br></pre></td></tr></table></figure>

<p>dllmain.cpp：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// dllmain.cpp : 定义 DLL 应用程序的入口点。</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;pch.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">DWORD WINAPI <span class="title function_">ThreadProc</span><span class="params">(LPVOID lpParameter)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;The program is being injected\n&quot;</span>);</span><br><span class="line">        Sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BOOL APIENTRY <span class="title function_">DllMain</span><span class="params">( HMODULE hModule,</span></span><br><span class="line"><span class="params">                       DWORD  ul_reason_for_call,</span></span><br><span class="line"><span class="params">                       LPVOID lpReserved</span></span><br><span class="line"><span class="params">                     )</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">switch</span> (ul_reason_for_call)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> DLL_PROCESS_ATTACH:</span><br><span class="line">        CreateThread(<span class="literal">NULL</span>, <span class="number">0</span>, ThreadProc, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> DLL_THREAD_ATTACH:</span><br><span class="line">    <span class="keyword">case</span> DLL_THREAD_DETACH:</span><br><span class="line">    <span class="keyword">case</span> DLL_PROCESS_DETACH:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="模块隐藏"><a href="#模块隐藏" class="headerlink" title="模块隐藏"></a>模块隐藏</h2><h3 id="模块隐藏之断链"><a href="#模块隐藏之断链" class="headerlink" title="模块隐藏之断链"></a>模块隐藏之断链</h3><p>TEB(Thread Environment Block线程环境块) ，他记录线程相关的信息，每一个线程都有自己的TEB，<code>FS:[0]</code>是当前线程的TEB。</p>
<p>PEB(Process Environment Block进程环境块)存放进程信息，每个进程都有自己的PEB信息，TEB偏移0x30即当前进程的PEB地址</p>
<p>TEB和PEB都在用户空间</p>
<p><img src="/2024/07/05/Win32API/image-20240320200212614.png" alt="image-20240320200212614"></p>
<p>在OD中使用指令<code>dd [FS]</code>，跳转到TEB的位置：</p>
<p>比如，先打开kernel32.dll的位置，</p>
<p><img src="/2024/07/05/Win32API/image-20240320170850397.png" alt="image-20240320170850397"></p>
<p><img src="/2024/07/05/Win32API/image-20240320191115578.png" alt="image-20240320191115578"></p>
<p><img src="/2024/07/05/Win32API/image-20240320171515791.png" alt="image-20240320171515791"></p>
<p>当API函数遍历模块的时候就是查PEB中的表</p>
<p><img src="/2024/07/05/Win32API/image-20240320171915170.png" alt="image-20240320171915170"></p>
<h3 id="PEB断链原码"><a href="#PEB断链原码" class="headerlink" title="PEB断链原码"></a>PEB断链原码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">UNICODE_STRING</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    USHORT Length;        <span class="comment">//字符串长度</span></span><br><span class="line">    USHORT MaximumLength; <span class="comment">//字符串最大长度</span></span><br><span class="line">    PWSTR Buffer;         <span class="comment">//双字节字符串指针</span></span><br><span class="line">&#125; UNICODE_STRING, * PUNICODE_STRING;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">PEB_LDR_DATA</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ULONG Length;</span><br><span class="line">    BOOLEAN Initialized;</span><br><span class="line">    PVOID SsHandle;</span><br><span class="line">    LIST_ENTRY InLoadOrderModuleList;           <span class="comment">//代表按加载顺序构成的模块列表</span></span><br><span class="line">    LIST_ENTRY InMemoryOrderModuleList;         <span class="comment">//代表按内存顺序构成的模块列表</span></span><br><span class="line">    LIST_ENTRY InInitializationOrderModuleList; <span class="comment">//代表按初始化顺序构成的模块链表</span></span><br><span class="line">&#125;PEB_LDR_DATA, * PPEB_LDR_DATA;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">LDR_DATA_TABLE_ENTRY</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    LIST_ENTRY InLoadOrderModuleList;  <span class="comment">//代表按加载顺序构成的模块列表</span></span><br><span class="line">    LIST_ENTRY InMemoryOrderModuleList;    <span class="comment">//代表按内存顺序构成的模块列表</span></span><br><span class="line">    LIST_ENTRY InInitializeationOrderModuleList; <span class="comment">//代表按初始化顺序构成的模块链表</span></span><br><span class="line">    PVOID DllBase;     <span class="comment">//该模块的基地址</span></span><br><span class="line">    PVOID EntryPoint;  <span class="comment">//该模块的入口</span></span><br><span class="line">    ULONG SizeOfImage; <span class="comment">//该模块的影像大小</span></span><br><span class="line">    UNICODE_STRING FullDllName;    <span class="comment">//模块的完整路径</span></span><br><span class="line">    UNICODE_STRING BaseDllName;    <span class="comment">//模块名</span></span><br><span class="line">    ULONG Flags;</span><br><span class="line">    SHORT LoadCount;</span><br><span class="line">    SHORT TlsIndex;</span><br><span class="line">    HANDLE SectionHandle;</span><br><span class="line">    ULONG CheckSum;</span><br><span class="line">    ULONG TimeDataStamp;</span><br><span class="line">&#125;LDR_MODULE, * PLDR_MODULE;</span><br><span class="line"></span><br><span class="line">PEB_LDR_DATA* g_pPebLdr = <span class="literal">NULL</span>;</span><br><span class="line">LDR_MODULE* g_pLdrModule = <span class="literal">NULL</span>;</span><br><span class="line">LIST_ENTRY* g_pInLoadOrderModule;</span><br><span class="line">LIST_ENTRY* g_pInMemoryOrderModule;</span><br><span class="line">LIST_ENTRY* g_pInInitializeationOrderModule;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ring3BrokenChains</span><span class="params">(HMODULE hModule)</span></span><br><span class="line">&#123;</span><br><span class="line">    LIST_ENTRY* pHead = g_pInLoadOrderModule;</span><br><span class="line">    LIST_ENTRY* pCur = pHead;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        pCur = pCur-&gt;Blink;</span><br><span class="line">        g_pLdrModule = (PLDR_MODULE)pCur;  <span class="comment">// 这里为什么可以直接将pCur转为PLDR_MODULE，见下面代码解释</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// CONTAINING_RECORD这个宏返回成员变量所在结构体的基址，ldte == g_pLdrModule</span></span><br><span class="line">        <span class="comment">// PLDR_MODULE ldte = CONTAINING_RECORD(pCur, _LDR_DATA_TABLE_ENTRY, InLoadOrderModuleList);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (hModule == g_pLdrModule-&gt;DllBase)</span><br><span class="line">        &#123;</span><br><span class="line">            g_pLdrModule-&gt;InLoadOrderModuleList.Blink-&gt;Flink = g_pLdrModule-&gt;InLoadOrderModuleList.Flink;</span><br><span class="line">            g_pLdrModule-&gt;InLoadOrderModuleList.Flink-&gt;Blink = g_pLdrModule-&gt;InLoadOrderModuleList.Blink;</span><br><span class="line"></span><br><span class="line">            g_pLdrModule-&gt;InInitializeationOrderModuleList.Blink-&gt;Flink = g_pLdrModule-&gt;InInitializeationOrderModuleList.Flink;</span><br><span class="line">            g_pLdrModule-&gt;InInitializeationOrderModuleList.Flink-&gt;Blink = g_pLdrModule-&gt;InInitializeationOrderModuleList.Blink;</span><br><span class="line"></span><br><span class="line">            g_pLdrModule-&gt;InMemoryOrderModuleList.Blink-&gt;Flink = g_pLdrModule-&gt;InMemoryOrderModuleList.Flink;</span><br><span class="line">            g_pLdrModule-&gt;InMemoryOrderModuleList.Flink-&gt;Blink = g_pLdrModule-&gt;InMemoryOrderModuleList.Blink;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (pHead != pCur);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    __asm</span><br><span class="line">    &#123;</span><br><span class="line">        mov eax, fs: [<span class="number">0x30</span>] ;  <span class="comment">// PPEB</span></span><br><span class="line">        mov ecx, [eax + <span class="number">0xC</span>];  <span class="comment">// ldr</span></span><br><span class="line">        mov g_pPebLdr, ecx;</span><br><span class="line"></span><br><span class="line">        mov ebx, ecx;</span><br><span class="line">        add ebx, <span class="number">0xC</span>;</span><br><span class="line">        mov g_pInLoadOrderModule, ebx;              <span class="comment">// 第1个链表</span></span><br><span class="line"></span><br><span class="line">        mov ebx, ecx;</span><br><span class="line">        add ebx, <span class="number">0x14</span>;</span><br><span class="line">        mov g_pInMemoryOrderModule, ebx;            <span class="comment">// 第2个链表</span></span><br><span class="line"></span><br><span class="line">        mov ebx, ecx;</span><br><span class="line">        add ebx, <span class="number">0x1C</span>;</span><br><span class="line">        mov g_pInInitializeationOrderModule, ebx;   <span class="comment">// 第3个链表</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;点任意按键开始断链&quot;</span>);</span><br><span class="line">    getchar();</span><br><span class="line">    ring3BrokenChains(GetModuleHandleA(<span class="string">&quot;kernel32.dll&quot;</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;断链成功\n&quot;</span>);</span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比如：使用以上函数，将以下几个库都断开</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ring3BrokenChains(GetModuleHandleA(<span class="string">&quot;kernel32.dll&quot;</span>));</span><br><span class="line">ring3BrokenChains(GetModuleHandleA(<span class="string">&quot;ntdll.dll&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>断开前：</p>
<p><img src="/2024/07/05/Win32API/image-20240320205056436.png" alt="image-20240320205056436"></p>
<p>断开后：</p>
<p><img src="/2024/07/05/Win32API/image-20240320205125990.png" alt="image-20240320205125990"></p>
<p>参见：[<a href="https://bbs.kanxue.com/thread-278717.htm">原创]超详细的3环和0环断链隐藏分析-软件逆向-看雪-安全社区|安全招聘|kanxue.com</a></p>
<h2 id="代码注入"><a href="#代码注入" class="headerlink" title="代码注入"></a>代码注入</h2><h3 id="代码注入原则"><a href="#代码注入原则" class="headerlink" title="代码注入原则"></a>代码注入原则</h3><p>四种代码不能注入的情况：</p>
<p>&lt;1&gt; 不能有全局变量<br>&lt;2&gt; 不能使用常量字符串<br>&lt;3&gt; 不能使用系统调用<br>&lt;4&gt; 不能嵌套其他函数</p>
<h3 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h3><p>有这么多限制该怎么办？假设我们要将代码进程的代码拷贝过去，这段代码的作用就是创建文件，那么它得流程可以如下图所示：</p>
<img src="/2024/07/05/Win32API/image-20240321135504313.png" alt="image-20240321135504313" style="zoom:70%;">

<p>首先将代码进程的ThreadProc复制过去，然后将复制过去之后目标进程的地址给到<strong>CreateRemoteThread</strong>函数，这样就解决了自定义函数的问题；</p>
<p>其次我们要创建文件的话就必须要使用<strong>CreateFile</strong>函数，我们不能直接这样写，因为它依赖当前进程的导入表，当前进程和目标进程导入表的地址肯定是不一样的，<strong>所以不符合复制代码的编写原则</strong>；所以我们可以通过线程函数的参数来解决，我们先将所有用到的目标参数写到一个结构体中复制到目标进程，然后将目标进程结构体的地址作为线程函数的参数。</p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>传递参数进行远程注入代码的实现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tlhelp32.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    DWORD dwCreateAPIAddr;                <span class="comment">// Createfile函数的地址</span></span><br><span class="line">    LPCTSTR lpFileName;                    <span class="comment">// 下面都是CreateFile所需要用到的参数</span></span><br><span class="line">    DWORD dwDesiredAccess;</span><br><span class="line">    DWORD dwShareMode;</span><br><span class="line">    LPSECURITY_ATTRIBUTES lpSecurityAttributes;</span><br><span class="line">    DWORD dwCreationDisposition;</span><br><span class="line">    DWORD dwFlagsAndAttributes;</span><br><span class="line">    HANDLE hTemplateFile;</span><br><span class="line">&#125; CREATEFILE_PARAM;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个函数指针</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">HANDLE</span><span class="params">(WINAPI* PFN_CreateFile)</span> <span class="params">(</span></span><br><span class="line"><span class="params">    LPCTSTR lpFileName,</span></span><br><span class="line"><span class="params">    DWORD dwDesiredAccess,</span></span><br><span class="line"><span class="params">    DWORD dwShareMode,</span></span><br><span class="line"><span class="params">    LPSECURITY_ATTRIBUTES lpSecurityAttributes,</span></span><br><span class="line"><span class="params">    DWORD dwCreationDisposition,</span></span><br><span class="line"><span class="params">    DWORD dwFlagsAndAttributes,</span></span><br><span class="line"><span class="params">    HANDLE hTemplateFile</span></span><br><span class="line"><span class="params">)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编写要复制到目标进程的函数</span></span><br><span class="line">DWORD _stdcall <span class="title function_">CreateFileThreadProc</span><span class="params">(LPVOID lparam)</span></span><br><span class="line">&#123;</span><br><span class="line">    CREATEFILE_PARAM* Gcreate = (CREATEFILE_PARAM*)lparam;</span><br><span class="line">    PFN_CreateFile pfnCreateFile;</span><br><span class="line">    pfnCreateFile = (PFN_CreateFile)Gcreate-&gt;dwCreateAPIAddr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// creatFile结构体全部参数</span></span><br><span class="line">    pfnCreateFile(</span><br><span class="line">        Gcreate-&gt;lpFileName,</span><br><span class="line">        Gcreate-&gt;dwDesiredAccess,</span><br><span class="line">        Gcreate-&gt;dwShareMode,</span><br><span class="line">        Gcreate-&gt;lpSecurityAttributes,</span><br><span class="line">        Gcreate-&gt;dwCreationDisposition,</span><br><span class="line">        Gcreate-&gt;dwFlagsAndAttributes,</span><br><span class="line">        Gcreate-&gt;hTemplateFile</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 远程创建文件</span></span><br><span class="line">BOOL <span class="title function_">RemotCreateFile</span><span class="params">(DWORD dwProcessID, <span class="type">char</span>* szFilePathName)</span></span><br><span class="line">&#123;</span><br><span class="line">    BOOL bRet;</span><br><span class="line">    DWORD dwThread;</span><br><span class="line">    HANDLE hProcess;</span><br><span class="line">    HANDLE hThread;</span><br><span class="line">    DWORD dwThreadFunSize;</span><br><span class="line">    CREATEFILE_PARAM GCreateFile;</span><br><span class="line">    LPVOID lpFilePathName;</span><br><span class="line">    LPVOID lpRemotThreadAddr;</span><br><span class="line">    LPVOID lpFileParamAddr;</span><br><span class="line">    DWORD dwFunAddr;</span><br><span class="line">    HMODULE hModule;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    bRet = <span class="number">0</span>;</span><br><span class="line">    hProcess = <span class="number">0</span>;</span><br><span class="line">    dwThreadFunSize = <span class="number">0x400</span>;</span><br><span class="line">    <span class="comment">// 1. 获取进程的句柄</span></span><br><span class="line">    hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwProcessID);</span><br><span class="line">    <span class="keyword">if</span> (hProcess == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        OutputDebugString(<span class="string">&quot;OpenProcessError! \n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2. 分配3段内存：存储参数，线程函数，文件名</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.1 用来存储文件名 +1是要计算到结尾处</span></span><br><span class="line">    lpFilePathName = VirtualAllocEx(hProcess, <span class="literal">NULL</span>, <span class="built_in">strlen</span>(szFilePathName)+<span class="number">1</span>, MEM_COMMIT, PAGE_READWRITE); <span class="comment">// 在指定的进程中分配内存</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.2 用来存储线程函数</span></span><br><span class="line">    lpRemotThreadAddr = VirtualAllocEx(hProcess, <span class="literal">NULL</span>, dwThreadFunSize, MEM_COMMIT, PAGE_READWRITE); <span class="comment">// 在指定的进程中分配内存</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.3 用来存储文件参数</span></span><br><span class="line">    lpFileParamAddr = VirtualAllocEx(hProcess, <span class="literal">NULL</span>, <span class="keyword">sizeof</span>(CREATEFILE_PARAM), MEM_COMMIT, PAGE_READWRITE); <span class="comment">// 在指定的进程中分配内存</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 初始化CreateFile参数</span></span><br><span class="line">    GCreateFile.dwDesiredAccess = GENERIC_READ | GENERIC_WRITE;</span><br><span class="line">    GCreateFile.dwShareMode = <span class="number">0</span>;</span><br><span class="line">    GCreateFile.lpSecurityAttributes = <span class="literal">NULL</span>;</span><br><span class="line">    GCreateFile.dwCreationDisposition = OPEN_ALWAYS;</span><br><span class="line">    GCreateFile.dwFlagsAndAttributes = FILE_ATTRIBUTE_NORMAL;</span><br><span class="line">    GCreateFile.hTemplateFile = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 获取CreateFile的地址</span></span><br><span class="line">    <span class="comment">// 因为每个进程中的LoadLibrary函数都在Kernel32.dll中，而且此dll的物理页是共享的，所以我们进程中获得的LoadLibrary地址和别的进程都是一样的</span></span><br><span class="line">    hModule = GetModuleHandle(<span class="string">&quot;kernel32.dll&quot;</span>);</span><br><span class="line">    GCreateFile.dwCreateAPIAddr = (DWORD)GetProcAddress(hModule, <span class="string">&quot;CreateFileA&quot;</span>);</span><br><span class="line">    FreeLibrary(hModule);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 初始化CreatFile文件名</span></span><br><span class="line">    GCreateFile.lpFileName = (LPCTSTR)lpFilePathName;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6. 修改线程函数起始地址</span></span><br><span class="line">    dwFunAddr = (DWORD)CreateFileThreadProc;</span><br><span class="line">    <span class="comment">// 间接跳</span></span><br><span class="line">    <span class="keyword">if</span> (*((BYTE*)dwFunAddr) == <span class="number">0xE9</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        dwFunAddr = dwFunAddr + <span class="number">5</span> + *(DWORD*)(dwFunAddr + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 7. 开始复制</span></span><br><span class="line">    <span class="comment">// 7.1 拷贝文件名</span></span><br><span class="line">    WriteProcessMemory(hProcess, lpFilePathName, szFilePathName, <span class="built_in">strlen</span>(szFilePathName) + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 7.2 拷贝线程函数</span></span><br><span class="line">    WriteProcessMemory(hProcess, lpRemotThreadAddr, (LPVOID)dwFunAddr, dwThreadFunSize, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 7.3 拷贝参数</span></span><br><span class="line">    WriteProcessMemory(hProcess, lpFileParamAddr, &amp;GCreateFile, <span class="keyword">sizeof</span>(CREATEFILE_PARAM), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 8. 创建远程线程</span></span><br><span class="line">    hThread = CreateRemoteThread(hProcess, <span class="literal">NULL</span>, <span class="number">0</span>, (LPTHREAD_START_ROUTINE)lpRemotThreadAddr, lpFileParamAddr, <span class="number">0</span>, &amp;dwThread);<span class="comment">// lpAllocAddr传给线程函数的参数.因为dll名字分配在内存中</span></span><br><span class="line">    <span class="keyword">if</span> (hThread == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        OutputDebugString(<span class="string">&quot;CreateRemoteThread Error! \n&quot;</span>);</span><br><span class="line">        CloseHandle(hProcess);</span><br><span class="line">        CloseHandle(hModule);</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 9. 关闭资源</span></span><br><span class="line">    CloseHandle(hProcess);</span><br><span class="line">    CloseHandle(hThread);</span><br><span class="line">    CloseHandle(hModule);</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据进程名称获取进程ID</span></span><br><span class="line">DWORD <span class="title function_">GetPID</span><span class="params">(<span class="type">char</span> *szName)</span></span><br><span class="line">&#123;</span><br><span class="line">    HANDLE hProcessSnapShot = <span class="literal">NULL</span>;</span><br><span class="line">    PROCESSENTRY32 pe32 = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    hProcessSnapShot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (hProcessSnapShot == (HANDLE)<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pe32.dwSize = <span class="keyword">sizeof</span>(PROCESSENTRY32);</span><br><span class="line">    <span class="keyword">if</span> (Process32First(hProcessSnapShot, &amp;pe32))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(szName, pe32.szExeFile)) &#123;</span><br><span class="line">                <span class="keyword">return</span> (<span class="type">int</span>)pe32.th32ProcessID;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> (Process32Next(hProcessSnapShot, &amp;pe32));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        CloseHandle(hProcessSnapShot);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    RemotCreateFile(GetPID(<span class="string">&quot;进程名&quot;</span>), <span class="string">&quot;文件名&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id><a href="#" class="headerlink" title></a></h1>]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>PE</title>
    <url>/2024/03/20/PE/</url>
    <content><![CDATA[<h1 id="PE"><a href="#PE" class="headerlink" title="PE"></a>PE</h1><h2 id="PE文件结构"><a href="#PE文件结构" class="headerlink" title="PE文件结构"></a>PE文件结构</h2><h3 id="可执行文件"><a href="#可执行文件" class="headerlink" title="可执行文件"></a>可执行文件</h3><p>可执行文件（executable file）指的是可以由操作系统进行加载执行的文件</p>
<blockquote>
<p>exe。txt之类的不是可执行文件，因为txt文件依赖exe打开。</p>
</blockquote>
<p>可执行文件格式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Windows平台：	PE(Portable Executable)文件结构</span><br><span class="line">Linux平台：	ELF(Executable and Linking Format)文件结构</span><br></pre></td></tr></table></figure>

<p>应用</p>
<p>&lt;1&gt;病毒与犯病毒</p>
<p>&lt;2&gt;外挂与反外挂</p>
<p>&lt;3&gt;加壳与脱壳（保护与破解）</p>
<p>&lt;4&gt;无源码修改功能、软件汉化等</p>
<span id="more"></span>

<h3 id="PE指纹"><a href="#PE指纹" class="headerlink" title="PE指纹"></a>PE指纹</h3><p><img src="/2024/03/20/PE/image-20240321150124826.png" alt="image-20240321150124826"></p>
<p>开头是<code>4D 5A</code>，往后查到0x3C的位置，这里存着一个地址，<code>F0</code>，从头往后查<code>F0</code>个地址，发现是<code>50 45</code>也就是<strong>PE</strong>，这就是PE指纹。</p>
<p>.sys  .exe  .dll都符合PE文件结构，都有这样一个结构体：</p>
<img src="/2024/03/20/PE/image-20240321151527264.png" alt="image-20240321151527264" style="zoom:50%;">

<h3 id="PE文件的两种状态"><a href="#PE文件的两种状态" class="headerlink" title="PE文件的两种状态"></a>PE文件的两种状态</h3><p>DOS MZ头         DOS块	4个字的PE标识	20个字节标准PE头		224个字节的扩展PE头	40个字节第一个节表里面的数据		40个字节节表里的第二个成员		40个字节第三个成员		40个字节第四个成员		至此标准PE头结束</p>
<img src="/2024/03/20/PE/image-20240321205031681.png" alt="image-20240321205031681" style="zoom:67%;">

<h2 id="DOS头属性说明"><a href="#DOS头属性说明" class="headerlink" title="DOS头属性说明"></a>DOS头属性说明</h2><h3 id="DOS-MZ文件头结构"><a href="#DOS-MZ文件头结构" class="headerlink" title="DOS MZ文件头结构"></a>DOS MZ文件头结构</h3><p><img src="/2024/03/20/PE/image-20240321205435799.png" alt="image-20240321205435799"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//注释掉的不需要重点分析</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_DOS_HEADER</span>&#123;</span></span><br><span class="line">    <span class="number">0X00</span> WORD e_magic;      <span class="comment">//※Magic DOS signature MZ(4Dh 5Ah):MZ标记:用于标记是否是可执行文件</span></span><br><span class="line">    <span class="comment">//0X02 WORD e_cblp;     //Bytes on last page of file</span></span><br><span class="line">    <span class="comment">//0X04 WORD e_cp;       //Pages in file</span></span><br><span class="line">    <span class="comment">//0X06 WORD e_crlc;     //Relocations</span></span><br><span class="line">    <span class="comment">//0X08 WORD e_cparhdr;  //Size of header in paragraphs</span></span><br><span class="line">    <span class="comment">//0X0A WORD e_minalloc; //Minimun extra paragraphs needs</span></span><br><span class="line">    <span class="comment">//0X0C WORD e_maxalloc; //Maximun extra paragraphs needs</span></span><br><span class="line">    <span class="comment">//0X0E WORD e_ss;       //intial(relative)SS value</span></span><br><span class="line">    <span class="comment">//0X10 WORD e_sp;       //intial SP value</span></span><br><span class="line">    <span class="comment">//0X12 WORD e_csum;     //Checksum</span></span><br><span class="line">    <span class="comment">//0X14 WORD e_ip;       //intial IP value</span></span><br><span class="line">    <span class="comment">//0X16 WORD e_cs;       //intial(relative)CS value</span></span><br><span class="line">    <span class="comment">//0X18 WORD e_lfarlc;   //File Address of relocation table</span></span><br><span class="line">    <span class="comment">//0X1A WORD e_ovno;     //Overlay number</span></span><br><span class="line">    <span class="comment">//0x1C WORD e_res[4];   //Reserved words</span></span><br><span class="line">    <span class="comment">//0x24 WORD e_oemid;    //OEM identifier(for e_oeminfo)</span></span><br><span class="line">    <span class="comment">//0x26 WORD e_oeminfo;  //OEM information;e_oemid specific</span></span><br><span class="line">    <span class="comment">//0x28 WORD e_res2[10]; //Reserved words</span></span><br><span class="line">    <span class="comment">//0x3C DWORD e_lfanew;    //※Offset to start of PE header:定位PE文件，PE头相对于文件的偏移量</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这个结构体是16位的，但是现在的程序一般都运行在32位或64为的平台，但是有两个例外（标红的）。</p>
<p>两个红的还在使用，也就是这两个地方↓↓↓。除了这两个地方，其他的地方删了也不影响程序的正常运行。</p>
<p><img src="/2024/03/20/PE/image-20240321210416972.png" alt="image-20240321210416972"></p>
<h2 id="PE头"><a href="#PE头" class="headerlink" title="PE头"></a>PE头</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef struct _IMAGE_NT_HEADERS&#123;</span><br><span class="line">	DWORD Signature;		//PE头标识</span><br><span class="line">	IMAGE_FILE_HEADER FileHeader;	//标准PE头</span><br><span class="line">	IMAGE_OPTIONAL_HEADER32 OptionalHeader;		//扩展PE头</span><br><span class="line">&#125; IMAGE_NT_HEADER32,*PIMAGE_NT_HEADER32;</span><br></pre></td></tr></table></figure>

<p>PE标识：PE标识不能破坏，操作系统在启动一个程序的时候会检测这个标识</p>
<h3 id="标准PE头"><a href="#标准PE头" class="headerlink" title="标准PE头"></a>标准PE头</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef struct _IMAGE_FILE_HEADER &#123;</span><br><span class="line">	WORD Machine;					//可以运行在什么样的CPU上 任意：0  Intel368及以后：14C	x64:8664</span><br><span class="line">	WORD NumberOfSections;			//表示节的数量</span><br><span class="line">	DWORD TimeDateStamp;			//编译器填写的时间戳  与文件属性页面里面的创建时间、修改时间无关</span><br><span class="line">	DWORD PointerToSysbolTable;		//调试相关（不重要</span><br><span class="line">	DWROD NumberOfSys=mbols;		//调试相关（不重要</span><br><span class="line">	WORD SizeOfOptionalHeader;		//可选(扩展)PE头的大小(x32位PE文件：0xE0；x64PE文件：0xF0)</span><br><span class="line">    WORD Characteristics;			//文件属性</span><br><span class="line">&#125;	IMAGE_FILE_HEADER,*PIMAGE_FILE_HEADER;</span><br></pre></td></tr></table></figure>

<p><img src="/2024/03/20/PE/image-20240325192925364.png" alt="image-20240325192925364"></p>
<p>文件属性：</p>
<p><img src="/2024/03/20/PE/image-20240325153015448.png" alt="image-20240325153015448"></p>
<h3 id="扩展PE头"><a href="#扩展PE头" class="headerlink" title="扩展PE头"></a>扩展PE头</h3><p>32位的扩展PE头和64位的扩展PE头不太一样，这里只说32位的扩展PE头</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_OPTIONAL_HEADER</span> &#123;</span></span><br><span class="line">    WORD    Magic; <span class="comment">// PE32：10B PE32+：20B</span></span><br><span class="line">    BYTE    MajorLinkerVersion; <span class="comment">// 链接器版本号</span></span><br><span class="line">    BYTE    MinorLinkerVersion; <span class="comment">// 链接器版本号</span></span><br><span class="line">    DWORD   SizeOfCode; <span class="comment">// 所有代码节的总和（文件对齐后的大小），编译器填的（没用）</span></span><br><span class="line">    DWORD   SizeOfInitializedData; <span class="comment">// 包含所有已经初始化数据的节的总大小（文件对齐后的大小），编译器填的（没用）</span></span><br><span class="line">    DWORD   SizeOfUninitializedData; <span class="comment">// 包含未初始化数据的节的总大小（文件对齐后的大小），编译器填的（没用）</span></span><br><span class="line">    DWORD   AddressOfEntryPoint; <span class="comment">// 程序入口</span></span><br><span class="line">    DWORD   BaseOfCode; <span class="comment">// 代码开始的基址，编译器填的（没用）</span></span><br><span class="line">    DWORD   BaseOfData; <span class="comment">// 数据开始的基址，编译器填的（没用）</span></span><br><span class="line">    DWORD   ImageBase; <span class="comment">// 内存镜像基址</span></span><br><span class="line">    DWORD   SectionAlignment; <span class="comment">// 内存对齐</span></span><br><span class="line">    DWORD   FileAlignment; <span class="comment">// 文件对齐</span></span><br><span class="line">    WORD    MajorOperatingSystemVersion; <span class="comment">// 标识操作系统版本号，主版本号</span></span><br><span class="line">    WORD    MinorOperatingSystemVersion; <span class="comment">// 标识操作系统版本号，次版本号</span></span><br><span class="line">    WORD    MajorImageVersion; <span class="comment">// PE文件自身的版本号 </span></span><br><span class="line">    WORD    MinorImageVersion; <span class="comment">// PE文件自身的版本号</span></span><br><span class="line">    WORD    MajorSubsystemVersion; <span class="comment">// 运行所需子系统版本号</span></span><br><span class="line">    WORD    MinorSubsystemVersion; <span class="comment">// 运行所需子系统版本号</span></span><br><span class="line">    DWORD   Win32VersionValue; <span class="comment">// 子系统版本的值，必须为0</span></span><br><span class="line">    DWORD   SizeOfImage; <span class="comment">// 内存中整个PE文件的映射的尺寸，且是内存对齐的整数倍</span></span><br><span class="line">    DWORD   SizeOfHeaders; <span class="comment">// 所有头加节表按照文件对齐后的大小，否则加载会出错</span></span><br><span class="line">    DWORD   CheckSum; <span class="comment">// 校验和 两个字节两个字节相加，最后再加上文件长度，当两个字节相加时有溢出，让其自然溢出。最后相加得到的和就是校验和</span></span><br><span class="line">    WORD    Subsystem; <span class="comment">// 子系统，驱动程序(1)、图形界面(2) 、控制台/DLL(3)</span></span><br><span class="line">    WORD    DllCharacteristics; <span class="comment">// 文件特性 不是针对DLL的</span></span><br><span class="line">    DWORD   SizeOfStackReserve; <span class="comment">// 初始化时保留的栈大小 </span></span><br><span class="line">    DWORD   SizeOfStackCommit; <span class="comment">// 初始化时实际提交的大小 </span></span><br><span class="line">    DWORD   SizeOfHeapReserve; <span class="comment">// 初始化时保留的堆大小</span></span><br><span class="line">    DWORD   SizeOfHeapCommit; <span class="comment">// 初始化时实践提交的大小 </span></span><br><span class="line">    DWORD   LoaderFlags; <span class="comment">// 调试相关</span></span><br><span class="line">    DWORD   NumberOfRvaAndSizes; <span class="comment">// 目录项数目</span></span><br><span class="line">    IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES]; <span class="comment">// 表，结构体数组</span></span><br><span class="line">&#125; IMAGE_OPTIONAL_HEADER32, *PIMAGE_OPTIONAL_HEADER32;</span><br></pre></td></tr></table></figure>

<p><strong>Magic表示当前PE文件是32位还是64位</strong>，32位时该值对应0x10B，64位时该值对应0x20B。</p>
<p>其中的文件特性：拆分为二进制后对应的位：</p>
<img src="/2024/03/20/PE/image-20240326151008611.png" alt="image-20240326151008611" style="zoom:67%;">

<p><strong>AddressOfEntryPoint表示当前程序入口地址，</strong>这个成员与<strong>ImageBase</strong>相加才能得到真正的入口地址，成员<strong>ImageBase</strong>用来表示内存镜像基址，也就是PE文件在内存中按内存对齐展开后的首地址。</p>
<h3 id="节表"><a href="#节表" class="headerlink" title="节表"></a>节表</h3><img src="/2024/03/20/PE/image-20240326151849451.png" alt="image-20240326151849451" style="zoom:67%;">

<h4 id="节表数据结构说明"><a href="#节表数据结构说明" class="headerlink" title="节表数据结构说明"></a>节表数据结构说明</h4><p> 节表是一个结构体数组，每一个结构体描述一个节的信息。</p>
<img src="/2024/03/20/PE/image-20240326151949413.png" alt="image-20240326151949413" style="zoom:67%;">

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SIZEOF_SHORT_NAME 8</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_SECTION_HEADER</span> &#123;</span></span><br><span class="line">    BYTE    Name[IMAGE_SIZEOF_SHORT_NAME]; <span class="comment">// ASCII字符串（节名），可自定义，只截取8个字节，可以8个字节都是名字</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span> <span class="comment">// Misc，双字，是该节在没有对齐前的真实尺寸，该值可以不准确</span></span><br><span class="line">        DWORD   PhysicalAddress; <span class="comment">// 真实宽度，这两个值是一个联合结构，可以使用其中的任何一个</span></span><br><span class="line">        DWORD   VirtualSize; <span class="comment">// 一般是取后一个</span></span><br><span class="line">    &#125; Misc;					</span><br><span class="line">    DWORD   VirtualAddress; <span class="comment">// 在内存中的偏移地址，加上ImageBase才是在内存中的真正地址</span></span><br><span class="line">    DWORD   SizeOfRawData; <span class="comment">// 节在文件中对齐后的尺寸</span></span><br><span class="line">    DWORD   PointerToRawData; <span class="comment">// 节区在文件中的偏移</span></span><br><span class="line">    DWORD   PointerToRelocations; <span class="comment">// 调试相关</span></span><br><span class="line">    DWORD   PointerToLinenumbers; <span class="comment">// 调试相关 </span></span><br><span class="line">    WORD    NumberOfRelocations; <span class="comment">// 调试相关 </span></span><br><span class="line">    WORD    NumberOfLinenumbers; <span class="comment">// 调试相关 </span></span><br><span class="line">    DWORD   Characteristics; <span class="comment">// 节的属性</span></span><br><span class="line">&#125; IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER;</span><br></pre></td></tr></table></figure>

<p>代码中的注释可以大致了解到每个成员的作用，其中有2个成员来描述节的大小，分别是没有对齐前的真实尺寸和对齐后的宽度，这时候会出现一种情况就是对齐前的真实尺寸大于对齐后的宽度，<strong>这就是存在全局变量没有赋予初始值导致的，在文件存储中全局变量没有赋予初始值也就不占空间，但是在内存中是必须要赋予初始值的，这时候宽度就大了一些，</strong>所以在内存中节是谁大就按照谁去展开。</p>
<p><img src="/2024/03/20/PE/image-20240326202315229.png" alt="image-20240326202315229"></p>
<p>节的属性：将四个位全部展开后对应下表</p>
<p><img src="/2024/03/20/PE/image-20240326201156279.png" alt="image-20240326201156279"></p>
<h2 id="RVA与FOA的转换"><a href="#RVA与FOA的转换" class="headerlink" title="RVA与FOA的转换"></a>RVA与FOA的转换</h2><p>问题：如果想改变一个全局变量的初始值，该怎么做？</p>
<p>有初始值的全局变量和没有初始值的全局变量在PE文件中是不一样的。没有初始值的全局变量在PE文件中根本没有他的位置，只有在运行时内存展开后才会给他分配一个0；有初始值的全局变量的值是已经在PE文件中。</p>
<img src="/2024/03/20/PE/image-20240328143419116.png" alt="image-20240328143419116" style="zoom:67%;">

<p>这个地址是在内存展开后的地址，直接在PE文件中找这个地址肯定不行，因为PE文件静态和动态的地址肯定不一样。</p>
<img src="/2024/03/20/PE/image-20240328143817385.png" alt="image-20240328143817385" style="zoom:50%;">

<p>所以要把动态时的地址转换成PE文件静态地址。</p>
<p>这两种状态的地址相互转换，可以称为RVA与FOA的转换，<strong>RVA</strong>就是相对虚拟地址（Relative Virtual Address）（动态），<strong>FOA</strong>就是文件偏移地址（File Offset Address）（静态），FOA和内存无关，它是某个位置距离文件头的偏移。</p>
<p><img src="/2024/03/20/PE/image-20240328150556759.png" alt="image-20240328150556759"></p>
<ol>
<li>RVA地址由内存地址减去ImageBase地址（PE文件在内存中的开始位置是由扩展PE头中的ImageBase决定）；</li>
<li>判断RVA地址是否位于PE头中：<ol>
<li><strong>如果是，那么RVA等于FOA</strong>；</li>
<li><strong>如果不是，判断RVA位于哪个节：</strong><ol>
<li>当满足<strong>RVA地址大于等于节.VirtualAddress和RVA地址小雨等于节.VirtualAddress加上当前节内存对齐后的大小</strong>时，就表示RVA地址在该节中。</li>
<li>RVA地址减去节.VirtualAddress等于差值，<strong>FOA地址就是根据节.PointerToRawData加上差值</strong>。</li>
</ol>
</li>
</ol>
</li>
</ol>
<p>在一些较老的编译器中，编译出来的文件会区分文件对齐、内存对齐，但是在现在的编译器编译出来的程序，文件对齐与内存对齐时完全一样的，所以我们不用费这么大的周折，我们只需要算出RVA的值就可以得出FOA的值。</p>
<h2 id="空白区添加代码"><a href="#空白区添加代码" class="headerlink" title="空白区添加代码"></a>空白区添加代码</h2><p>目标：打开程序时首先弹出一个窗口。</p>
<p>&lt;1&gt;构造要写入的代码<br>&lt;2&gt;在PE的空白区构造一段代码<br>&lt;3&gt;修改入口地址为新增代码位置<br>&lt;4&gt;新增代码执行后，跳回入口地址</p>
<p>构造要写入的代码，比如调用一个MessageBoxA。在VS中查看反汇编可以发现调用MessageBoxA的时候先有4个<code>push 0</code>，然后是一个调用。在编译器中看到的调用是间接调用，如果要写到PE文件中需要使用直接调用。</p>
<p>首先打开一个exe程序，查看一下MessageBoxA在内存中的地址。因为user32.dll中的地址是不会变的，所以直接拿过来就可以使用（同一台电脑一样，但是每台电脑不一样）。</p>
<p>使用<code>call</code>时，硬编码为<code>E8</code>，后面跟的地址应该是地址偏移。计算公式为<code>目标地址 - E8所在地址 - 5 = E8后面应该写的值</code>。</p>
<p>通过查询得MessageBoxA的地址为<code>751DA0E0</code>。</p>
<p>如果将E8写在0x3A8处，那么E8后面应该加的值为<code>751DA0E0 - 4003A8 - 5 = 74 DD 9D 33</code>。</p>
<img src="/2024/03/20/PE/image-20240330134830550.png" alt="image-20240330134830550" style="zoom:50%;">

<p>执行完这段代码之后，还要跳转回原先的程序入口。</p>
<p><img src="/2024/03/20/PE/image-20240330134931128.png" alt="image-20240330134931128"></p>
<p>在扩展PE头中查到这个地址是0x11023。所以还要计算E9后面跟的值。</p>
<p><code>0x411023 - 0x4003AD - 5 = 10C71</code></p>
<p>所以：<img src="/2024/03/20/PE/image-20240330135148603.png" alt="image-20240330135148603" style="zoom: 45%;"></p>
<p>这时添加的代码就完成了，最后还需要把文件开始执行的地址改成E8前面开始push的地址，也就是0x3A0。</p>
<p><img src="/2024/03/20/PE/3b7099b3a1cfc3c7826169ef678318f.png" alt="3b7099b3a1cfc3c7826169ef678318f"></p>
<h2 id="扩大节"><a href="#扩大节" class="headerlink" title="扩大节"></a>扩大节</h2><p>当我们需要插入的代码比较多时，如果只在节表后面的空白区域添加是不够的，所以可以在某一个节中添加，因此扩大一个节。</p>
<p>扩大节时，最好是扩大最后一个节，因为如果要扩大前面的节的话，后面每一个节的属性都需要修改。所以扩大最后一个节。</p>
<p>首先在文件的最后，插入需要的大小，比如扩大最后一个节0x1000(DEC:4096)</p>
<p><img src="/2024/03/20/PE/image-20240330160701699.png" alt="image-20240330160701699"></p>
<p>一个节表的定义如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SIZEOF_SHORT_NAME ``8</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_SECTION_HEADER</span> &#123;</span></span><br><span class="line">    BYTE    Name[IMAGE_SIZEOF_SHORT_NAME]; ``<span class="comment">// ASCII字符串（节名），可自定义，只截取8个字节，可以8个字节都是名字</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span> ``<span class="comment">// Misc，双字，是该节在没有对齐前的真实尺寸，该值可以不准确</span></span><br><span class="line">        DWORD   PhysicalAddress; ``<span class="comment">// 真实宽度，这两个值是一个联合结构，可以使用其中的任何一个</span></span><br><span class="line">        DWORD   VirtualSize; ``<span class="comment">// 一般是取后一个</span></span><br><span class="line">    &#125; Misc;					</span><br><span class="line">    DWORD   VirtualAddress; ``<span class="comment">// 在内存中的偏移地址，加上ImageBase才是在内存中的真正地址</span></span><br><span class="line">    DWORD   SizeOfRawData; ``<span class="comment">// 节在文件中对齐后的尺寸</span></span><br><span class="line">    DWORD   PointerToRawData; ``<span class="comment">// 节区在文件中的偏移</span></span><br><span class="line">    DWORD   PointerToRelocations; ``<span class="comment">// 调试相关</span></span><br><span class="line">    DWORD   PointerToLinenumbers; ``<span class="comment">// 调试相关 </span></span><br><span class="line">    WORD    NumberOfRelocations; ``<span class="comment">// 调试相关 </span></span><br><span class="line">    WORD    NumberOfLinenumbers; ``<span class="comment">// 调试相关 </span></span><br><span class="line">    DWORD   Characteristics; ``<span class="comment">// 节的属性</span></span><br><span class="line">&#125; IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER;</span><br></pre></td></tr></table></figure>

<p>想要扩大节就需要修改SizeOfRawData、VirtualSize。</p>
<p><img src="/2024/03/20/PE/image-20240330162850162.png" alt="image-20240330162850162"></p>
<p><img src="/2024/03/20/PE/image-20240330163011905.png" alt="image-20240330163011905"></p>
<h3 id="扩大节的步骤"><a href="#扩大节的步骤" class="headerlink" title="扩大节的步骤"></a>扩大节的步骤</h3><p>&lt;1&gt; 分配一块新的空间，大小为S</p>
<p>&lt;2&gt; 将最后一个节的SizeOfRawData和VirtualSize改成N</p>
<p>​		N &#x3D; （SizeOfRawData或者VirtualSize内存对齐后的值) + S			SizeOPfImageData和VirtualSize谁大选谁 </p>
<p>&lt;3&gt; 修改SizeOfImage大小</p>
<h2 id="新增节"><a href="#新增节" class="headerlink" title="新增节"></a>新增节</h2><p>扩大节时可能会影响扩大的最后一个节，因为修改了该节的属性，可能从只读变成可读可写，影响代码的执行。</p>
<h3 id="新增节的步骤"><a href="#新增节的步骤" class="headerlink" title="新增节的步骤"></a>新增节的步骤</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;1&gt; 判断是否有足够的空间，可以增加一个新节表</span><br><span class="line"></span><br><span class="line">&lt;2&gt;在节表中新增一个成员</span><br><span class="line"></span><br><span class="line">&lt;3&gt;修改PE头中节的数量</span><br><span class="line"></span><br><span class="line">&lt;4&gt;修改SizeOfImage的大小</span><br><span class="line"></span><br><span class="line">&lt;5&gt;在原有数据的最后，新增一个节的数据（内存对齐的整数倍）</span><br><span class="line"></span><br><span class="line">&lt;6&gt;修正新增节表的属性</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="新增节-1"><a href="#新增节-1" class="headerlink" title="新增节"></a>新增节</h3><h4 id="有空间新增一个节表"><a href="#有空间新增一个节表" class="headerlink" title="有空间新增一个节表"></a>有空间新增一个节表</h4><img src="/2024/03/20/PE/image-20240408195256004.png" alt="image-20240408195256004" style="zoom:35%;">

<h4 id="复制一份节表"><a href="#复制一份节表" class="headerlink" title="复制一份节表"></a>复制一份节表</h4><p>可以复制一份.text节表，这个节表用来存储执行代码，不需要修改节的属性</p>
<p><img src="/2024/03/20/PE/image-20240408195702299.png" alt="image-20240408195702299"></p>
<p>加到后面，改一个名字</p>
<p>在标准PE头中，第二个成员是节的数量，本来有6个节，现在加一个节，改成7</p>
<p><img src="/2024/03/20/PE/image-20240408195808690.png" alt="image-20240408195808690"></p>
<p>为了方便添加节，还需要修改一下最后一个节表成员的属性，将其真实大小（VirtualSize）修改成文件对齐之后的大小（SizeOfRawData）：</p>
<p><img src="/2024/03/20/PE/image-20240409085156500.png" alt="image-20240409085156500"></p>
<p>接着修改添加的节表成员的属性：名字、真实大小（0x1000）、文件对齐之后的大小（0x1000）、内存中的偏移（第4个节的偏移地址0x74000+其数据大小0x4000）、文件中的偏移：</p>
<p><img src="/2024/03/20/PE/image-20240409085933456.png" alt="image-20240409085933456"></p>
<p>SizeOfImage + 0x1000</p>
<p><img src="/2024/03/20/PE/image-20240409091935619.png" alt="image-20240409091935619"></p>
<p>然后再文件最后插入0x1000的数据即可（4096字节）</p>
<p>这样新增节就完成了，然后可以在新增的节中增加要执行的代码</p>
<h2 id="合并节"><a href="#合并节" class="headerlink" title="合并节"></a>合并节</h2><p>上一章中了解到新增节需要在节表之后至少有40个字节的空白区给我们去新增，但并不是所有的程序都可以满足这个条件，如下图所示的程序在节表之后的数据是编译器填充的，这些数据并不能覆盖：</p>
<p><img src="/2024/03/20/PE/image2021-12-28_15-44-45.png" alt="images/download/attachments/1015828/image2021-12-28_15-44-45.png"></p>
<p>(视频看不了，见在线笔记)</p>
<h2 id="导出表"><a href="#导出表" class="headerlink" title="导出表"></a>导出表</h2><p>一个可执行程序是由多个PE文件组成的，一个exe运行的时候，不仅有exe文件，还有一堆dll文件</p>
<p>exe中的<strong>导入表</strong>存储了这个程序需要用哪些dll</p>
<p><strong>导出表</strong>中存储了这个PE文件中的哪些函数需要提供给别人使用。</p>
<p>通常情况下，exe不提供函数给别人用，也就是一般没有导出表吗，但是不代表exe不能有导出表。</p>
<p>dll文件通常会调用其他函数，其他的exe或dll也会调用其中的函数，所以dll一般既有导出表，也有导入表。</p>
<h3 id="定位导出表"><a href="#定位导出表" class="headerlink" title="定位导出表"></a>定位导出表</h3><p>找到PE头最后一个成员结构体数组，</p>
<p>然后找到该结构体数组的第一个结构体，里面包含了导出表的相对虚拟地址和导出表所占大小。</p>
<p><img src="/2024/03/20/PE/image-20240515143123896.png" alt="image-20240515143123896"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">VirtualAddress：0x10000</span><br><span class="line">Size：0x7AE</span><br></pre></td></tr></table></figure>

<p>根据SectionAlign和FileAlign计算出导出表所在的位置</p>
<img src="/2024/03/20/PE/image-20240515150034086.png" alt="image-20240515150034086" style="zoom:50%;">

<p>然后就能找到导出表</p>
<img src="/2024/03/20/PE/image-20240515150229847.png" alt="image-20240515150229847" style="zoom:80%;">

<h2 id="导入表"><a href="#导入表" class="headerlink" title="导入表"></a>导入表</h2><h3 id="导入表——确定依赖模块"><a href="#导入表——确定依赖模块" class="headerlink" title="导入表——确定依赖模块"></a>导入表——确定依赖模块</h3><p>和导出表一样，找到节表上面的结构体数组，找到第二个结构体成员。</p>
<p>因为打开的是一个exe，所以导出表是00 00 00 00（一般）</p>
<p><img src="/2024/03/20/PE/image-20240515222312319.png" alt="image-20240515222312319"></p>
<p>这里存储导入表RVA和Size：RVA-&gt;0x4BB74，Size-&gt;0x64</p>
<p>这个exe的SectionAlign和FileAlign不相同，所以先将RVA转换成FOA</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SectionAlign：0x1000</span><br><span class="line">FileALign：0x200</span><br></pre></td></tr></table></figure>

<p>RVA：0x4BB74 -&gt; FOA：0x4AB74，VA：0x14004BB74</p>
<p><img src="/2024/03/20/PE/image-20240516083214817.png" alt="image-20240516083214817"></p>
<p>这个exe总共有4个依赖模块，最后由20个0结束。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">B8 C0 04 00 00 00 00 00 00 00 00 00 0A C2 04 00 E0 D4 03 00</span><br><span class="line">D8 BB 04 00 00 00 00 00 00 00 00 00 2C C3 04 00 00 D0 03 00</span><br><span class="line">18 C1 04 00 00 00 00 00 00 00 00 00 A2 C3 04 00 40 D5 03 00</span><br><span class="line">48 BC 04 00 00 00 00 00 00 00 00 00 1A CA 04 00 70 D0 03 00</span><br><span class="line">00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</span><br></pre></td></tr></table></figure>

<p>以下是导入表的结构，倒数第二个成员是一个字符串，存储的是依赖模块的地址，从这个RVA地址一直找到00结束</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_IMAGE_IMPORT_DESCRIPTOR</span> &#123;</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        DWORD Characteristics;</span><br><span class="line">        DWORD OriginalFirstThunk; ``<span class="comment">// RVA，指向IMAGE_THUNK_DATA结构数组</span></span><br><span class="line">    &#125;;</span><br><span class="line">    DWORD TimeDateStamp; ``<span class="comment">// 时间戳</span></span><br><span class="line">        DWORD ForwarderChain;</span><br><span class="line">    DWORD Name; ``<span class="comment">// RVA，表示依赖模块名字的地址，这是一串字符串</span></span><br><span class="line">        DWORD FirstThunk; ``<span class="comment">// RVA，指向IMAGE_THUNK_DATA结构数组</span></span><br><span class="line">&#125; IMAGE_IMPORT_DESCRIPTOR;</span><br></pre></td></tr></table></figure>

<p><img src="/2024/03/20/PE/image-20240516090158390.png" alt="image-20240516090158390"></p>
<p>所以，第一个依赖的模块就是USER32.dll</p>
<p><img src="/2024/03/20/PE/image-20240516090423249.png" alt="image-20240516090423249"></p>
<p>第二个模块是ADVAPI32.dll</p>
<p><img src="/2024/03/20/PE/image-20240516090556137.png" alt="image-20240516090556137"></p>
<p>第三个模块是ale32.dll</p>
<p><img src="/2024/03/20/PE/image-20240516090703665.png" alt="image-20240516090703665"></p>
<p>第四个模块是KERNEL32.dll</p>
<p><img src="/2024/03/20/PE/image-20240516090944739.png" alt="image-20240516090944739"></p>
<h3 id="导入表——确定依赖函数"><a href="#导入表——确定依赖函数" class="headerlink" title="导入表——确定依赖函数"></a>导入表——确定依赖函数</h3><p>在确定这个PE文件依赖那些导入表之外，还要确定这个PE文件依赖哪些函数。</p>
<p>在导入表结构体中，OriginalFirstThunk指向一个<strong>INT</strong>(Import Name Table)导入名称表，FirstThunk指向一个IAT(Import Address Table)导入地址表。</p>
<p><img src="/2024/03/20/PE/image-20240516091514313.png" alt="image-20240516091514313"></p>
<p>观察这两张表，这两张表指向不同的（地址不同）两张表，但是两者的内容一样。因此通过两个成员都能够找到当前所依赖模块中的函数。因此任选择一个成员去找依赖函数即可。</p>
<p>第一个成员指向的就是一个<strong>INT</strong>，结构体如下表，这个结构体中只有一个联合体，它的宽度就是四字节：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_IMAGE_THUNK_DATA32</span> &#123;</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        PBYTE ForwarderString;</span><br><span class="line">        PDWORD Function;</span><br><span class="line">        DWORD Ordinal; ``<span class="comment">// 序号</span></span><br><span class="line">            PIMAGE_IMPORT_BY_NAME AddressOfData; ``<span class="comment">// 指向IMAGE_IMPORT_BY_NAME</span></span><br><span class="line">    &#125; u1;</span><br><span class="line">&#125; IMAGE_THUNK_DATA32;</span><br></pre></td></tr></table></figure>

<p><strong>INT</strong>中有很多个这种结构体，他与导入表一样，当遇到与这个结构体宽度相同的一段0x00时，就代表这个表结束了。同时在这里面发现的结构体的数量就代表依赖模块的函数数量。</p>
<p><img src="/2024/03/20/PE/image-20240516152559528.png" alt="image-20240516152559528"></p>
<h3 id="导入表——确定依赖地址"><a href="#导入表——确定依赖地址" class="headerlink" title="导入表——确定依赖地址"></a>导入表——确定依赖地址</h3><p>在静态PE文件中，<strong>INT</strong>和<strong>IAT</strong>两张表的结构内容是一样的：</p>
<p><img src="/2024/03/20/PE/image-20240516202442765.png" alt="image-20240516202442765"></p>
<p>但是，当PE文件加载之后，IAT就发生了变化，它里面直接储存了函数的地址：</p>
<p><img src="/2024/03/20/PE/image-20240516202548298.png" alt="image-20240516202548298"></p>
<p>当程序在使用依赖模块的函数时，实际上是间接调用，比如调用MessageBoxA函数时，汇编指令不是直接call地址，而是从内存中找到这个地址再call：</p>
<p><img src="/2024/03/20/PE/image-20240516202749490-1720116192893-2.png" alt="image-20240516202749490"></p>
<p>而这一块内存就是IAT中存储的函数地址：</p>
<img src="/2024/03/20/PE/image-20240516202815003.png" alt="image-20240516202815003" style="zoom:50%;">

<p>为什么不只留一张表：因为IAT的函数地址很有可能被修改掉，导致地址不正确，如果只有一张表的话，就没有一个正确的参照物了。</p>
<h2 id="重定位表"><a href="#重定位表" class="headerlink" title="重定位表"></a>重定位表</h2><p>PE文件中最重要的三张表：导出表、导入表、重定位表</p>
<p>假设某个PE文件使用了一些模块，这些模块都有自己的ImageBase（内存中开始的地址），但实际上在内存中模块的ImageBase被别人占用了，<strong>这时候模块就需要偏移，换一个新的内存地址去展开，</strong>假设在这个模块中有很多已经写好了的地址硬编码（<strong>但凡涉及直接寻址的指令都需要进行重定位处理</strong>），当换了地址之后就找不到了，甚至会出现安全隐患，所以硬编码的地址是需要随着偏移而去修改的，<strong>这时候就需要一张表去记录需要修正的位置，便于去根据对应偏移修正，这张表就称为重定位表；</strong>一般来说，<strong>exe文件是没有重定位表的，</strong>因为他一般不会提供函数给别人用（导出表），所以运行时它理应是第一个载入内存中的，而DLL之类的PE文件则一定是需要重定位表的，因为它并不一定会加载在ImageBase上。</p>
<blockquote>
<p>当一个进程的内存空间中放进了一个A模块，占用了0x100000-0x1FFFFF的地址，但是本来B模块应该被放在这里，而这里已经被A模块占用，所以B模块只能放到A的后面，从0x200000开始。恰好B进程中有一个<code>x = 0x11</code>：</p>
</blockquote>
<blockquote>
<p><img src="/2024/03/20/PE/image-20240517150718844.png" alt="image-20240517150718844"></p>
</blockquote>
<blockquote>
<p>这里的B模块一旦没有占住它原来的这一段内存，这里的硬编码就会失效，导致程序没法正确的给x赋值。</p>
<p>因此这就需要用重定位表来修正。</p>
<p>重定位表中要记录的就是这些需要修正的地方的地址。</p>
<p>所以有了重定位表，就不用担心这段程序如果没占住他的ImageBase会不会出问题</p>
</blockquote>
<p><img src="/2024/03/20/PE/image-20240517152658313.png" alt="image-20240517152658313"></p>
<p>重定位表的位置信息与导入表、导出表一样，在扩展PE头最后一个成员中的第6个结构体，结构体的成员与导入表、导出表一样，分别表示重定位表的RVA和Size</p>
<img src="/2024/03/20/PE/image-20240516205416126.png" alt="image-20240516205416126" style="zoom:65%;">

<p>重定位表中有一个结构体，它一共有8字节：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_IMAGE_BASE_RELOCATION</span> &#123;</span><br><span class="line">    DWORD VirtualAddress; ``<span class="comment">// RVA</span></span><br><span class="line">    DWORD SizeOfBlock;</span><br><span class="line">&#125; IMAGE_BASE_RELOCATION;</span><br><span class="line"><span class="keyword">typedef</span> IMAGE_BASE_RELOCATION ，* PIMAGE_BASE_RELOCATION;</span><br></pre></td></tr></table></figure>

<p>但是完整的重定位表还包含了很多重定位项，所以整体大小是没有一个统一标准的，需要根据实际情况。该结构体的第一个成员VirtualAddress表示基地址，<strong>第二个成员SizeOfBlock也就是减去当前结构体的大小之后其他的所有重定位项加起来的大小。</strong></p>
<p>这也就表示每一个重定位表是IMAGE_BASE_RELOCATION结构体开始，跟着的就是重定位项。</p>
<p>从理论上来说，重定位表中存储的项应该都是4字节大小的地址，但是这样一旦需要修改的地址多了，就会占用大量的空间，所以重定位表就做了一些优化，假设你现在有这几个地址需要修正：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x800123</span><br><span class="line">0x800456</span><br><span class="line">0x800789</span><br></pre></td></tr></table></figure>

<p>那么优化之后，IMAGE_BASE_RELOCATION结构体的第一个成员存储的就是0x800000，而这个结构体之后的每2字节存储就包含0x123、0x456、0x789，这样就大大的节省了空间。同时，这也就说明重定位表的实际大小为IMAGE_BASE_RELOCATION结构体（8字节）+N*2字节。</p>
<p>重定位表是按照一个物理页（4KB）进行存储的，也就表示一个4KB内存有需要修正的位置，就会有一个重定位块，一个重定位表只管自己当前的物理页的重定位。</p>
<p>但需要注意的是由于内存对齐的缘故，在重定位表中还是有很多的无用项的，<strong>所以需要判断当前重定位项（2字节）的高四位是否为3，如果是那么低12位就是偏移量，最后的地址也就是VirtualAddress+低12位，如果不是就表示这是无所谓的值。</strong></p>
<h2 id="PE实践"><a href="#PE实践" class="headerlink" title="PE实践"></a>PE实践</h2><h3 id="注入ShellCode"><a href="#注入ShellCode" class="headerlink" title="注入ShellCode"></a>注入ShellCode</h3><p>什么事ShellCode？不依赖环境，放到任何地方都可以执行的机器码。如果机器码具备这个特征，就可以称之为ShellCode。</p>
<p>ShellCode编写原则</p>
<p>&lt;1&gt; 不能有全局变量</p>
<p>&lt;2&gt; 不能使用常量字符串</p>
<p>如果ShellCode中写的是</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> Injstr[] = <span class="string">&quot;ShellCode&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>这样的代码在反汇编中程序会先把吧ShellCode放到常量区，然后用的时候再将这个字符串的地址复制出来。但是ShellCode不能依赖常量区，所以应该换一种方式直接将这个字符串放到堆栈中。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> Injstr[] = &#123;<span class="string">&#x27;S&#x27;</span>,<span class="string">&#x27;h&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;C&#x27;</span>,<span class="string">&#x27;o&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;\0&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>

<p>这样写出来的代码在汇编中就会直接放到堆栈中，而不是放在常量区。</p>
<p>&lt;3&gt; 不能使用系统调用</p>
<p>解决方案：</p>
<p>​		FS:[0] -&gt; TEB</p>
<p>​		FS:[0x30] -&gt; PEB</p>
<p>找到PEB后<img src="/2024/03/20/PE/image-20240519090745097.png" alt="image-20240519090745097"></p>
<p>在找到其中的+0xc的位置，找到右边这个结构体，找到右侧这三个链表。</p>
<p><img src="/2024/03/20/PE/image-20240519091248845.png" alt="image-20240519091248845"></p>
<p>这样就可以通过DLL的名字找到自己想要的DLL（Unicode）</p>
<p>比如要找LoadLibrary或者GetProcAddress这两个函数，这两个函数时kernel32,dll里面的函数，所以要找到LoadLibrary要先找到kernel32这个dll</p>
<p>然后可以遍历上面这个结构体，遍历+0x24这个地方如果是kernel32.dll的话，就把+0x18这里的DllBase拿过来，就找到了kernel32.dll模块的基地址</p>
<p>比如LoadLibrary(“user32.dll”)得到一个句柄，这个返回的句柄就是这个模块的基地址。</p>
<p>所以现找TEB，再找PEB，然后找到三个链表，再遍历链表，找到kernel32.dll，找到kernel32.dll了之后还不能直接使用，还要找到这个函数在什么地方</p>
<p>因为PE文件有一张导出表，并且已经找到了kenel32.dll的首地址，所以通过找内存能找到kernel32的导出表，然后通过查询导出表，就能找到需要用的函数。然后只要有了LoadLibrary和GetProcAddress这两个函数，想找到其他的函数就都行了。这样就能做到在自己的函数中不依赖导入表，想用谁就用谁</p>
<p>&lt;4&gt; 不能嵌套调用其他函数</p>
<blockquote>
<p>第二个和第三个其实是可以解决掉的</p>
</blockquote>
<h3 id="HOOK"><a href="#HOOK" class="headerlink" title="HOOK"></a>HOOK</h3><p>什么是HOOK，HOOK是用来获取、更改程序执行时的某些数据，或者是用于更改程序执行流程的一种技术。</p>
<p>HOOK的两种主要形式：</p>
<p>1.该函数代码 -&gt; INLINE HOOK</p>
<p>2.改函数地址<br>IAT HOOK<br>SSDT HOOK<br>IDT HOOK<br>EAT HOOK<br>IRP HOOK<br>……</p>
<p>​							</p>
<h3 id="IAT-HOOK"><a href="#IAT-HOOK" class="headerlink" title="IAT HOOK"></a>IAT HOOK</h3><p>IAT（Import Address Table）导入地址表HOOK。</p>
<p>比如在一个程序中有一个MessageBox，现在使用HOOK将MessageBox中的值改调，或者让这个程序在执行MessageBox的时候执行自己的一个函数，这时候就用IAT HOOK。</p>
<p><img src="/2024/03/20/PE/image-20240519103431074.png" alt="image-20240519103431074"></p>
<p>比如这样一个间接调用，call后面跟的是一个ptr，一块内存。此时可以HOOK将这个内存地址中存储的函数地址改成自己函数的地址。</p>
<p><strong>IAT HOOK步骤：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、在Dll里构造Detour函数(也就是我们自己的函数)</span><br><span class="line">2、获取Target函数地址，并找到Target函数所在的IAT的地址</span><br><span class="line">3、保存原始的IAT地址和IAT地址所存储的内容</span><br><span class="line">4、修改IAT地址中的数据(前提：修改内存属性为可写)</span><br><span class="line">5、恢复IAT</span><br></pre></td></tr></table></figure>



<h3 id="INLINE-HOOK"><a href="#INLINE-HOOK" class="headerlink" title="INLINE HOOK"></a>INLINE HOOK</h3><p>IAT Hook缺点：</p>
<p>&lt;1&gt; 容易被检测到</p>
<p>&lt;2&gt; 只能Hook IAT表里面的函数 -&gt; 有50个WindowsAPI的函数，还有50个自己写的函数，这些自己写的函数就没法Hook，因为自己写的函数在IAT表中是没有的。</p>
<p>INLINE HOOK就是直接修改exe的硬编码。</p>
<p>比如现在有一个程序：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">plus</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> a;</span><br><span class="line">	a = x + y;</span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, plus(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">	system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过Hook修改plus()函数执行时，堆栈中的值。使2+3&#x3D; 5。</p>
<p><img src="/2024/03/20/PE/image-20240523102541164.png" alt="image-20240523102541164"></p>
<p>从这个call开始修改，让这里先jmp到0x30194A这里，执行自己的代码</p>
<img src="/2024/03/20/PE/image-20240523102621892.png" alt="image-20240523102621892" style="zoom:50%;">

<p>有三个字节没有被占用，所以用nop填充</p>
<img src="/2024/03/20/PE/image-20240523104330985.png" alt="image-20240523104330985" style="zoom:50%;">

<p>因为jmp跳转之后不会改变esp的值，所以跳完之后直接esp和esp+0x4直接找到两个push进来的值，直接对这两个值进行修改。</p>
<p>修改两个值：<img src="/2024/03/20/PE/image-20240523105118207.png" alt="image-20240523105118207"></p>
<p>因为本来覆盖了一句汇编call 0xxxxxxx所以在这里要把它先填回来。</p>
<p><img src="/2024/03/20/PE/image-20240523105329269.png" alt="image-20240523105329269"></p>
<p>修改完之后再jmp执行回来。</p>
<p>最终改完就是这样<img src="/2024/03/20/PE/image-20240523111015872.png" alt="image-20240523111015872"></p>
<p>执行完后，堆栈中变成了0x3和0x4</p>
<p><img src="/2024/03/20/PE/image-20240523111057776.png" alt="image-20240523111057776"></p>
<p><img src="/2024/03/20/PE/image-20240523111531311.png" alt="image-20240523111531311"></p>
<p>执行后就是0x7</p>
<p>原理是这样，需要用代码来实现。</p>
<p>还是以MessageBoxA来举例。这里HookMessageBoxA这个函数</p>
<p>代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">DWORD jump = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">__declspec(naked) <span class="type">void</span> <span class="title function_">Transfer</span><span class="params">()</span>&#123;</span><br><span class="line">	__asm&#123;</span><br><span class="line">		mov edi, edi</span><br><span class="line">		push ebp</span><br><span class="line">		mov ebp, esp</span><br><span class="line">		mov ebx, jump</span><br><span class="line">		jmp ebx</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> APIENTRY <span class="title function_">DllMain</span><span class="params">(HANDLE handle, DWORD dword, LPVOID lpvoid)</span></span><br><span class="line">&#123;</span><br><span class="line">	HMODULE hwnd = GetModuleHandle(TEXT(<span class="string">&quot;user32.dll&quot;</span>));</span><br><span class="line">	DWORD base = (DWORD)GetProcAddress(hwnd, <span class="string">&quot;MessageBoxA&quot;</span>);</span><br><span class="line">	DWORD oldProtect = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (VirtualProtect((LPVOID)base, <span class="number">5</span>, PAGE_EXECUTE_READWRITE, &amp;oldProtect))</span><br><span class="line">	&#123;</span><br><span class="line">		DWORD value = (DWORD)Transfer - base - <span class="number">5</span>;</span><br><span class="line">		jump = base + <span class="number">0x1a</span>;</span><br><span class="line">		__asm&#123;</span><br><span class="line">			mov eax, base</span><br><span class="line">			mov byte ptr[eax], <span class="number">0xe9</span></span><br><span class="line">			inc eax</span><br><span class="line">			mov ebx, value</span><br><span class="line">			mov dword ptr[eax], ebx</span><br><span class="line">		&#125;</span><br><span class="line">		VirtualProtect((LPVOID)base, <span class="number">5</span>, oldProtect, &amp;oldProtect);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再比如hook修改MessageBoxA的标题：</p>
<p>MessageBoxA在设置窗口标题时会使用SetWindowTextA这个API函数，可以通过Hook这个函数，并修改这个函数调用时的值，从而实现指定窗口的标题，</p>
<p>代码实现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">DWORD jump = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">__declspec(naked) <span class="type">bool</span> _stdcall <span class="title function_">Transfer</span><span class="params">(HWND hwnd, LPCSTR lpString)</span>&#123;</span><br><span class="line">	__asm&#123;</span><br><span class="line">		mov edi, edi</span><br><span class="line">		push ebp</span><br><span class="line">		mov ebp, esp</span><br><span class="line">		mov ebx, jump</span><br><span class="line">		jmp ebx</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> __stdcall <span class="title function_">MySetWindowTextA</span><span class="params">(HWND hwnd, LPCSTR lpString)</span>&#123;</span><br><span class="line">	<span class="type">char</span> * lpText = <span class="string">&quot;LyShark 破解版&quot;</span>;</span><br><span class="line">	<span class="keyword">return</span> Transfer(hwnd, lpText);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> APIENTRY <span class="title function_">DllMain</span><span class="params">(HANDLE handle, DWORD dword, LPVOID lpvoid)</span></span><br><span class="line">&#123;</span><br><span class="line">	HMODULE hwnd = GetModuleHandle(TEXT(<span class="string">&quot;user32.dll&quot;</span>));</span><br><span class="line">	DWORD base = (DWORD)GetProcAddress(hwnd, <span class="string">&quot;SetWindowTextA&quot;</span>);</span><br><span class="line">	DWORD oldProtect = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (VirtualProtect((LPVOID)base, <span class="number">5</span>, PAGE_EXECUTE_READWRITE, &amp;oldProtect))</span><br><span class="line">	&#123;</span><br><span class="line">		DWORD value = (DWORD)MySetWindowTextA - base - <span class="number">5</span>;</span><br><span class="line">		jump = base + <span class="number">5</span>;</span><br><span class="line">		__asm&#123;</span><br><span class="line">			mov eax, base</span><br><span class="line">			mov byte ptr[eax], <span class="number">0xe9</span></span><br><span class="line">			inc eax</span><br><span class="line">			mov ebx, value</span><br><span class="line">			mov dword ptr[eax], ebx</span><br><span class="line">		&#125;</span><br><span class="line">		VirtualProtect((LPVOID)base, <span class="number">5</span>, oldProtect, &amp;oldProtect);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><a href="https://www.cnblogs.com/LyShark/p/11692436.html">C&#x2F;C++ Inline Hook 钩子编写技巧 - lyshark - 博客园 (cnblogs.com)</a></p>
<h3 id="INLINE-HOOK-改进版"><a href="#INLINE-HOOK-改进版" class="headerlink" title="INLINE HOOK 改进版"></a>INLINE HOOK 改进版</h3><p>当自己需要写的函数非常复杂的时候，比如想要打印一个字符串，这时候用纯汇编自己编写就非常复杂。所以采用调用函数的方法。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">MyMessageBox</span><span class="params">(HWND hwnd, LPCSTR lpText, LPCSTR lpCaption, UINT uType)</span></span><br><span class="line">&#123;</span><br><span class="line">	TCHAR szBuffer[<span class="number">0x100</span>];</span><br><span class="line">	<span class="built_in">sprintf</span>(szBuffer,<span class="string">&quot;%x %s %s %x \n&quot;</span>, hwnd, lpText, lpCaption, uType);</span><br><span class="line">	OutputDebugString(szBuffer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> __declspec(naked) NewMessageBox()</span><br><span class="line">&#123;</span><br><span class="line">	__asm</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 1.保存寄存器</span></span><br><span class="line">		pushad</span><br><span class="line">		pushfd</span><br><span class="line">        <span class="comment">// 2.调用处理函数</span></span><br><span class="line">        push DWORD PTR SS:[esp+<span class="number">0x28</span>]</span><br><span class="line">        push DWORD PTR SS:[esp+<span class="number">0x30</span>]</span><br><span class="line">        push DWORD PTR SS:[esp+<span class="number">0x38</span>]</span><br><span class="line">        push DWORD PTR SS:[esp+<span class="number">0x40</span>]</span><br><span class="line">        call MyMessageBox</span><br><span class="line">        add esp, <span class="number">0x10</span></span><br><span class="line">        <span class="comment">// 3.恢复寄存器</span></span><br><span class="line">        popfd</span><br><span class="line">        popad</span><br><span class="line">        <span class="comment">// 4.执行覆盖的代码</span></span><br><span class="line">        mov edi, edi</span><br><span class="line">        push ebp</span><br><span class="line">        mov ebp, esp</span><br><span class="line">        <span class="comment">// 5.返回执行</span></span><br><span class="line">        push dwHookAddress</span><br><span class="line">        add dword ptr ds:[esp], PATCH_LENGTH</span><br><span class="line">        retn</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>INLINE HOOK检测</strong></p>
<p>过E9检测，因为在INLINE Hook中一般使用jmp跳转到某个指定的地方来执行自己的指令，而jmp的机器码就是E9，所以可以改为使用CALL + RET的方法避免E9的检测，不过这也只是最简单的一种检测的攻防。</p>
<h3 id="HOOK攻防"><a href="#HOOK攻防" class="headerlink" title="HOOK攻防"></a>HOOK攻防</h3><p>HOOK攻防常用手段</p>
<p>阶段一：</p>
<p>​		（防）检测JMP(E9)、检测跳转范围</p>
<p>​		（破）绕</p>
<p>阶段二：</p>
<p>​		（防）写一个进程，对自己的代码进行全代码校验、CRC校验</p>
<p>​		（破）修改监测代码、挂起检测函数</p>
<p>阶段三：进程A检测进程B，进程B检测进程C，进程C检测进程D，进程D进行全代码校验。</p>
<p>​		（防）先对相关API全代码校验，多个线程互相检测，并检测线程是否在活动中</p>
<p>​		（破）使用瞬时钩子&#x2F;硬件钩子</p>
<h3 id="瞬时HOOK过检测"><a href="#瞬时HOOK过检测" class="headerlink" title="瞬时HOOK过检测"></a>瞬时HOOK过检测</h3>]]></content>
      <categories>
        <category>PE</category>
      </categories>
      <tags>
        <tag>PE</tag>
        <tag>汇编</tag>
      </tags>
  </entry>
  <entry>
    <title>c++</title>
    <url>/2024/02/28/c-1/</url>
    <content><![CDATA[<h1 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h1><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><h3 id="封装-1"><a href="#封装-1" class="headerlink" title="封装"></a>封装</h3><p>将函数定义到结构体内部，就是封装</p>
<h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><p>带有函数的结构体称为类</p>
<h3 id="成员函数"><a href="#成员函数" class="headerlink" title="成员函数"></a>成员函数</h3><p>结构体里面的函数，称为成员函数</p>
<h3 id="this关键字"><a href="#this关键字" class="headerlink" title="this关键字"></a>this关键字</h3><p>当在一个类中，有一个成员函数</p>
<span id="more"></span>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyStruct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">int</span> a;</span><br><span class="line">	<span class="type">int</span> b;</span><br><span class="line">	<span class="type">int</span> c;</span><br><span class="line">	<span class="type">int</span> d;</span><br><span class="line">	<span class="type">int</span> <span class="title function_">init</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c, <span class="type">int</span> d)</span></span><br><span class="line">	&#123;</span><br><span class="line">		a = a;</span><br><span class="line">		b = b;</span><br><span class="line">		c = c;</span><br><span class="line">		d = d;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当用<code>a=a</code>时，编译器不能知道a是参数a还是类中的a。</p>
<p>所以用this关键字</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyStruct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">int</span> a;</span><br><span class="line">	<span class="type">int</span> b;</span><br><span class="line">	<span class="type">int</span> c;</span><br><span class="line">	<span class="type">int</span> d;</span><br><span class="line">	<span class="type">int</span> <span class="title function_">init</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c, <span class="type">int</span> d)</span></span><br><span class="line">	&#123;</span><br><span class="line">		this-&gt;a = a;</span><br><span class="line">		this-&gt;b = b;</span><br><span class="line">		this-&gt;c = c;</span><br><span class="line">		this-&gt;d = d;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为this关键字指向的是结构体的首地址，所以this-&gt;a就指的是这个成员函数所在的类中的一个成员变量，而不是成员函数中的参数</p>
<p>总结：1.this指针时编译器默认传入的，通常会使用ECX寄存器进行传递</p>
<p>2.成员函数都有this指针，无论是否使用，都会有这个指针</p>
<p>3.this指针不能做加减运算，也不能被重新赋值</p>
<p>4.this指针不占用结构体的宽度</p>
<h2 id="构造函数与析构函数"><a href="#构造函数与析构函数" class="headerlink" title="构造函数与析构函数"></a>构造函数与析构函数</h2><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>构造函数不能有返回值，构造函数的名字跟类名相同</p>
<p>有构造函数时，当创建一个对象时，构造函数会直接被调用</p>
<p><strong>总结：</strong></p>
<p>1.与类名同名并且没有返回值</p>
<p>2.创建对象时执行，主要用于初始化</p>
<p>3.可以有多个相同的构造函数，最好是有一个无参的，称为函数重载，其他的函数也可以重载</p>
<p>4.编译器不需求必须提供，但是提供时必须不能加返回值</p>
<h3 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h3><p>析构函数也不允许写返回值类型，析构函数只能写一个，不能重载，并且必须无参，不能带参数</p>
<p>构造函数是创建对象的时候执行，而析构函数是当这个对象被销毁时才执行<br>也就是当函数要return返回值时，析构函数会被执行</p>
<p><strong>总结：</strong></p>
<p>1.只能有一个析构函数，不能重载</p>
<p>2.不能带任何参数</p>
<p>3.不能带返回值</p>
<p>4.主要用于清理工作</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">	<span class="type">int</span> level;</span><br><span class="line">	<span class="type">char</span>* arr;</span><br><span class="line">	</span><br><span class="line">	Person(<span class="type">int</span> age, <span class="type">int</span> level)</span><br><span class="line">	&#123;</span><br><span class="line">		this-&gt;age = age;</span><br><span class="line">		this-&gt;level = level;</span><br><span class="line">		arr = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="number">1024</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	~Person()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;析构函数执行了...&quot;</span>);</span><br><span class="line">		<span class="built_in">free</span>(arr)</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 其他函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5.编译器不要求必须提供</p>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>有一个Teacher类，一个Person类。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">	<span class="type">int</span> gender;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Teacher</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">	<span class="type">int</span> gender;</span><br><span class="line">	<span class="type">int</span> level;</span><br><span class="line">	<span class="type">int</span> teacherID;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>发现Teacher类中有两个和Person类中是一样的，为了减少代码的重复，可以让Teacher继承Person的一些性质（age、gender）。也就是：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Teacher</span>:</span>Person</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> level;</span><br><span class="line">	<span class="type">int</span> teacherID;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里，Person类称为父类或基类；Teacher类称为子类或者派生类</p>
<p><strong>但是，</strong>当父类和子类中有相同的数据时，比如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">	<span class="type">int</span> gender;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Teacher</span>:</span>Person</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">	<span class="type">int</span> level;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当Teacher类继承了Person类时，其中的age重复了，但是编译器仍然会给这两个age都开辟空间</p>
<p>当使用时：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	Teacher t;</span><br><span class="line">	t.Person::age = <span class="number">20</span>;			<span class="comment">//这里就是父类Person类中的age</span></span><br><span class="line">	t.age = <span class="number">25</span>;					<span class="comment">//这里就是子类Teacher类中的age</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>继承不仅限于父类</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">X</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">int</span> a;</span><br><span class="line">	<span class="type">int</span> b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Y</span>:</span>X</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> c;</span><br><span class="line">	<span class="type">int</span> d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">z</span>:</span>Y</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> e;</span><br><span class="line">	<span class="type">int</span> f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当使用时，Z类中能够继承到所有的a,b,c,d</p>
<p><strong>多重继承</strong></p>
<p>与上面类似：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Z</span>:</span>X,Y</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> e;</span><br><span class="line">	<span class="type">int</span> f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>多重继承增加了程序的复杂度，不建议使用。</p>
<h2 id="在堆中创建对象"><a href="#在堆中创建对象" class="headerlink" title="在堆中创建对象"></a>在堆中创建对象</h2><p>堆中创建对象的两种方式：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Person* p = (Person*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Person)*<span class="number">10</span>);</span><br><span class="line">Person* p = new Person[<span class="number">10</span>];</span><br></pre></td></tr></table></figure>

<p>释放对象占用内存对应的两种方式：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line">delete[] p;</span><br></pre></td></tr></table></figure>

<p>当使用malloc函数分配空间时，创建对象后不会调用构造函数，使用free()函数后也不会调用析构函数。</p>
<p>当使用new关键字创建对象时，会调用构造函数，并在使用delete释放对象占用内存时会调用析构函数。</p>
<h2 id="面向对象程序设计之封装和继承"><a href="#面向对象程序设计之封装和继承" class="headerlink" title="面向对象程序设计之封装和继承"></a>面向对象程序设计之封装和继承</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span>(disable:26495)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">private:</span><br><span class="line">    <span class="type">int</span> Age;</span><br><span class="line">    <span class="type">int</span> Gender;</span><br><span class="line">public:</span><br><span class="line">    Person()</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    Person(<span class="type">int</span> Age, <span class="type">int</span> Gender)</span><br><span class="line">    &#123;</span><br><span class="line">        this-&gt;Age = Age;</span><br><span class="line">        this-&gt;Gender = Gender;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// public method</span></span><br><span class="line">    	<span class="comment">// Age</span></span><br><span class="line">    <span class="type">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> Age)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (Age &lt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            this-&gt;Age = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            this-&gt;Age = Age;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> this-&gt;Age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    	<span class="comment">//Gender</span></span><br><span class="line">    <span class="type">void</span> <span class="title function_">setGender</span><span class="params">(<span class="type">int</span> Gender)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (Gender &lt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            this-&gt;Gender = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            this-&gt;Gender = Gender;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">getGender</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> this-&gt;Gender;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teacher</span>:</span>public Person</span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">    <span class="type">int</span> Level;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    Teacher()</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    Teacher(<span class="type">int</span> Level, <span class="type">int</span> Age, <span class="type">int</span> Gender):Person(Age, Gender)		 <span class="comment">// 这里如果不在后面加::Person()的话，程序默认会调用Person类中的无参构造函数。</span></span><br><span class="line">    &#123;</span><br><span class="line">        this-&gt;Level = Level;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// public method</span></span><br><span class="line">    	<span class="comment">// Level</span></span><br><span class="line">    <span class="type">void</span> <span class="title function_">setLevel</span><span class="params">(<span class="type">int</span> Level)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (Level &lt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            this-&gt;Level = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            this-&gt;Level = Level;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">getLevel</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> this-&gt;Level;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 创建Teacher对象并传入三个参数</span></span><br><span class="line">    Teacher* A = new Teacher(<span class="number">5</span>, <span class="number">20</span>, <span class="number">1</span>);</span><br><span class="line">    Teacher* B = new Teacher(<span class="number">4</span>, <span class="number">22</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;A =&gt; Age:%d,Level:%d,Gender:%d\n&quot;</span>, A-&gt;getAge(), A-&gt;getLevel(), A-&gt;getGender()); <span class="comment">// 使用get方法获取</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;B =&gt; Age:%d,Level:%d,Gender:%d\n&quot;</span>, B-&gt;getAge(), B-&gt;getLevel(), B-&gt;getGender());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用Teacher中的方法和继承的Person中的方法修改对象A和对象B中的数据</span></span><br><span class="line">    A-&gt;setAge(<span class="number">50</span>);</span><br><span class="line">    A-&gt;setLevel(<span class="number">8</span>);</span><br><span class="line">    B-&gt;setAge(<span class="number">45</span>);</span><br><span class="line">    B-&gt;setLevel(<span class="number">9</span>);</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;A =&gt; Age:%d,Level:%d,Gender:%d\n&quot;</span>, A-&gt;getAge(), A-&gt;getLevel(), A-&gt;getGender());</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;B =&gt; Age:%d,Level:%d,Gender:%d\n&quot;</span>, B-&gt;getAge(), B-&gt;getLevel(), B-&gt;getGender());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A =&gt; Age:20,Level:5,Gender:1</span><br><span class="line">B =&gt; Age:22,Level:4,Gender:0</span><br><span class="line"></span><br><span class="line">A =&gt; Age:50,Level:8,Gender:1</span><br><span class="line">B =&gt; Age:45,Level:9,Gender:0</span><br></pre></td></tr></table></figure>

<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span>		//这是一个抽象类，抽象类不能创建对象</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">public:</span><br><span class="line">    virtual <span class="type">float</span> <span class="title function_">CalcSq</span><span class="params">()</span> = <span class="number">0</span>;		<span class="comment">//因为不同的图形有不同的求面积方式，所以这里仅定义一个纯虚函数，然后由子类中重写这个函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> :</span> public Square		<span class="comment">//继承抽象类</span></span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">    <span class="type">float</span> r;</span><br><span class="line">public:</span><br><span class="line">    Circle(<span class="type">float</span> r)</span><br><span class="line">    &#123;</span><br><span class="line">        this-&gt;r = r;</span><br><span class="line">    &#125;</span><br><span class="line">    virtual <span class="type">float</span> <span class="title function_">CalcSq</span><span class="params">()</span>			<span class="comment">//重写，这一行必须要和父类中的一样</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3.14</span> * r * r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> :</span> public Square</span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">    <span class="type">float</span> x, y;</span><br><span class="line">public:</span><br><span class="line">    Rectangle(<span class="type">float</span> x, <span class="type">float</span> y)</span><br><span class="line">    &#123;</span><br><span class="line">        this-&gt;x = x;</span><br><span class="line">        this-&gt;y = y;</span><br><span class="line">    &#125;</span><br><span class="line">    virtual <span class="type">float</span> <span class="title function_">CalcSq</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> x * y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> <span class="title function_">CalcSq</span><span class="params">(Square* S)</span>			<span class="comment">//这里传递父类指针</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> S-&gt;CalcSq();			<span class="comment">//父类指针可指向子类		////这里体现了多态性</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    Circle <span class="title function_">C</span><span class="params">(<span class="number">2.5</span>)</span>;				<span class="comment">//创建一个对象，参数传递r=2.5</span></span><br><span class="line">    Rectangle <span class="title function_">R</span><span class="params">(<span class="number">4.5</span>, <span class="number">10</span>)</span>;·		<span class="comment">//创建一个对象,参数传递x=4.5,y=10</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Circle:\t\t%f\n&quot;</span>, CalcSq(&amp;C));<span class="comment">//调用函数求面积，函数中传递子类的指针，因为float CalcSq(Square* S)，其中传递的父类指针可以指向子类地址</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Rectangle:\t%f\n&quot;</span>, CalcSq(&amp;R));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h3><p><code>&lt;1&gt;</code>虚函数目的是提供一个统一的接口，被继承的子类重载，以多态的形式被调用。<br><code>&lt;2&gt;</code>如果基类中的函数没有任何实现的意义，那么可以定义成纯虚函数：virtual返回类型函数名（参数列表）&#x3D;0；<br><code>&lt;3&gt;</code>含有纯虚函数的类被称为抽象类(abstract class),不能创建对象。<br><code>&lt;4&gt;</code>虚函数可以被直接使用，也可以被子类(sub class)重载以后以多态的形式调用，而纯虚函数必须在子类(sub class)中实现该函数才可以使用。</p>
<h2 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h2><p><img src="/2024/02/28/c-1/image-20240228230826536.png" alt="image-20240228230826536"></p>
<p>运算符重载也就是给之前的运算符重新起个名字，比如重载一个<code>++</code>，使它被使用时一次+5</p>
<p>当然，这个重载仅在这个类中有用，原本的<code>++</code>还是自增1</p>
<h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><p>使用<code>template &lt;class T&gt;</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">template &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">BubbleSort</span><span class="params">(T arr[], <span class="type">int</span> length)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="type">int</span> j;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; length - i - <span class="number">1</span>; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (arr[j]&gt;arr[j+<span class="number">1</span>])</span><br><span class="line">			&#123;</span><br><span class="line">				T temp = arr[j];</span><br><span class="line">				arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">				arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> arr1[] = &#123; <span class="number">5</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">12</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">5</span>,<span class="number">10</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">9</span> &#125;;</span><br><span class="line">	<span class="type">float</span> arr2[] = &#123; <span class="number">5.2</span>,<span class="number">1.1</span>,<span class="number">3.6</span>,<span class="number">2.5</span>,<span class="number">4.9</span>,<span class="number">8.0</span>,<span class="number">9.4</span>,<span class="number">1.52</span>,<span class="number">7.7</span>,<span class="number">8.2</span>,<span class="number">5.9</span>,<span class="number">10.4</span>,<span class="number">6.012</span>,<span class="number">9.5</span> &#125;;</span><br><span class="line">	BubbleSort&lt;<span class="type">int</span>&gt;(arr1, <span class="keyword">sizeof</span>(arr1)/<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">	BubbleSort&lt;<span class="type">float</span>&gt;(arr2, <span class="keyword">sizeof</span>(arr2)/<span class="keyword">sizeof</span>(<span class="type">float</span>));</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当程序同为冒泡排序，只是数组的数据类型不同时，可以使用模板替换其中的一部分。</p>
<p>模板可以替换各种类型。如果类型时自己定义的，比如定义一个Number类，要给Number类中的成员进行冒泡排序，则需要先运算符重载，使<code>&gt;</code>可以比较Number中成员的大小。</p>
<p>案例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">template &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">BubbleSort</span><span class="params">(T arr[], <span class="type">int</span> length)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; length - i - <span class="number">1</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                T temp = arr[j];</span><br><span class="line">                arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">                arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Number</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">private:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    Number(<span class="type">int</span> x)</span><br><span class="line">    &#123;</span><br><span class="line">        this-&gt;x = x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> operator&gt;(Number&amp; num)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> this-&gt;x &gt; num.x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> arr1[] = &#123; <span class="number">5</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">12</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">5</span>,<span class="number">10</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">9</span> &#125;;</span><br><span class="line">    BubbleSort&lt;<span class="type">int</span>&gt;(arr1, <span class="keyword">sizeof</span>(arr1) / <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"></span><br><span class="line">    Number arr2[] = &#123; Number(<span class="number">5</span>), Number(<span class="number">1</span>), Number(<span class="number">3</span>), Number(<span class="number">2</span>), Number(<span class="number">4</span>), Number(<span class="number">8</span>), Number(<span class="number">9</span>), Number(<span class="number">12</span>), Number(<span class="number">7</span>), Number(<span class="number">8</span>), Number(<span class="number">5</span>), Number(<span class="number">10</span>), Number(<span class="number">6</span>), Number(<span class="number">2</span>), Number(<span class="number">9</span>) &#125;;</span><br><span class="line">    BubbleSort&lt;Number&gt;(arr2, <span class="keyword">sizeof</span>(arr2) / <span class="keyword">sizeof</span>(Number));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="纯虚函数"><a href="#纯虚函数" class="headerlink" title="纯虚函数"></a>纯虚函数</h2><h3 id="什么是纯虚函数"><a href="#什么是纯虚函数" class="headerlink" title="什么是纯虚函数"></a>什么是纯虚函数</h3><p>&lt; 1 &gt; 将成员函数声明为virtual</p>
<p>&lt; 2 &gt;该函数没有函数体（后跟&#x3D;0）</p>
<p>如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CBank</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">public:</span><br><span class="line">	virtual <span class="title function_">double</span><span class="params">(返回值)</span> <span class="title function_">GetAnnualRate</span><span class="params">(函数名)</span><span class="params">()</span><span class="params">(参数列表)</span> = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>&lt; 1 &gt;含有纯虚函数的类，称为抽象类（Abstract Class）</p>
<p>&lt; 2 &gt;抽象类也可以包含普通成员函数</p>
<p>&lt; 3 &gt;抽象类不能实例化</p>
<p>如使用以下方式定义一个对象：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">CBank bank;						<span class="comment">//全局区	栈</span></span><br><span class="line">CBank* pBank = new CBank;		<span class="comment">//堆</span></span><br></pre></td></tr></table></figure>

<p>此时编译器会报错<code>cannot instantiate abstract class due to folowing members(无法实例化一个抽象类)</code></p>
<p>纯虚函数导致了抽象类的存在，抽象类则可以定义规范、定义一些规则<br>比如以下案例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 银行年利率</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CBank</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">public:</span><br><span class="line">	virtual <span class="type">double</span> <span class="title function_">GetAnnualRate</span><span class="params">()</span> = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中国工商银行</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ICBCBank</span> :</span>public CBank</span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">	<span class="type">double</span> m_dPrincipal;</span><br><span class="line">public:</span><br><span class="line">	ICBCBank(<span class="type">double</span> dPrincipal)</span><br><span class="line">	&#123;</span><br><span class="line">		m_dPrincipal = dPrincipal;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">double</span> <span class="title function_">GetAnnualRate</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0.010</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">double</span> <span class="title function_">GetTotalMoney</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> m_dPrincipal + m_dPrincipal * GetAnnualRate();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中国建设银行</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CCBank</span> :</span>public CBank</span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">	<span class="type">double</span> m_dPrincipal;</span><br><span class="line">public:</span><br><span class="line">	CCBank(<span class="type">double</span> dPrincipal)</span><br><span class="line">	&#123;</span><br><span class="line">		m_dPrincipal = dPrincipal;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">double</span> <span class="title function_">GetAnnualRate</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0.015</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">double</span> <span class="title function_">GetTotalMoney</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> m_dPrincipal + m_dPrincipal * GetAnnualRate();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ShowAnnualRate</span><span class="params">(CBank* pBank[], DWORD nLength)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nLength; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%.5lf \n&quot;</span>, pBank[i]-&gt;GetAnnualRate());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	ICBCBank <span class="title function_">icbc</span><span class="params">(<span class="number">10000.0</span>)</span>;</span><br><span class="line">	<span class="type">double</span> dMoney1 = icbc.GetTotalMoney();</span><br><span class="line">	CCBank <span class="title function_">ccb</span><span class="params">(<span class="number">10000.0</span>)</span>;</span><br><span class="line">	<span class="type">double</span> dMoney2 = ccb.GetTotalMoney();</span><br><span class="line"></span><br><span class="line">	CBank* pBank[] = &#123; &amp;icbc,&amp;ccb &#125;;</span><br><span class="line">	ShowAnnualRate(pBank, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个案例中，银行都继承了CBank这个抽象类，这个抽象类中的纯虚函数定义了子类应该如何获取年利率，因此子类需要重写这个函数。</p>
<p>而它存在的意义就是，当我们需要获取所有的银行的年利率时，有一个这样统一的规范可以将所有银行的年利率统一起来，使用<code>void ShowAnnualRate(CBank* pBank[], DWORD nLength)</code>来让父类指向子类。</p>
<p>这都是站在使用的角度来说。</p>
<h2 id="对象拷贝-拷贝构造函数"><a href="#对象拷贝-拷贝构造函数" class="headerlink" title="对象拷贝-拷贝构造函数"></a>对象拷贝-拷贝构造函数</h2><h3 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h3><img src="/2024/02/28/c-1/image-20240229083940206.png" alt="image-20240229083940206" style="zoom: 67%;">

<p>拷贝构造函数时，如果子类有继承的父类对象，父类也会被继承过来</p>
<img src="/2024/02/28/c-1/image-20240229085147294.png" alt="image-20240229085147294" style="zoom:67%;">

<h3 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Object</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">private:</span><br><span class="line">	<span class="type">int</span> m_nLength;</span><br><span class="line">	<span class="type">char</span>* m_strBuffer;</span><br><span class="line">public:</span><br><span class="line">	Object() &#123;&#125;</span><br><span class="line">	Object(<span class="type">const</span> <span class="type">char</span>* str)</span><br><span class="line">	&#123;</span><br><span class="line">		m_nLength = <span class="built_in">strlen</span>(str) + <span class="number">1</span>;</span><br><span class="line">		m_strBuffer = new <span class="type">char</span>[m_nLength];</span><br><span class="line">		<span class="built_in">memset</span>(m_strBuffer, <span class="number">0</span>, m_nLength);</span><br><span class="line">		<span class="built_in">strcpy</span>(m_strBuffer, str);</span><br><span class="line">	&#125; </span><br><span class="line">	~Object()</span><br><span class="line">	&#123;</span><br><span class="line">		delete[] m_strBuffer;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	Object <span class="title function_">Obj</span><span class="params">(<span class="string">&quot;Hello World&quot;</span>)</span>;</span><br><span class="line">	Object <span class="title function_">newObj</span><span class="params">(Obj)</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>像这样拷贝一个对象，在类中传递了一个指针，当拷贝这个指针时，不会拷贝指针指向地址中存储的数据，而是会拷贝这个指针。</p>
<p>所以当原对象空间被释放时，会把后来拷贝的对象的空间一块释放掉，导致程序错误</p>
<p>这个程序拷贝完之后，发现拷贝后类中的字符串指向的地址是相同的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">newObj	&#123;m_nLength=12 m_strBuffer=0x00c8a640 &quot;Hello World&quot; &#125;	Object</span><br><span class="line"></span><br><span class="line">Obj	&#123;m_nLength=12 m_strBuffer=0x00c8a640 &quot;Hello World&quot; &#125;	Object</span><br></pre></td></tr></table></figure>

<p>这两个字符串指向的是同一个地址<code>0x00c8a640</code>，当第一个对象地址释放时，拷贝的对象中的字符串也会被释放。</p>
<h3 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h3><p>基于上面这种情况，要自己写一个拷贝构造函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Object</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">private:</span><br><span class="line">	<span class="type">int</span> m_nLength;</span><br><span class="line">	<span class="type">char</span>* m_strBuffer;</span><br><span class="line">public:</span><br><span class="line">	Object() &#123;&#125;</span><br><span class="line">	Object(<span class="type">const</span> <span class="type">char</span>* str)</span><br><span class="line">	&#123;</span><br><span class="line">		m_nLength = <span class="built_in">strlen</span>(str) + <span class="number">1</span>;</span><br><span class="line">		m_strBuffer = new <span class="type">char</span>[m_nLength];</span><br><span class="line">		<span class="built_in">memset</span>(m_strBuffer, <span class="number">0</span>, m_nLength);</span><br><span class="line">		<span class="built_in">strcpy</span>(m_strBuffer, str);</span><br><span class="line">	&#125;</span><br><span class="line">	Object(<span class="type">const</span> Object&amp; obj)		<span class="comment">//这里是拷贝构造函数，传入的参数必须是和类相同的对象类型。参数必须是Object&amp;</span></span><br><span class="line">	&#123;</span><br><span class="line">		m_nLength = obj.m_nLength;</span><br><span class="line">		m_strBuffer = new <span class="type">char</span>[m_nLength];	<span class="comment">//开辟了一块新的空间存储拷贝的值</span></span><br><span class="line">		<span class="built_in">memset</span>(m_strBuffer, <span class="number">0</span>, m_nLength);</span><br><span class="line">		<span class="built_in">strcpy</span>(m_strBuffer, obj.m_strBuffer);</span><br><span class="line">	&#125;</span><br><span class="line">	~Object()</span><br><span class="line">	&#123;</span><br><span class="line">		delete[] m_strBuffer;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	Object <span class="title function_">Obj</span><span class="params">(<span class="string">&quot;Hello World&quot;</span>)</span>;</span><br><span class="line">	Object <span class="title function_">newObj</span><span class="params">(Obj)</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这时候再看拷贝后的地址</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Obj	&#123;m_nLength=12 m_strBuffer=0x013ca640 &quot;Hello World&quot; &#125;	Object</span><br><span class="line">newObj	&#123;m_nLength=12 m_strBuffer=0x013ca678 &quot;Hello World&quot; &#125;	Object</span><br></pre></td></tr></table></figure>

<p>一个是<code>0x013ca640</code>，一个是<code>0x013ca678</code>，这样当第一个释放空间的时候，第二个拷贝的对象不受影响。</p>
<h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OutClass</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">private:</span><br><span class="line">	<span class="type">int</span> a;</span><br><span class="line">	<span class="type">int</span> b;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">InnerClassPrivate</span></span></span><br><span class="line"><span class="class">	&#123;</span></span><br><span class="line">	private:</span><br><span class="line">		<span class="type">int</span> x;</span><br><span class="line">		<span class="type">int</span> y;</span><br><span class="line">	public:</span><br><span class="line">		InnerClassPrivate()&#123;&#125;</span><br><span class="line">		InnerClassPrivate(<span class="type">int</span> x, <span class="type">int</span> y)</span><br><span class="line">		&#123;</span><br><span class="line">			this-&gt;x = x;</span><br><span class="line">			this-&gt;y = y;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">	OutClass() &#123;&#125;</span><br><span class="line">	OutClass(<span class="type">int</span> a, <span class="type">int</span> b)</span><br><span class="line">	&#123;</span><br><span class="line">		this-&gt;a = a;</span><br><span class="line">		this-&gt;b = b;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">void</span> <span class="title function_">Fn</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		InnerClassPrivate <span class="title function_">In</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	OutClass <span class="title function_">Out</span><span class="params">(<span class="number">5</span>, <span class="number">6</span>)</span>;</span><br><span class="line">	OutClass::InnerClassPrivate(<span class="number">7</span>, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>内部类就是定义在一个类内部的类，可以将内部类定义在外部类的public中，从外部使用<code>OutClass::InnerCLass();</code>可以进行访问。</p>
<p>如果内部类只在这个外部类中使用，则可以定义在这个类的private中，让外部无法访问或者也可以提供使用函数。内部类也可以定义在函数中，比如定义在OutClass的Fn()中。</p>
<p>内部类不会占用外部类的空间。外部类有<code>int a; int b;</code>，其中内部类中有<code>int x</code>，则外部类的大小仍然是8字节。</p>
<h2 id="namespace命名空间"><a href="#namespace命名空间" class="headerlink" title="namespace命名空间"></a>namespace命名空间</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">namespace ns1 &#123;</span><br><span class="line">	<span class="type">int</span> a;</span><br><span class="line">	<span class="type">int</span> <span class="title function_">Fn</span><span class="params">(<span class="type">int</span> x)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> x + <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">NameSpace</span></span></span><br><span class="line"><span class="class">	&#123;</span></span><br><span class="line">	private:</span><br><span class="line">		<span class="type">int</span> i;</span><br><span class="line">		<span class="type">int</span> j;</span><br><span class="line">		NameSpace() &#123;&#125;</span><br><span class="line">		NameSpace(<span class="type">int</span> i, <span class="type">int</span> j)</span><br><span class="line">		&#123;</span><br><span class="line">			this-&gt;i = i;</span><br><span class="line">			this-&gt;j = j;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">namespace ns2 &#123;</span><br><span class="line">	<span class="type">int</span> a;</span><br><span class="line">	<span class="type">int</span> <span class="title function_">Fn</span><span class="params">(<span class="type">int</span> x)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> x + <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">NameSpace</span></span></span><br><span class="line"><span class="class">	&#123;</span></span><br><span class="line">	private:</span><br><span class="line">		<span class="type">int</span> i;</span><br><span class="line">		<span class="type">int</span> j;</span><br><span class="line">		NameSpace() &#123;&#125;</span><br><span class="line">		NameSpace(<span class="type">int</span> i, <span class="type">int</span> j)</span><br><span class="line">		&#123;</span><br><span class="line">			this-&gt;i = i;</span><br><span class="line">			this-&gt;j = j;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	ns1::a = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ns2::Fn(<span class="number">8</span>));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>命名空间中的变量、函数、类等的名称可以相同，当调用时，用<code>namespace::成员名</code>来使用。</p>
<p>如果是创建了一个类文件，在头文件中声明后，可以用using namespace 命名空间来让整个程序直接使用指定命名空间中的成员。</p>
<h2 id="static关键字"><a href="#static关键字" class="headerlink" title="static关键字"></a>static关键字</h2><h3 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h3><h4 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h4><p>static关键字修饰的变量相当于一个私有的全局变量</p>
<p>比如有这样的一个类：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">`<span class="class"><span class="keyword">class</span> <span class="title">staClass</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">private:</span><br><span class="line">public :</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> a;</span><br><span class="line">	<span class="type">int</span> b;</span><br><span class="line">	<span class="type">int</span> c;</span><br><span class="line">	staClass() &#123;&#125;</span><br><span class="line">	staClass(<span class="type">int</span> b, <span class="type">int</span> c)</span><br><span class="line">	&#123;</span><br><span class="line">		this-&gt;b = b;</span><br><span class="line">		this-&gt;c = c;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中变量a用static修饰，所以在staClass这个类中，a是一个属于staClass私有的全局变量，可以直接进行访问，但是不能从外部访问。</p>
<h4 id="2"><a href="#2" class="headerlink" title="2."></a>2.</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">public :</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> z;</span><br><span class="line">	<span class="type">int</span> a;</span><br><span class="line">	<span class="type">int</span> b;</span><br><span class="line">	Demo() &#123;&#125;</span><br><span class="line">	Demo(<span class="type">int</span> a, <span class="type">int</span> b)</span><br><span class="line">	&#123;</span><br><span class="line">		this-&gt;a = a;</span><br><span class="line">		this-&gt;b = b;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> <span class="title function_">SetZ</span><span class="params">(<span class="type">int</span> z)</span></span><br><span class="line">	&#123;</span><br><span class="line">		this-&gt;z = z;</span><br><span class="line">		<span class="keyword">return</span> z;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> <span class="title function_">GetZ</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> z;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> Demo::z;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	Demo <span class="title function_">d1</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span>;</span><br><span class="line">	Demo <span class="title function_">d2</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span>;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> temp = d1.SetZ(<span class="number">5</span>);</span><br><span class="line">	<span class="type">int</span> temp2 = d2.GetZ();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码中，int z用static修饰，所以z属于这个类中的全局变量，当使用d1对象访问和使用d2对象访问时，访问的是同一个z的地址。</p>
<h3 id="static单子模式"><a href="#static单子模式" class="headerlink" title="static单子模式"></a>static单子模式</h3><p>当要限制创建一个对象时，可以使用static函数进行限制。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">One</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">private:</span><br><span class="line">	One() &#123;&#125;		<span class="comment">//1.首先要将无参构造函数私有，使从外部不能直接创建对象</span></span><br><span class="line">	<span class="type">static</span> One* SetUpPoint;		<span class="comment">//3.创建一个静态成员，类型是One指针类型</span></span><br><span class="line">public:</span><br><span class="line">	<span class="type">static</span> One* <span class="title function_">Setup</span><span class="params">()</span>		<span class="comment">//2.提供一个静态函数，因为static修饰的函数从外部可以被访问</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (SetUpPoint == <span class="literal">NULL</span>)		<span class="comment">//5.当这个指针是空指针时，就创建一个对象</span></span><br><span class="line">			SetUpPoint = new One();</span><br><span class="line">		<span class="keyword">return</span> SetUpPoint;			<span class="comment">//6.将创建的这个指针返回</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">One* One::SetUpPoint = <span class="literal">NULL</span>;		<span class="comment">//4.初始化静态成员为空指针</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	One* p1 = One::Setup();</span><br><span class="line">	One* p2 = One::Setup();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="面向对象设计中的static之静态成员函数："><a href="#面向对象设计中的static之静态成员函数：" class="headerlink" title="面向对象设计中的static之静态成员函数："></a>面向对象设计中的static之静态成员函数：</h3><p><strong>总结：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;1&gt;出现在类体外的函数定义不能指定关键字static；</span><br><span class="line">&lt;2&gt;静态成员之间可以相互访问，包括静态成员函数访问静态数据成员和访问静态成员函数；</span><br><span class="line">&lt;3&gt;非静态成员函数可以任意地访问静态成员函数和静态数据成员；</span><br><span class="line">&lt;4&gt;静态成员函数不能访问非静态成员函数和非静态数据成员；</span><br><span class="line">&lt;5&gt;调用类的静态成员函数的两种方式；</span><br><span class="line">		&lt;类名&gt;::&lt;静态成员函数名&gt;（&lt;参数表&gt;）</span><br><span class="line">		&lt;对象名&gt;.&lt;静态成员函数名&gt;(&lt;参数表&gt;)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>c</title>
    <url>/2023/12/15/c/</url>
    <content><![CDATA[<h1 id="C"><a href="#C" class="headerlink" title="C"></a>C</h1><h2 id="C基础"><a href="#C基础" class="headerlink" title="C基础"></a>C基础</h2><h3 id="一、c语言分步编译"><a href="#一、c语言分步编译" class="headerlink" title="一、c语言分步编译"></a>一、c语言分步编译</h3><p>1.预处理：宏定义展开 头文件展开 条件编译 去注释</p>
<p>2.汇编 检查语法 将C语言转变成汇编语言</p>
<p>3.汇编 将汇编语言转成机器语言</p>
<p>4.链接 将C语言依赖库链接到程序中</p>
<p><img src="/2023/12/15/c/image-20231204140915723.png" alt="image-20231204140915723"></p>
<span id="more"></span>

<img src="/2023/12/15/c/image-20231204141249224.png" alt="image-20231204141249224" style="zoom: 67%;">

<h4 id="一步编译"><a href="#一步编译" class="headerlink" title="一步编译"></a>一步编译</h4><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">gcc -o hello.exe hello1.c hello2.c</span><br></pre></td></tr></table></figure>

<h4 id="常见代码异常"><a href="#常见代码异常" class="headerlink" title="常见代码异常"></a>常见代码异常</h4><p>1.编辑时异常</p>
<p>2.编译时异常</p>
<p>3.运行时异常</p>
<h4 id="程序执行过程"><a href="#程序执行过程" class="headerlink" title="程序执行过程"></a>程序执行过程</h4><p><img src="/2023/12/15/c/image-20231204142152340.png" alt="image-20231204142152340"></p>
<h3 id="二、汇编语言和程序调试"><a href="#二、汇编语言和程序调试" class="headerlink" title="二、汇编语言和程序调试"></a>二、汇编语言和程序调试</h3><img src="/2023/12/15/c/image-20231204145742260.png" alt="image-20231204145742260" style="zoom:50%;">

<p><img src="/2023/12/15/c/image-20231204145845807.png" alt="image-20231204145845807"></p>
<blockquote>
<h4 id="汇编语言"><a href="#汇编语言" class="headerlink" title="汇编语言"></a>汇编语言</h4><p>mov 移动<br>add 添加<br>push 压栈<br>pop 出栈<br>call 调用<br>eax 32位寄存器<br>简单的加法计算</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov a, 3</span><br><span class="line">mov b, 4</span><br><span class="line">mov eax, a </span><br><span class="line">add eax, b</span><br><span class="line">mov c, eax</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>快捷键：<br>断点 F9<br>调试 F5<br>逐语句执行 F11<br>逐过程执行 F10</p>
</blockquote>
<h4 id="寄存器名字"><a href="#寄存器名字" class="headerlink" title="寄存器名字"></a>寄存器名字</h4><p><img src="/2023/12/15/c/image-20231204151902735.png" alt="image-20231204151902735"></p>
<h3 id="三、数据类型"><a href="#三、数据类型" class="headerlink" title="三、数据类型"></a>三、数据类型</h3><img src="/2023/12/15/c/image-20231204152719971.png" alt="image-20231204152719971" style="zoom:67%;">

<h4 id="变量与常量"><a href="#变量与常量" class="headerlink" title="变量与常量"></a>变量与常量</h4><p>1.定义常量名</p>
<p>const 数据类型 常量名 &#x3D; 值;（不建议，不安全</p>
<p>#define 常量名 值;</p>
<p>2.整形变量的定义和输出</p>
<table>
<thead>
<tr>
<th>打印格式</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>%d</td>
<td>输出一个有符号的10进制int类型</td>
</tr>
<tr>
<td>%o</td>
<td>输出8进制的int类型</td>
</tr>
<tr>
<td>%x</td>
<td>输出16进制的int类型，字母以小写输出</td>
</tr>
<tr>
<td>%X</td>
<td>输出16进制的int类型，字母以大写输出</td>
</tr>
<tr>
<td>%u</td>
<td>输出一个10进制的无符号数</td>
</tr>
</tbody></table>
<p>3.进制计算</p>
<h4 id="整形输入"><a href="#整形输入" class="headerlink" title="整形输入"></a>整形输入</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> a;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,a);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>出现报错：</p>
<blockquote>
<p>error C4996: ‘scanf’: This function or variable may be unsafe. Consider using scanf_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS</p>
</blockquote>
<p>解决scanf()安全问题</p>
<p>使用</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br></pre></td></tr></table></figure>

<p>或</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span>(disable:4996)</span></span><br></pre></td></tr></table></figure>

<h4 id="short、int、long、long-long"><a href="#short、int、long、long-long" class="headerlink" title="short、int、long、long long"></a>short、int、long、long long</h4><table>
<thead>
<tr>
<th>数据类型</th>
<th>占用空间</th>
</tr>
</thead>
<tbody><tr>
<td>short</td>
<td>2字节</td>
</tr>
<tr>
<td>int</td>
<td>4字节</td>
</tr>
<tr>
<td>long</td>
<td>Windows为4字节，Linux为4字节(32位)，8字节(64位)</td>
</tr>
<tr>
<td>long long</td>
<td>8字节</td>
</tr>
</tbody></table>
<p>输出时的占位符：</p>
<img src="/2023/12/15/c/image-20231204202543936.png" alt="image-20231204202543936" style="zoom:67%;">

<p>sizeof计算数据类型大小</p>
<img src="/2023/12/15/c/image-20231204203738931.png" alt="image-20231204203738931" style="zoom:50%;">

<h4 id="字符型：char"><a href="#字符型：char" class="headerlink" title="字符型：char"></a>字符型：char</h4><p>定义：char 数据名 &#x3D; ‘字符’;</p>
<p>sizeof(char)  1字节</p>
<p>对应ASCII码表</p>
<h4 id="float-double"><a href="#float-double" class="headerlink" title="float double"></a>float double</h4><img src="/2023/12/15/c/image-20231204205801024.png" alt="image-20231204205801024" style="zoom:50%;">

<p>float和double认为保留小数点后6位是精确的</p>
<p>打印地址编号</p>
<img src="/2023/12/15/c/image-20231204211118884.png" alt="image-20231204211118884" style="zoom: 50%;">

<p>科学计数法打印float：占位符 %e</p>
<img src="/2023/12/15/c/image-20231204211620965.png" alt="image-20231204211620965" style="zoom:67%;">

<p>将科学计数法转换成正常浮点数</p>
<img src="/2023/12/15/c/image-20231204211903963.png" alt="image-20231204211903963" style="zoom:67%;">

<h3 id="四、进制相互转化"><a href="#四、进制相互转化" class="headerlink" title="四、进制相互转化"></a>四、进制相互转化</h3><p><strong>二进制十进制互转：</strong>转低进制，除二反序取余法，转高进制，权值法</p>
<img src="/2023/12/15/c/image-20231204213533505.png" alt="image-20231204213533505" style="zoom: 50%;">

<p><strong>八进制十进制互转：</strong>除八反序取余法，权值法</p>
<img src="/2023/12/15/c/image-20231204214714937.png" alt="image-20231204214714937" style="zoom:50%;">

<p><strong>十进制十六进制互转</strong>：除十六反序取余法</p>
<img src="/2023/12/15/c/image-20231204214848129.png" alt="image-20231204214848129" style="zoom:50%;">

<h5 id="进制转变简单方法"><a href="#进制转变简单方法" class="headerlink" title="进制转变简单方法"></a>进制转变简单方法</h5><p><strong>二进制十进制互转：8421法则</strong></p>
<p>①	11101	16+8+4+0+1&#x3D;29</p>
<p>②	29		29不包含32，从16开始，29-16&#x3D;13，13包含8，13-8&#x3D;5，5包含4，5-4&#x3D;1</p>
<p>​			  所以1 4 8 16分别对应1 100 1000 10000，将这四个数相加得11101</p>
<p><strong>二进制八进制互转：三位一隔</strong></p>
<p>①	11001000100111110101010		从后向前三位一隔	<br>​					11 001 000 100 111 110 101 010<br>​					 3    1     0     4    7     6     5     2</p>
<p>所以11001000100111110101010   &#x3D;&gt;   31047652</p>
<p>②	31047652		将每一位数转换成三位二进制数</p>
<p>​				 3       1        0        4       7        6        5        2<br>​				11    001    000    100    111    110    101    010</p>
<p>​				所以31047652	&#x3D;&gt;	所以11001000100111110101010</p>
<p><strong>二进制十六进制互转：四位一隔</strong></p>
<p>①     7        3          a         b           c<br>​	0111    0011   1010    1011     1100</p>
<p>②0111    0011   1010    1011     1100</p>
<p>​     7        3          a         b           c</p>
<h3 id="五、计算机内存数值存储方式"><a href="#五、计算机内存数值存储方式" class="headerlink" title="五、计算机内存数值存储方式"></a>五、计算机内存数值存储方式</h3><p><strong>原码：</strong></p>
<p>①最高位作为符号位，0为正，1为负<br>②其他数值部分就是数值本身绝对值的二进制数<br>③负数是在绝对值的基础上将最高位变为1</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>+15</td>
<td>0000 1111</td>
</tr>
<tr>
<td>-15</td>
<td>1000 1111</td>
</tr>
<tr>
<td>+0</td>
<td>0000 0000</td>
</tr>
<tr>
<td>-0</td>
<td>1000 0000</td>
</tr>
</tbody></table>
<p>原码表示法简单易懂，与带符号数本身转换比较方便，只要符号还原即可，但是，当两个正数相减或不同符号数相加时，必须比较两个数哪一个绝对值大，才能决定谁减谁，才能决定结果是正是负，所以原码不便于加减运算。</p>
<p><strong>反码：</strong></p>
<p>①对于正数，反码与原码相同</p>
<p>②对于负数，符号位不变，其他部分取反（1,0）</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>+15</td>
<td>0000 1111</td>
</tr>
<tr>
<td>-15</td>
<td>1111 0000</td>
</tr>
<tr>
<td>+0</td>
<td>0000 0000</td>
</tr>
<tr>
<td>-0</td>
<td>1111 1111</td>
</tr>
</tbody></table>
<p>反码运算起来也不方便，通常用来作为求补码的中间过度。</p>
<p><strong>补码：</strong></p>
<p>①对于正数，原码、反码、补码相同<br>②对于负数，补码为它的反码+1<br>③补码符号位不动，其他位求反，最后整个数+1，得到反码</p>
<p><strong>计算：</strong></p>
<p><strong>①</strong>56 - 45  &#x3D;&gt;  56 + （-45）<br>原码：0011 1000<br>反码：0011 1000<br>补码：0011 1000</p>
<p>原码：1010 1101<br>反码：1101 0010<br>补码：1101 0011</p>
<p> 56补码 0011 1000<br>-45补码 1101 0011</p>
<p>56 - 45 补码：1 0000 1011<br>多一位，将第一位舍弃<br>得0000 1011 补码和原码相同 &#x3D;&gt;  11</p>
<p><strong>②</strong>26 - 68<br>原码：0001 1010<br>反码：0001 1010<br>补码：0001 1010</p>
<p>原码：1100 0100<br>反码：1011 1011<br>补码：1011 1100</p>
<p> 26补码：0001 1010<br>-68补码：1011 1100</p>
<p>26 + （-68）<br>补码：1101 0110<br>反码：1101 0101<br>原码：1010 1010  &#x3D;&gt;  -42</p>
<p><strong>数据区间</strong></p>
<p>8bit：-2^7 ~ 2^7-1		-128~127</p>
<p>32bit：-2^31 ~ 2^31-1	-2,147,483,648~2,147,483,647</p>
<p>64bit：-2^63 ~ 2^63-1	-9,223,372,036,854,775,808~9,223,372,036,854,775,807</p>
<p><strong>无符号	数据存储在计算器中不存在符号位</strong><br>unsigned char 0~255</p>
<p>最大值：1111 1111 2^8-1<br>最小值：0000 0000 0</p>
<p>unsigned int 0~4,294,967,295</p>
<p>最大值：1111 1111 1111 1111 1111 1111 1111 1111				2^32-1&#x3D;4,294,967,295<br>最小值：0000 0000 0000 0000 0000 0000 0000 0000		0</p>
<h4 id="数据溢出"><a href="#数据溢出" class="headerlink" title="数据溢出"></a>数据溢出</h4><p>当超出一个数据类型能够存放的最大范围时，数值会溢出</p>
<p>有符号位 最高位溢出的区别：符号位溢出会导致数的正负发生改变，但最高位溢出会导致最高位丢失</p>
<p>如：<img src="/2023/12/15/c/image-20231205151823426.png" alt="image-20231205151823426" style="zoom:50%;"></p>
<h3 id="类型限定"><a href="#类型限定" class="headerlink" title="类型限定"></a>类型限定</h3><table>
<thead>
<tr>
<th>限定符</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>extern</td>
<td>声明一个变量，extern声明的变量没有建立存储空间。extern int a;&#x2F;&#x2F;变量在定义的时候创建存储空间</td>
</tr>
<tr>
<td>const</td>
<td>定义一个常量，常量的值不能修改。<br>const int a &#x3D; 10;</td>
</tr>
<tr>
<td>Volatile</td>
<td>防止编译器优化代码</td>
</tr>
<tr>
<td>register</td>
<td>定义寄存器变量，提高效率。这是建议型指令，而不是命令型指令，如果CPU有空闲寄存器，那么register生效</td>
</tr>
</tbody></table>
<h3 id="printf函数和putchar函数"><a href="#printf函数和putchar函数" class="headerlink" title="printf函数和putchar函数"></a>printf函数和putchar函数</h3><p>printf是输出一个字符串，putchar输出一个char</p>
<p>printf格式字符：</p>
<table>
<thead>
<tr>
<th>打印格式</th>
<th>对应数据类型</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>%d</td>
<td>int</td>
<td>接收整数值并将他表示为有符号的十进制整数</td>
</tr>
<tr>
<td>%hd</td>
<td>short int</td>
<td>短整数</td>
</tr>
<tr>
<td>%hu</td>
<td>unsigned short</td>
<td>无符号短整数</td>
</tr>
<tr>
<td>%o</td>
<td>unsigned int</td>
<td>无符号8进制整数</td>
</tr>
<tr>
<td>%u</td>
<td>unsigned int</td>
<td>无符号10进制整数</td>
</tr>
<tr>
<td>%x,%X</td>
<td>unsigned int</td>
<td>无符号16进制整数，x对应abcdef,X对应ABCDEF</td>
</tr>
<tr>
<td>%f</td>
<td>float</td>
<td>单精度浮点数</td>
</tr>
<tr>
<td>%lf</td>
<td>double</td>
<td>双精度浮点数</td>
</tr>
<tr>
<td>%e,%E</td>
<td>double</td>
<td>科学计数法表示的数，e的大小写代表输出是使用的E的大小写</td>
</tr>
<tr>
<td>%c</td>
<td>char</td>
<td>字符型。可以把输入的数字按照ASCII码相应转换为对应的字符</td>
</tr>
<tr>
<td>%s</td>
<td>char *</td>
<td>字符串。输出字符串中的字符直至字符串中的空字符 <br>（字符串以‘\0结尾，这个\0即空字符’）</td>
</tr>
<tr>
<td>%p</td>
<td>void *</td>
<td>以16进制形式输出指针</td>
</tr>
<tr>
<td>%%</td>
<td>%</td>
<td>输出一个百分号</td>
</tr>
</tbody></table>
<p><strong>printf附加格式：</strong></p>
<img src="/2023/12/15/c/image-20231205190810519.png" alt="image-20231205190810519" style="zoom:50%;">

<img src="/2023/12/15/c/image-20231205191222083.png" alt="image-20231205191222083" style="zoom:50%;">

<img src="/2023/12/15/c/image-20231205192818629.png" alt="image-20231205192818629" style="zoom:50%;">

<h3 id="运算符优先级别"><a href="#运算符优先级别" class="headerlink" title="运算符优先级别"></a>运算符优先级别</h3><img src="/2023/12/15/c/20231205200611.png" alt="20231205200611" style="zoom:50%;">

<h3 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h3><img src="/2023/12/15/c/image-20231205201220882.png" alt="image-20231205201220882" style="zoom:50%;">

<p>强制转换</p>
<p>格式：(数据类型)变量名;</p>
<p>类型转换原则：占用内存字节数少（值域小）的类型，向占用内存字节数多（值域大）的数据类型转换，以保证精度不降低。<br>从占用字节多的数据类型向占用字节数少的数据类型转换时，会降低精度：</p>
<img src="/2023/12/15/c/image-20231205202152032.png" alt="image-20231205202152032" style="zoom:67%;">

<h3 id="程序流程结构"><a href="#程序流程结构" class="headerlink" title="程序流程结构"></a>程序流程结构</h3><h4 id="1-分支结构"><a href="#1-分支结构" class="headerlink" title="1.分支结构"></a>1.分支结构</h4><h5 id="if结构"><a href="#if结构" class="headerlink" title="if结构"></a>if结构</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(condition)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//表达式</span></span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(consition2)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//表达式</span></span><br><span class="line">&#125;<span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//表达式</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="三目运算符"><a href="#三目运算符" class="headerlink" title="三目运算符"></a>三目运算符</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">表达式1?表达式2:表达式3</span><br></pre></td></tr></table></figure>

<p><strong>如果表达式1为真，则用表达式2作为结果，为假用表达式3作为结果</strong></p>
<img src="/2023/12/15/c/image-20231205204226805.png" alt="image-20231205204226805" style="zoom:50%;">

<p>三目运算符的嵌套</p>
<img src="/2023/12/15/c/image-20231205204525348.png" alt="image-20231205204525348" style="zoom:50%;">

<p>使用#define宏定义表达式</p>
<img src="/2023/12/15/c/image-20231205205033609.png" alt="image-20231205205033609" style="zoom:50%;">

<h4 id="2-选择结构"><a href="#2-选择结构" class="headerlink" title="2.选择结构"></a>2.选择结构</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> (switch_on)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> condition1:</span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> condition2:</span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-循环结构"><a href="#3-循环结构" class="headerlink" title="3.循环结构"></a>3.循环结构</h4><h5 id="while循环结构"><a href="#while循环结构" class="headerlink" title="while循环结构"></a>while循环结构</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(condition)&#123;</span><br><span class="line"><span class="comment">//执行语句</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">	<span class="comment">//执行语句</span></span><br><span class="line">&#125;<span class="keyword">while</span>(condition)</span><br></pre></td></tr></table></figure>

<p>do…while可以用于第一句执行条件为假，当第一句执行完后条件为真再进行后面循环的情况。</p>
<h5 id="for循环结构"><a href="#for循环结构" class="headerlink" title="for循环结构"></a>for循环结构</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; value; i++)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>for循环嵌套实例：时钟</em></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">24</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">60</span>; j++) </span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">60</span>; k++)</span><br><span class="line">			&#123;</span><br><span class="line">				system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;%02d:%02d:%02d&quot;</span>,i,j,k);</span><br><span class="line">				Sleep(<span class="number">980</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>实例：九九乘法表</em></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">9</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= i; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%d*%d=%d\t&quot;</span>, j, i, i * j);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-跳转语句"><a href="#4-跳转语句" class="headerlink" title="4.跳转语句"></a>4.跳转语句</h4><h5 id="break语句"><a href="#break语句" class="headerlink" title="break语句"></a>break语句</h5><p>1.在switch中，跳出case并结束switch<br>2.在循环中结束循环<br>3.在嵌套循环中，跳出最近循环</p>
<h5 id="continue语句"><a href="#continue语句" class="headerlink" title="continue语句"></a>continue语句</h5><p>结束本次循环，跳到下一次循环</p>
<p>如只输出偶数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">100</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="goto语句"><a href="#goto语句" class="headerlink" title="goto语句"></a>goto语句</h5><img src="/2023/12/15/c/image-20231206145941501.png" alt="image-20231206145941501" style="zoom:80%;">

<h3 id="六、数组与字符串"><a href="#六、数组与字符串" class="headerlink" title="六、数组与字符串"></a>六、数组与字符串</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>定义数组：数据类型 数组名[元素个数] &#x3D; {值1，值2，值3，……}；</p>
<p><strong>数组在内存中存储方式和大小</strong></p>
<p>数组存储在内存中连续的相同类型鹅变量空间。同一个数组所有的成员都是相同的数据类型，同时所有的成员在内存中的地址是连续的。因此可以通过地址找到数组的下一个</p>
<img src="/2023/12/15/c/image-20231206152557219.png" alt="image-20231206152557219" style="zoom:50%;">

<p><strong>数组名是一个地址常量	指向数组首地址的常量</strong></p>
<img src="/2023/12/15/c/image-20231206153111166.png" alt="image-20231206153111166" style="zoom:50%;">

<p><strong>数组占用内存的大小与数据个数和类型有关</strong></p>
<img src="/2023/12/15/c/image-20231206155931438.png" alt="image-20231206155931438" style="zoom:50%;">

<h4 id="数组逆置"><a href="#数组逆置" class="headerlink" title="数组逆置"></a>数组逆置</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> arr[] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span> &#125;;</span><br><span class="line">	<span class="type">int</span> length = <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> j = length - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (i &lt; j)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> temp = arr[i];</span><br><span class="line">		arr[i] = arr[j];</span><br><span class="line">		arr[j] = temp;</span><br><span class="line"></span><br><span class="line">		i++;</span><br><span class="line">		j--;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; length; k++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,arr[k]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2023/12/15/c/image-20231206185958346.png" alt="image-20231206185958346" style="zoom:50%;">

<h5 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> arr[] = &#123; <span class="number">10</span>,<span class="number">56</span>,<span class="number">48</span>,<span class="number">79</span>,<span class="number">51</span>,<span class="number">46</span>,<span class="number">95</span>,<span class="number">32</span>,<span class="number">65</span>,<span class="number">98</span> &#125;;</span><br><span class="line">	<span class="type">int</span> length = <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length - <span class="number">1</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; length - <span class="number">1</span> - i; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>])</span><br><span class="line">			&#123;</span><br><span class="line">			<span class="type">int</span> temp = arr[j];</span><br><span class="line">			arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">			arr[j + <span class="number">1</span>] = temp;</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h4><p><strong>判断二维数组行数和列数：</strong></p>
<img src="/2023/12/15/c/image-20231206192724601.png" alt="image-20231206192724601" style="zoom:50%;">

<p>** 打印二维数组 **</p>
<img src="/2023/12/15/c/image-20231206192958569.png" alt="image-20231206192958569" style="zoom:50%;">

<h4 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h4><h5 id="三维数组"><a href="#三维数组" class="headerlink" title="三维数组"></a>三维数组</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">数据类型 数组名[层][列][行]</span><br></pre></td></tr></table></figure>

<img src="/2023/12/15/c/image-20231206195845078.png" alt="image-20231206195845078" style="zoom:67%;">

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span>(disable:6328)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> arr[<span class="number">2</span>][<span class="number">3</span>][<span class="number">4</span>] = &#123; <span class="comment">// 一个数组</span></span><br><span class="line">		&#123; <span class="comment">// 第一层</span></span><br><span class="line">			&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;,</span><br><span class="line">			&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;,</span><br><span class="line">			&#123;<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;</span><br><span class="line">		&#125;,</span><br><span class="line">		&#123; <span class="comment">// 第二层</span></span><br><span class="line">			&#123;<span class="number">8</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">5</span>&#125;,</span><br><span class="line">			&#123;<span class="number">7</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">4</span>&#125;,</span><br><span class="line">			&#123;<span class="number">6</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;三维数组大小：%d\n&quot;</span>, <span class="keyword">sizeof</span>(arr));									<span class="comment">//96</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;三维数组每层大小：%d\n&quot;</span>, <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]));							<span class="comment">//48</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;三维数组每层中每行大小：%d\n&quot;</span>, <span class="keyword">sizeof</span>(arr[<span class="number">0</span>][<span class="number">0</span>]));					<span class="comment">//16</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;三维数组每层每行中每个元素的大小：%d\n&quot;</span>, <span class="keyword">sizeof</span>(arr[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>]));		<span class="comment">//4</span></span><br><span class="line">	<span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;层数：%d\n&quot;</span>, <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;行数：%d\n&quot;</span>, <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>][<span class="number">0</span>]));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;列数：%d\n&quot;</span>, <span class="keyword">sizeof</span>(arr[<span class="number">0</span>][<span class="number">0</span>]) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>]);;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="字符数组"><a href="#字符数组" class="headerlink" title="字符数组"></a>字符数组</h4><p>定义字符数组：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">char 数组名[元素个数] = &#123;&#x27;h&#x27;,&#x27;e&#x27;,&#x27;l&#x27;,&#x27;l&#x27;,&#x27;o&#x27;&#125;;</span><br></pre></td></tr></table></figure>

<img src="/2023/12/15/c/image-20231206203151661.png" alt="image-20231206203151661" style="zoom:50%;">

<p>字符串最后一个字符为 \0，所以有6位。</p>
<p><strong>字符串拼接</strong></p>
<img src="/2023/12/15/c/image-20231206211934907.png" alt="image-20231206211934907" style="zoom:50%;">

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span>(disable:6328)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> ch1[] = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">	<span class="type">char</span> ch2[] = <span class="string">&quot;world&quot;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="type">char</span> ch3[<span class="number">20</span>];</span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span> (ch1[i] != <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		ch3[i] = ch1[i];</span><br><span class="line">		i++;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span> (ch2[j] != <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		ch3[i + j] = ch2[j];</span><br><span class="line">		j++;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	ch3[i + j] = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, ch3);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><h5 id="字符串与字符的区别"><a href="#字符串与字符的区别" class="headerlink" title="字符串与字符的区别"></a>字符串与字符的区别</h5><p><strong>C语言中没有字符串这种数据类型，可以通过char的数组来替代：</strong><br>      	字符串一定是一个char的数组，但char的数组未必是字符串；<br>          数字0（和字符’\0’等价）结尾的char数组就是一个字符串，但如果char数组没有以数字0结尾，那么就不是一个字符串，只是普通字符数组，所以字符串是一种特殊的char的数组。</p>
<h5 id="字符串的输入与输出"><a href="#字符串的输入与输出" class="headerlink" title="字符串的输入与输出"></a>字符串的输入与输出</h5><h6 id="gets"><a href="#gets" class="headerlink" title="gets()"></a>gets()</h6><p><strong>1.功能：</strong>从标输入读入字符，并保到指定的内存间，直到出现换行符或读到文件结尾为止。</p>
<p><strong>2.gets(str)与scanf(“%s”,str)的区别：</strong><br>gets(str)允许输入的字符串含有空格<br>scanf(“%s”,str)不允许含有空格</p>
<p>但是scanf()可以通过正则表达式输入带空格的字符串：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%[^\n]&quot;</span>,  ch)</span><br></pre></td></tr></table></figure>

<p>意思是接收非回车以外的所有数值。</p>
<p><strong>注意：</strong>由于scanf()和gets()无法知道字符串s大小，必须遇到换行符或读到文件结尾为止才接收输入，因此容易导致字篮颗组画界（缓冲区溢出）的情况</p>
<h6 id="fgets"><a href="#fgets" class="headerlink" title="fgets()"></a>fgets()</h6><p><strong>1.功能：</strong>从stream指的文件内读入字符，保存轾到所指定的内存空间，直到出现换行字符、读到文件结尾或已读了size-1个字符为止，最后会自动加上字符’\0’作为序符束。</p>
<p>可以接受空格。</p>
<p><strong>2.参数：</strong></p>
<p>​		s：字符串<br>​		size：指定最大读取字符串的长度（size - 1）<br>​		stream：文件指针，如果读键盘输入的字符串，固定写为stdin</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> ch[<span class="number">10</span>];</span><br><span class="line">	fgets(ch, <span class="keyword">sizeof</span>(ch), <span class="built_in">stdin</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, ch);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="puts"><a href="#puts" class="headerlink" title="puts()"></a>puts()</h6><p><strong>功能：</strong>标准设备输出s字符串，在输出完成后自动输出一个’\n’</p>
<h6 id="fputs"><a href="#fputs" class="headerlink" title="fputs()"></a>fputs()</h6><p><strong>1.功能：</strong>将str所指定的字符串写入到stream指定的文件中，字符串结束符’\0’ 不写入文件。</p>
<p><strong>2.参数：</strong></p>
<p>​		str：字符串<br>​		stream：文件指针，如果把字符串输出到屏幕，固定写为stdout</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> ch[] = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">	<span class="built_in">fputs</span>(ch, <span class="built_in">stdout</span>); <span class="comment">//等价于printf(&quot;%s&quot;, ch)</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="strlen"><a href="#strlen" class="headerlink" title="strlen()"></a>strlen()</h6><p><strong>1.功能：</strong>计算字符串长度（有效长度），计算的是第一个\0之前的长度，不包含\0</p>
<p><strong>2.返回值：</strong>返回值为unsigned int类型。</p>
<img src="/2023/12/15/c/image-20231206224553253.png" alt="image-20231206224553253" style="zoom:50%;">

<img src="/2023/12/15/c/image-20231206224718177.png" alt="image-20231206224718177" style="zoom:50%;">


<p>​																				↑↑↑↑↑↑↑		12，因为还有一个\0</p>
<p>使用strlen()函数要导入头文件 #include &lt;string.h&gt;</p>
<p>自己实现字符串长度计算</p>
<img src="/2023/12/15/c/image-20231206225332152.png" alt="image-20231206225332152" style="zoom:50%;">

<p>strlen()</p>
<img src="/2023/12/15/c/image-20231206225420024.png" alt="image-20231206225420024" style="zoom:50%;">

<h3 id="七、函数"><a href="#七、函数" class="headerlink" title="七、函数"></a>七、函数</h3><h5 id="函数调用：产生随机数"><a href="#函数调用：产生随机数" class="headerlink" title="函数调用：产生随机数"></a>函数调用：产生随机数</h5><p>当调用函数时，需要关心5要素：</p>
<p>头文件：包含指定的头文件<br>函数名字：函数名字必须和头文件声明的名字一样<br>功能：需要知道此函数能干啥后才调用。<br>参数：参数类型要匹配<br>返回值：根据需要接收返回值。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="type">time_t</span> <span class="title function_">time</span><span class="params">(<span class="type">time_t</span>*t)</span>;</span><br><span class="line"></span><br><span class="line">功能：获取当前系统时间</span><br><span class="line">参数：常设置为<span class="literal">NULL</span></span><br><span class="line">返回值：当前系统时间<span class="type">time_t</span>相当于<span class="type">long</span>类型，单位为毫秒</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">srand</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> seed)</span>;</span><br><span class="line"></span><br><span class="line">功能：用来设置rand()产生随机数时的随机种子</span><br><span class="line">参数：如果每次设置的seed相等，rand()产生随机数相等</span><br><span class="line">返回值：无</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">rand</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line">功能：返回一个随机数值</span><br><span class="line">参数：无</span><br><span class="line">返回值：随机数</span><br></pre></td></tr></table></figure>

<p><strong>直接产生的随机数</strong></p>
<img src="/2023/12/15/c/image-20231206231811470.png" alt="image-20231206231811470" style="zoom:67%;">

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 添加随机数种子</span></span><br><span class="line">	srand((<span class="type">size_t</span>)time(<span class="literal">NULL</span>));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, rand() % <span class="number">100</span>); <span class="comment">// 产生0~99之间的随机数</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>生成特定范围的随机数</p>
<img src="/2023/12/15/c/image-20231207135553294.png" alt="image-20231207135553294" style="zoom:50%;">

<img src="/2023/12/15/c/image-20231207135640611.png" alt="image-20231207135640611" style="zoom:50%;">

<p>双色球案例：注意去重</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LENGTH 6</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> arr[LENGTH] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	<span class="type">int</span> length = <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 添加随机数种子</span></span><br><span class="line">	srand((<span class="type">size_t</span>)time(<span class="literal">NULL</span>));</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> flag = <span class="number">0</span>;</span><br><span class="line">		<span class="type">int</span> value = rand() % <span class="number">32</span> + <span class="number">1</span>;</span><br><span class="line">		arr[i] = value;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; length; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (value == arr[j])</span><br><span class="line">			&#123;</span><br><span class="line">				flag++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (flag != <span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			i--;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> blue = rand() %<span class="number">16</span> + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;+ %d\n&quot;</span>, blue);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-函数的定义与使用"><a href="#1-函数的定义与使用" class="headerlink" title="1.函数的定义与使用"></a>1.函数的定义与使用</h4><h5 id="函数的定义"><a href="#函数的定义" class="headerlink" title="函数的定义"></a>函数的定义</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">返回值类型 函数名(参数列表)</span><br><span class="line">&#123;</span><br><span class="line">	代码体;</span><br><span class="line">	return 返回值;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义静态函数static与非静态函数，静态函数与非静态函数的<strong>区别</strong>：</p>
<ol>
<li>可见性：<strong>静态函数</strong>只能在<strong>当前文件内使用</strong>，不能被其他文件调用，而<strong>非静态函数</strong>可以被当前文件以外的其他文件调用，具有<strong>全局可见性</strong>。</li>
<li>生命周期：静态函数在程序运行期间一直存在，不会被释放，而非静态函数则是在被调用时动态地创建并在函数返回时被释放，拥有较短的生命周期。</li>
<li>内存分配：非静态函数调用时从堆栈中动态分配内存空间，函数返回时空间被释放，而静态函数分配内存空间仅一次，且在程序运行期间一直存在，调用时并不会重新分配内存空间。</li>
<li>其他：静态函数不能被其他文件调用，因此可以被认为是一种信息隐藏方法，能够有效地维护代码的安全性。同时，在一些对性能要求较高的场景，静态函数相比非静态函数性能更好，因为静态函数的调用时间更短。</li>
</ol>
<p>函数实例：判断字符串是否相等</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> ch1[] = <span class="string">&quot;hallo&quot;</span>;</span><br><span class="line">	<span class="type">char</span> ch2[] = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">	<span class="type">int</span> value = strcompair(ch1, ch2);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (value == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;两个字符串相同&quot;</span>);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;两字符串不相同\t%d\n&quot;</span>, value);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">strcompair</span><span class="params">(<span class="type">char</span> ch1[], <span class="type">char</span> ch2[])</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (ch1[i] == ch2[i])</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 判断是否到了字符串结尾</span></span><br><span class="line">		<span class="keyword">if</span> (ch1[i] == <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//没到结尾继续判断下一位</span></span><br><span class="line">		i++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ch1[i] &gt; ch2[i] ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="2-函数样式"><a href="#2-函数样式" class="headerlink" title="2.函数样式"></a>2.函数样式</h4><p>1.无参函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">function</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.有参函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">function</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-函数的声明"><a href="#3-函数的声明" class="headerlink" title="3.函数的声明"></a>3.函数的声明</h4><p>如果函数定义在主函数之后，则函数需要在主函数之前声明。</p>
<h4 id="4-main函数和exit函数"><a href="#4-main函数和exit函数" class="headerlink" title="4.main函数和exit函数"></a>4.main函数和exit函数</h4><p>exit()函数：结束程序运行</p>
<p>在主函数中，main()，使用return和exit基本没有区别，都会结束程序运行</p>
<p>在函数中，使用return会返回返回值，使用exit()也会停止整个程序</p>
<p>例如：一个程序中有一个加载图片的函数，图片加载不了程序不能正常运行，则此时使用exit()函数使程序终止。</p>
<h3 id="八、多文件编程"><a href="#八、多文件编程" class="headerlink" title="八、多文件编程"></a>八、多文件编程</h3><p><strong>·</strong>可以再头文件中声明函数，在主函数中只导入头文件即可，不用一直声明函数。</p>
<img src="/2023/12/15/c/image-20231207213854267.png" alt="image-20231207213854267" style="zoom:150%;">

<p>自定义函数文件和自定义头文件可以文件名相同，可以方便捋顺程序</p>
<p>自定义的头文件中要写，防止main函数 头文件包含</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br></pre></td></tr></table></figure>

<p>如果头文件包含则会报错：</p>
<img src="/2023/12/15/c/image-20231207215038085.png" alt="image-20231207215038085" style="zoom:67%;">

<p>为了避免同一个文件被include多次，C&#x2F;C++中有两种方式，一种是#ifndef方式，一种是pragma once方式</p>
<p>#pragma once：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="comment">//声明语句</span></span><br></pre></td></tr></table></figure>

<p>#ifndef</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#indef __SOMEFILE_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __SOMEFILE_H__</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明语句</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h3 id="九、指针"><a href="#九、指针" class="headerlink" title="九、指针"></a>九、指针</h3><h4 id="1-定义指针"><a href="#1-定义指针" class="headerlink" title="1.定义指针"></a>1.定义指针</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span>* p;</span><br></pre></td></tr></table></figure>

<p>定义指针时，想存储什么类型的数据就要定义什么类型的指针。</p>
<p><strong>通过指针赋值：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span>* p = &amp;a;</span><br><span class="line">	*p = <span class="number">100</span>; </span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, a);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>运算符</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>*</td>
<td>取值运算符</td>
</tr>
<tr>
<td>&amp;</td>
<td>取地址运算符</td>
</tr>
</tbody></table>
<p>可以通过 &amp;a 取出 a 的地址赋值给指针p，也可以通过 * p 取出指针p所指向的变量存储的值 </p>
<p>指针所占内存大小：</p>
<img src="/2023/12/15/c/image-20231207224226442.png" alt="image-20231207224226442" style="zoom: 67%;">

<img src="/2023/12/15/c/image-20231207224336967.png" alt="image-20231207224336967" style="zoom:67%;">

<p>​                                    <strong>在32位操作系统中，指针大小为4字节</strong>                                          <strong>在64位操作系统中，指针大小为8字节</strong></p>
<h4 id="2-野指针和空指针"><a href="#2-野指针和空指针" class="headerlink" title="2.野指针和空指针"></a>2.野指针和空指针</h4><h5 id="野指针"><a href="#野指针" class="headerlink" title="野指针"></a>野指针</h5><img src="/2023/12/15/c/image-20231207230337071.png" alt="image-20231207230337071" style="zoom:67%;">

<p>所以，存在野指针不会出现错误，但是操作或访问野指针时可能会出错。</p>
<p>不建议把一个变量的值直接赋值给指针。</p>
<h5 id="空指针"><a href="#空指针" class="headerlink" title="空指针"></a>空指针</h5><p> 空指针是指内存地址编号为0的空间</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>* p = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>

<p>空指针也不能访问或操作</p>
<p><strong>应用：</strong>空指针可以用作条件判断</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (p==<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="万能指针-void"><a href="#万能指针-void" class="headerlink" title="万能指针 void*"></a>万能指针 void*</h5><p><strong>所占字节大小</strong></p>
<p>在32为操作系统下占4个字节，在64为操作系统下占8个字节</p>
<p>万能指针可以接受任意类型变量的内存地址</p>
<p>但是通过万能指针操作（访问、修改）所指变量时，必须找到变量对应的指针类型，如：</p>
<img src="/2023/12/15/c/image-20231207232205725.png" alt="image-20231207232205725" style="zoom:67%;">

<p>必须将指针p强制转换为int类型指针：</p>
<img src="/2023/12/15/c/image-20231207232316993.png" alt="image-20231207232316993" style="zoom:67%;">

<h5 id="const修饰的指针类型"><a href="#const修饰的指针类型" class="headerlink" title="const修饰的指针类型"></a>const修饰的指针类型</h5><img src="/2023/12/15/c/image-20231207233230201.png" alt="image-20231207233230201" style="zoom:67%;">
通过指针修改了const修饰的常量



<h6 id="1-const修饰指针类型"><a href="#1-const修饰指针类型" class="headerlink" title="1.const修饰指针类型"></a>1.const修饰指针类型</h6><p>可以修改指针变量的值，不可以修改指针指向内存空进的值。（const离谁近就不能改谁</p>
<h6 id="2-const修饰指针变量"><a href="#2-const修饰指针变量" class="headerlink" title="2.const修饰指针变量"></a>2.const修饰指针变量</h6><p>可以修改指针指向内存空间的值</p>
<h6 id="3-const同时修饰指针类型和指针变量（只读指针）"><a href="#3-const同时修饰指针类型和指针变量（只读指针）" class="headerlink" title="3.const同时修饰指针类型和指针变量（只读指针）"></a>3.const同时修饰指针类型和指针变量（只读指针）</h6><p>当const同时修饰指针类型和指针变量时，可以使用二级指针对一级指针所指的变量进行修改。</p>
<img src="/2023/12/15/c/image-20231207235602859.png" alt="image-20231207235602859" style="zoom:67%;">

<h4 id="3-指针与数组"><a href="#3-指针与数组" class="headerlink" title="3.指针与数组"></a>3.指针与数组</h4><p>指针与数组（p与arr）的区别：</p>
<img src="/2023/12/15/c/image-20231208091528010.png" alt="image-20231208091528010" style="zoom:67%;">

<p>数组arr所指的地址不仅有地址，还包含数组的长度，使用指针p接收arr的地址，p只是一个指针变量，不具有整个数组的长度。</p>
<p><strong>当数组作为函数参数会退化为指针。</strong>变成指针后，一个指针变量的大小为4字节(32位)，丢失了数组的元素个数</p>
<img src="/2023/12/15/c/image-20231208092320722.png" alt="image-20231208092320722" style="zoom: 67%;">

<h4 id="4-指针的加减运算"><a href="#4-指针的加减运算" class="headerlink" title="4.指针的加减运算"></a>4.指针的加减运算</h4><h5 id="1-加法运算"><a href="#1-加法运算" class="headerlink" title="1.加法运算"></a>1.加法运算</h5><p>指针计算不是简单得整数相加，</p>
<p>如果是一个int *，+1的结果是增加一个int的大小；</p>
<p>如果是一个char*，+1的结果是增加一个char大小。</p>
<p><strong>通过指针运算，计算字符串长度。</strong></p>
<img src="/2023/12/15/c/image-20231208094010583.png" alt="image-20231208094010583" style="zoom:67%;">

<p><strong>复制字符串</strong></p>
<img src="/2023/12/15/c/image-20231208095300785.png" alt="image-20231208095300785" style="zoom:67%;">

<h5 id="2-减法运算"><a href="#2-减法运算" class="headerlink" title="2.减法运算"></a>2.减法运算</h5><h2 id="C-汇编"><a href="#C-汇编" class="headerlink" title="C 汇编"></a>C 汇编</h2><h3 id="1-参数与返回值"><a href="#1-参数与返回值" class="headerlink" title="1.参数与返回值"></a>1.参数与返回值</h3><h4 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">返回类型 函数名（参数列表）</span><br><span class="line">&#123;</span><br><span class="line">	return；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>返回类型和参数列表的参数类型，如int(4byte), short(2byte),char(1byte)等用来说明数据宽度是多大</p>
<h4 id="函数返回值"><a href="#函数返回值" class="headerlink" title="函数返回值"></a>函数返回值</h4><img src="/2023/12/15/c/image-20231228141753125.png" alt="image-20231228141753125" style="zoom:67%;">

<img src="/2023/12/15/c/image-20231228141919911.png" alt="image-20231228141919911" style="zoom:67%;">

<p>函数返回后使用eax存储，函数ret后，eax存储的返回值被压到堆栈中。</p>
<h3 id="2-变量"><a href="#2-变量" class="headerlink" title="2.变量"></a>2.变量</h3><h4 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	x = <span class="number">123456</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1)编译的时候就已经确定了内存地址和宽度，变量名就是内存地址的别名。</p>
<p>2)如果不重写编译，全局变量的内存地址不变。游戏外挂中的找“基址”，其实就是找全局变量。</p>
<p>3)全局变量中的值任何程序都可以改，是公用的。</p>
<h4 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">function</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> x = <span class="number">123456</span>;</span><br><span class="line">	<span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	funtion();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1)局部变量是函数内部申请的，如果函数没有执行，那么局部变量没有内存空间。</p>
<p>2)局部变量的内存是在堆栈中分配的，程序执行时才分配。我们无法预知程序何时执行，这也就意味着，我们无法确定局部变量的内存地址。</p>
<p>3)因为局部变量地址内存是不确定的，所以，局部变量只能在函数内部使用，其他函数不能使用。</p>
<h4 id="函数调用的内存布局"><a href="#函数调用的内存布局" class="headerlink" title="函数调用的内存布局"></a>函数调用的内存布局</h4><img src="/2023/12/15/c/image-20231228202155115.png" alt="image-20231228202155115" style="zoom: 50%;">

<h4 id="函数嵌套调用的内存布局"><a href="#函数嵌套调用的内存布局" class="headerlink" title="函数嵌套调用的内存布局"></a>函数嵌套调用的内存布局</h4><h3 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h3><h4 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h4><h5 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h5><p>整数类型的宽度：char short int long</p>
<p>char	8BIT	1字节<br>short	16BIT	2字节<br>int		32BIT	4字节<br>long	32BIT	4字节</p>
<h5 id="浮点类型"><a href="#浮点类型" class="headerlink" title="浮点类型"></a>浮点类型</h5><p>浮点类型的存储格式：float和double在存储方式上都是遵从IEEE编码规范的</p>
<p><img src="/2023/12/15/c/image-20240102144902818.png" alt="image-20240102144902818"></p>
<p><strong>8.25转成浮点存储：整数部分</strong></p>
<p>整数部分8转成2进制<br>8&#x2F;2 &#x3D; 4			0<br>4&#x2F;2 &#x3D; 2			0<br>2&#x2F;2 &#x3D; 1			0<br>1&#x2F;2 &#x3D; 0			1<br>从下往上读，所以8转成2进制是1000</p>
<p><strong>9转2进制：</strong><br>9&#x2F;2 &#x3D; 4			1<br>4&#x2F;2 &#x3D; 2			0<br>2&#x2F;2 &#x3D; 1			0<br>1&#x2F;2 &#x3D; 0			1<br>所以9转2进制是1001</p>
<p>所以，所有的整数部分一定能转成2进制</p>
<p><strong>8.25转2进制：小数部分</strong></p>
<p>小数部分转2进制用乘法</p>
<p>0.25转2进制：<br>0.25 * 2 &#x3D; 0.5		0<br>0.5 * 2 &#x3D; 1.0		1</p>
<p>当小数部分乘出0时停止<br>从上往下读：0.25转成2进制是01</p>
<p><strong>如小数部分0.4转成2进制：</strong><br>0.4 * 2 &#x3D; 0.8		0<br>0.8 * 2 &#x3D; 1.6		1<br>0.6 * 2 &#x3D; 1.2		1<br>0.2 * 2 &#x3D; 0.4		0<br>……</p>
<p>会发现当0.4转成2进制的时候，小数部分永远得不到0，所以用二进制描述小数，不可能做到完全精确</p>
<p><strong>使用IEEE规则存储小数8.25 -&gt; 1000.01 -&gt; 1.00001 * 2(10)^3</strong></p>
<p>第一位是符号位，整数填0负数填1<br>尾数部分00001从前往后填，float类型尾数23位，所以尾数是00001000000000000000000<br>指数部分：当使用科学计数法时，小数点向左移，指数的最高位填1，向右移时填0</p>
<p>因为是3次方，所以3-1&#x3D;2，将2转换为2进制，2 &#x3D;&gt; 10</p>
<p>所以指数最后填10</p>
<p>所以8.25的2进制存储格式为 0 10000010 00001000000000000000000</p>
<p>这个数用16进制表示为 -&gt; 0x41040000</p>
<p><img src="/2023/12/15/c/image-20240102153351929.png" alt="image-20240102153351929"></p>
<h3 id="if-if…else"><a href="#if-if…else" class="headerlink" title="if, if…else"></a>if, if…else</h3><p>if语句在编译器编译后，汇编语句比较灵活</p>
<p><img src="/2023/12/15/c/image-20240104195701535.png" alt="image-20240104195701535"></p>
<p><img src="/2023/12/15/c/image-20240104200120721.png" alt="image-20240104200120721"></p>
<p>当条件为a &gt; b时，汇编指令实际上做的是判断a &lt;&#x3D; b：当a &gt; b时，JLE指令不执行，直接按步执行；当a &lt;&#x3D; b时，执行JLE指令，跳过if中的执行语句。</p>
<p>当条件较简单时，编译器也会将汇编编译成TEST。</p>
<h4 id="if-else"><a href="#if-else" class="headerlink" title="if else"></a>if else</h4><p><img src="/2023/12/15/c/image-20240104200606048.png" alt="image-20240104200606048"></p>
<p>当if中判断不满足条件时，会跳转到else语句内部，当满足条件时，汇编语句会按步向下执行，在else上面的JMP跳过else的执行语句。</p>
<p>所以当判断语句是if…else时，一般中间会有一个JMP指令，用来跳过else执行语句。</p>
<h3 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h3><h4 id="一般的switch"><a href="#一般的switch" class="headerlink" title="一般的switch"></a>一般的switch</h4><p>一般来说，使用switch分支语句比if的执行效率要高。</p>
<img src="/2023/12/15/c/image-20240104230139273.png" alt="image-20240104230139273" style="zoom:50%;">

<img src="/2023/12/15/c/image-20240104230208618.png" alt="image-20240104230208618" style="zoom:50%;">

<p>当情况较少时，使用if和switch的分支语句的执行效率差不多</p>
<p>但当情况较多时，使用switch的执行效率较高：</p>
<img src="/2023/12/15/c/image-20240104230606347.png" alt="image-20240104230606347" style="zoom: 67%;">

<p>发现switch的跳转语句只有上面一点</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">00FA18A8	 8B 45 F8             	mov         eax,dword ptr [a]  </span><br><span class="line">00FA18AB	 89 85 30 FF FF FF    	mov         dword ptr [ebp-0D0h],eax  </span><br><span class="line">00FA18B1	 8B 8D 30 FF FF FF    	mov         ecx,dword ptr [ebp-0D0h]  </span><br><span class="line">00FA18B7	 83 E9 01             	sub         ecx,1  </span><br><span class="line">00FA18BA	 89 8D 30 FF FF FF    	mov         dword ptr [ebp-0D0h],ecx  </span><br><span class="line">00FA18C0	 83 BD 30 FF FF FF 05 	cmp         dword ptr [ebp-0D0h],5  </span><br><span class="line">00FA18C7	 77 67                	ja          $LN15+0Fh (0FA1930h)  </span><br><span class="line">00FA18C9	 8B 95 30 FF FF FF    	mov         edx,dword ptr [ebp-0D0h]  </span><br><span class="line">00FA18CF	 FF 24 95 54 19 FA 00 	jmp         dword ptr [edx*4+0FA1954h]  </span><br></pre></td></tr></table></figure>

<p>switch语句在程序启动时已经在内存中生成了一个“跳转表”，在上面的这段汇编指令中，这个跳转表的地址就是从最后一句的0x0FA1954开始的，所以转到内存中查看这个内存地址：</p>
<img src="/2023/12/15/c/image-20240104231216347.png" alt="image-20240104231216347" style="zoom:50%;">

<img src="/2023/12/15/c/image-20240104231939317.png" alt="image-20240104231939317" style="zoom: 50%;">

<p>在内存地址中刚好存了这一段跳转表。</p>
<p>当跳转时，先有一句</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">00FA18B7	 83 E9 01             	sub         ecx,1</span><br></pre></td></tr></table></figure>

<p>这里减的是switch中最小的那个数，因为原码中写的switch条件是：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">switch</span> (a)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;1111\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;2222\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;3333\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;4444\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;5555\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;6666\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;default\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以最后减完的值会放到EDX中，使用EDX偏移计算要跳转的地址</p>
<p>switch运行速度快的第一点是：判断switch_on与最大的值的大小，当switch_on的值比最大的case还要大时，直接跳出switch</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">00FA18C0	 83 BD 30 FF FF FF 05 	cmp         dword ptr [ebp-0D0h],5  </span><br><span class="line">00FA18C7	 77 67                	ja          $LN15+0Fh (0FA1930h)  </span><br></pre></td></tr></table></figure>

<p>计算完SUB之后，将计算完的值存到EDX寄存器，然后根据EDX计算跳转地址偏移。</p>
<h4 id="当switch之中的值不是连续的"><a href="#当switch之中的值不是连续的" class="headerlink" title="当switch之中的值不是连续的"></a>当switch之中的值不是连续的</h4><p><img src="/2023/12/15/c/image-20240104233957452.png" alt="image-20240104233957452"></p>
<p>c原码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">switch</span> (a)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;1111\n&quot;</span>);</span><br><span class="line">	<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;2222\n&quot;</span>);</span><br><span class="line">	<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;3333\n&quot;</span>);</span><br><span class="line">	<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;4444\n&quot;</span>);</span><br><span class="line">	<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">9</span>:</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;5555\n&quot;</span>);</span><br><span class="line">	<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;6666\n&quot;</span>);</span><br><span class="line">	<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;default\n&quot;</span>);</span><br><span class="line">	<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="当case的值没有规律时"><a href="#当case的值没有规律时" class="headerlink" title="当case的值没有规律时"></a>当case的值没有规律时</h4><p>当case的值不连续且没有啥规律时，再多的case也可能跟if一样，每一个跳转都会有一个JMP</p>
<p>当原码是：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> (a)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;1111\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;2222\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;3333\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">998</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;4444\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">999</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;5555\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1000</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;6666\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;default\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>发现case的值有规律，但是从3到998差了很多，因此用EDX比例因子查内存地址的话，中间要差几百个default的地址，所以在这种情况下也不会使用EDX比例因子找，只会生成一堆JCC跳转指令。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">006A5438 8B 45 F8             mov         eax,dword ptr [a]  </span><br><span class="line">006A543B 89 85 30 FF FF FF    mov         dword ptr [ebp-0D0h],eax  </span><br><span class="line">006A5441 81 BD 30 FF FF FF E6 03 00 00 cmp         dword ptr [ebp-0D0h],3E6h  </span><br><span class="line">006A544B 7F 29                jg          __$EncStackInitStart+0AAh (06A5476h)  </span><br><span class="line">006A544D 81 BD 30 FF FF FF E6 03 00 00 cmp         dword ptr [ebp-0D0h],3E6h  </span><br><span class="line">006A5457 74 64                je          __$EncStackInitStart+0F1h (06A54BDh)  </span><br><span class="line">006A5459 83 BD 30 FF FF FF 01 cmp         dword ptr [ebp-0D0h],1  </span><br><span class="line">006A5460 74 2E                je          __$EncStackInitStart+0C4h (06A5490h)  </span><br><span class="line">006A5462 83 BD 30 FF FF FF 02 cmp         dword ptr [ebp-0D0h],2  </span><br><span class="line">006A5469 74 34                je          __$EncStackInitStart+0D3h (06A549Fh)  </span><br><span class="line">006A546B 83 BD 30 FF FF FF 03 cmp         dword ptr [ebp-0D0h],3  </span><br><span class="line">006A5472 74 3A                je          __$EncStackInitStart+0E2h (06A54AEh)  </span><br><span class="line">006A5474 EB 74                jmp         __$EncStackInitStart+11Eh (06A54EAh)  </span><br><span class="line">006A5476 81 BD 30 FF FF FF E7 03 00 00 cmp         dword ptr [ebp-0D0h],3E7h  </span><br><span class="line">006A5480 74 4A                je          __$EncStackInitStart+100h (06A54CCh)  </span><br><span class="line">006A5482 81 BD 30 FF FF FF E8 03 00 00 cmp         dword ptr [ebp-0D0h],3E8h  </span><br><span class="line">006A548C 74 4D                je          __$EncStackInitStart+10Fh (06A54DBh)  </span><br><span class="line">006A548E EB 5A                jmp         __$EncStackInitStart+11Eh (06A54EAh) </span><br><span class="line"></span><br><span class="line">// 在这上面生成了好多JCC指令用来跳转</span><br><span class="line"></span><br><span class="line">006A5490 68 EC 7C 6A 00       push        offset string &quot;1111\n&quot; (06A7CECh)  </span><br><span class="line">006A5495 E8 38 BC FF FF       call        _printf (06A10D2h)  </span><br><span class="line">006A549A 83 C4 04             add         esp,4  </span><br><span class="line">006A549D EB 58                jmp         __$EncStackInitStart+12Bh (06A54F7h)  </span><br><span class="line">006A549F 68 F4 7C 6A 00       push        offset string &quot;2222\n&quot; (06A7CF4h)  </span><br><span class="line">006A54A4 E8 29 BC FF FF       call        _printf (06A10D2h)  </span><br><span class="line">006A54A9 83 C4 04             add         esp,4  </span><br><span class="line">006A54AC EB 49                jmp         __$EncStackInitStart+12Bh (06A54F7h)  </span><br><span class="line">006A54AE 68 20 7E 6A 00       push        offset string &quot;3333\n&quot; (06A7E20h)  </span><br><span class="line">006A54B3 E8 1A BC FF FF       call        _printf (06A10D2h)  </span><br><span class="line">006A54B8 83 C4 04             add         esp,4  </span><br><span class="line">006A54BB EB 3A                jmp         __$EncStackInitStart+12Bh (06A54F7h)  </span><br><span class="line">006A54BD 68 28 7E 6A 00       push        offset string &quot;4444\n&quot; (06A7E28h)  </span><br><span class="line">006A54C2 E8 0B BC FF FF       call        _printf (06A10D2h)  </span><br><span class="line">006A54C7 83 C4 04             add         esp,4  </span><br><span class="line">006A54CA EB 2B                jmp         __$EncStackInitStart+12Bh (06A54F7h)  </span><br><span class="line">006A54CC 68 30 7E 6A 00       push        offset string &quot;5555\n&quot; (06A7E30h)  </span><br><span class="line">006A54D1 E8 FC BB FF FF       call        _printf (06A10D2h)  </span><br><span class="line">006A54D6 83 C4 04             add         esp,4  </span><br><span class="line">006A54D9 EB 1C                jmp         __$EncStackInitStart+12Bh (06A54F7h)  </span><br><span class="line">006A54DB 68 38 7E 6A 00       push        offset string &quot;6666\n&quot; (06A7E38h)  </span><br><span class="line">006A54E0 E8 ED BB FF FF       call        _printf (06A10D2h)  </span><br><span class="line">006A54E5 83 C4 04             add         esp,4  </span><br><span class="line">006A54E8 EB 0D                jmp         __$EncStackInitStart+12Bh (06A54F7h)  </span><br><span class="line">006A54EA 68 E0 7C 6A 00       push        offset string &quot;default\n&quot; (06A7CE0h)  </span><br><span class="line">006A54EF E8 DE BB FF FF       call        _printf (06A10D2h)  </span><br><span class="line">006A54F4 83 C4 04             add         esp,4 </span><br></pre></td></tr></table></figure>

<p>因此当使用switch时，连续的case会提高代码的执行速度</p>
<h3 id="do…while"><a href="#do…while" class="headerlink" title="do…while"></a>do…while</h3><p>do…while一般用于先执行后判断</p>
<h3 id="for"><a href="#for" class="headerlink" title="for"></a>for</h3><p>for循环在反汇编中的形式</p>
<p><img src="/2023/12/15/c/image-20240108191715316.png" alt="image-20240108191715316"></p>
<p>for循环的执行效率可能不是特别高，但是可读性比较好，比较容易写</p>
<p>for循环的第一个和第三个表达式可以使用逗号连接多个表达式，比如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="type">int</span> j;</span><br><span class="line"><span class="type">int</span> k;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>,j=<span class="number">0</span>,k=<span class="number">0</span>; i&lt;=<span class="number">10</span>, i++,j++,k++)</span><br><span class="line">&#123;</span><br><span class="line">	print(<span class="string">&quot;%d %d %d\n&quot;</span>, i, j, k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="结构体数组"><a href="#结构体数组" class="headerlink" title="结构体数组"></a>结构体数组</h3><h3 id="结构体数组的定义"><a href="#结构体数组的定义" class="headerlink" title="结构体数组的定义"></a>结构体数组的定义</h3><h4 id="定义结构体"><a href="#定义结构体" class="headerlink" title="定义结构体"></a>定义结构体</h4><p><code>类型 变量名[常量表达式]</code></p>
<p>定义结构题类型<br>struct stStudent<br>{<br>    int Age;<br>    int Level;<br>}</p>
<p>定义结构体变量<br>struct stStudent st;</p>
<p>定义结构题数组<br>struct stStudent arr[10] 或者 stStudent arr[10]</p>
<p>结构体数组的赋值</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyStruct</span> <span class="title">arr</span>[3] =</span> &#123; &#123;<span class="number">0</span>,<span class="number">0</span>&#125;,&#123;<span class="number">1</span>,<span class="number">1</span>&#125;,&#123;<span class="number">2</span>,<span class="number">2</span>&#125; &#125;;</span><br><span class="line">或</span><br><span class="line">arr[<span class="number">0</span>].Age = <span class="number">10</span>;</span><br><span class="line">arr[<span class="number">0</span>].Level = <span class="number">100</span>;</span><br></pre></td></tr></table></figure>

<img src="/2023/12/15/c/image-20240227084341723.png" alt="image-20240227084341723" style="zoom:50%;">

<h4 id="结构体数组中字符串成员的处理"><a href="#结构体数组中字符串成员的处理" class="headerlink" title="结构体数组中字符串成员的处理"></a>结构体数组中字符串成员的处理</h4><p><img src="/2023/12/15/c/image-20240227085527133.png" alt="image-20240227085527133"></p>
<h3 id="指针类型"><a href="#指针类型" class="headerlink" title="指针类型"></a>指针类型</h3><p>任何类型都可以带上<code>*</code>，加上<code>*</code>以后是新的类型，统称为“指针类型”。</p>
<p><code>*</code>可以是任意多个。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span>* x;</span><br><span class="line"><span class="type">short</span>* y;</span><br><span class="line"><span class="type">int</span>* z;</span><br><span class="line"><span class="type">float</span>* f;</span><br><span class="line"><span class="type">double</span>* d;</span><br><span class="line">Student* st;（结构体）</span><br></pre></td></tr></table></figure>

<p>指针变量的赋值</p>
<img src="/2023/12/15/c/image-20240227092130958.png" alt="image-20240227092130958" style="zoom:50%;"> 

<img src="/2023/12/15/c/image-20240227092215037.png" alt="image-20240227092215037" style="zoom: 50%;"> 

<p><strong>指针变量宽度</strong></p>
<p>指针类型的变量宽度永远是4字节、无论指针类型是什么，无论是几级指针</p>
<p><strong>指针变量的自加自减</strong></p>
<p>1、不带<code>*</code>类型的变量，++或者–都是加1或者减1<br>2、带<code>*</code>类型的变量，++或者–新增（减少）的数量是去掉一个<code>*</code>后变量的宽度</p>
<p>也就是当指针变量是一级指针时，指针自加后，char类型会加1，short类型会加2.int类型会加4</p>
<p>当指针变量是二级以上时，指针自加后，都会加4，因为这时去掉一个<code>*</code>后，宽度都是指针的宽度4.</p>
<p><strong>指针的加减运算</strong></p>
<p>指针不能进行乘除运算，只能加减。</p>
<p>当指针时多级指针时：</p>
<p><img src="/2023/12/15/c/image-20240227094643479.png" alt="image-20240227094643479"></p>
<p>当指针是一级指针时</p>
<p><img src="/2023/12/15/c/image-20240227094725042.png" alt="image-20240227094725042"></p>
<p>总结：</p>
<img src="/2023/12/15/c/image-20240227094928263.png" alt="image-20240227094928263" style="zoom:33%;"> 

<p><strong>指针取值方式</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(p+i)=p[i]</span><br><span class="line">*(*(p+i)+k)=p[i][k]</span><br><span class="line">*(*(*(p+i)+k)+m)=p[i][k][m]</span><br><span class="line">*(*(*(*(*(p+i)+k)+m)+w)+t)=p[i][k][m][W][t]</span><br><span class="line">*()与[]可以相互转换</span><br></pre></td></tr></table></figure>

<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><h4 id="数组参数传递"><a href="#数组参数传递" class="headerlink" title="数组参数传递"></a>数组参数传递</h4><p>在反汇编中，<code>arr[i]</code>等价于<code>*(p+i)</code>，使用函数传递数组参数时，传递的是数组的首地址，并且传送时不会传递数组的宽度。要使用数组的宽度时，必须要把数组的宽度也传递进去。</p>
<p>在函数中使用数组，如果是按照指针传递的数组，在使用时也可以按照数组来使用；如果是按照数组传递的参数，也可以按照指针的方式来使用。</p>
<h3 id="字符串-1"><a href="#字符串-1" class="headerlink" title="字符串"></a>字符串</h3><h4 id="字符串的定义方式"><a href="#字符串的定义方式" class="headerlink" title="字符串的定义方式"></a>字符串的定义方式</h4><ol>
<li></li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> str[<span class="number">5</span>] = &#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;\0&#x27;</span>&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, str);</span><br></pre></td></tr></table></figure>

<p>程序会找到<code>&#39;\0&#39;</code>或者<code>0</code>来停止寻找字符串</p>
<ol start="2">
<li></li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> str[] = <span class="string">&quot;ABCDEF&quot;</span>;		<span class="comment">// 在常量区找一段空间放，然后在复制到数组中，因为复制到数组中才可以对其进行修改，比如str[0]=‘K&#x27;，然后就变成了&quot;KBCDE&quot;</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li></li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span>* str = <span class="string">&quot;ABCDE&quot;</span></span><br></pre></td></tr></table></figure>

<p>这种方式是将字符串放在了常量区，但是没有复制到字符数组中，所以这样定义的字符串只能读，不能写（也有可以改的方法）</p>
<h4 id="处理字符串函数"><a href="#处理字符串函数" class="headerlink" title="处理字符串函数"></a>处理字符串函数</h4><p><strong>1.int strlrn(char *  str)</strong></p>
<p>返回值是字符串s的长度。不包括结束符’\0’。、</p>
<p><strong>2.char * strcpy(char * dest, char * src);</strong></p>
<p>复制字符串src到dest中，返回值为dest的值。</p>
<p><strong>3.char * strcat(char * dest, char * src);</strong></p>
<p>将字符串src添加到dest尾部，返回值为dest的值。</p>
<p><strong>4.int strcmp(char * str1, char * str2);</strong></p>
<p>一样返回0，不一样返回非0</p>
<h3 id="结构体指针"><a href="#结构体指针" class="headerlink" title="结构体指针"></a>结构体指针</h3><p>首先定义一个结构体</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">int</span> a;</span><br><span class="line">	<span class="type">int</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>给结构体赋值、定义结构体指针</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Point p = &#123; <span class="number">1</span>, <span class="number">2</span> &#125;;</span><br><span class="line">Point* px = &amp;p;</span><br></pre></td></tr></table></figure>

<p>通过指针读取结构体时不用<code>.</code>，而是用<code>-&gt;</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> x = px-&gt;x		| x = <span class="number">1</span></span><br><span class="line"><span class="type">int</span> y = px-&gt;y		| y = <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>通过结构体指针修改结构体成员数值</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">px-&gt;y = <span class="number">100</span>			| y = <span class="number">100</span></span><br></pre></td></tr></table></figure>

<h3 id="指针数组-与-数组指针"><a href="#指针数组-与-数组指针" class="headerlink" title="指针数组 与 数组指针"></a>指针数组 与 数组指针</h3><h4 id="指针数组的赋值"><a href="#指针数组的赋值" class="headerlink" title="指针数组的赋值"></a>指针数组的赋值</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> * a = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="type">char</span> * b = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line"></span><br><span class="line">&lt;<span class="number">1</span>&gt;</span><br><span class="line"><span class="type">char</span> * arr[<span class="number">2</span>] = &#123;a, b&#125;;</span><br><span class="line"></span><br><span class="line">&lt;<span class="number">2</span>&gt;</span><br><span class="line"><span class="type">char</span> * arr[<span class="number">2</span>];</span><br><span class="line">arr[<span class="number">0</span>] = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">arr[<span class="number">1</span>] = <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line"></span><br><span class="line">&lt;<span class="number">3</span>&gt;</span><br><span class="line"><span class="type">char</span> * arr[<span class="number">2</span>] = &#123;</span><br><span class="line">	<span class="string">&quot;Hello&quot;</span>,</span><br><span class="line">	<span class="string">&quot;张三&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="数组指针的定义"><a href="#数组指针的定义" class="headerlink" title="数组指针的定义"></a>数组指针的定义</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>(*px) [<span class="number">5</span>];			<span class="comment">//一维数组指针</span></span><br><span class="line"><span class="type">char</span>(*px) [<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>(*px)[<span class="number">2</span>][<span class="number">2</span>];			<span class="comment">//二维数组指针</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span>(*px)[<span class="number">3</span>][<span class="number">3</span>][<span class="number">3</span>];		<span class="comment">//三维数组指针</span></span><br></pre></td></tr></table></figure>

<p><strong><code>int* p[5]</code>和<code>int (*p)[5]</code>的区别：</strong></p>
<p><code>int* p[5]</code>：<code>[]</code>的优先级高于<code>*</code>，所以<code>int* p[]</code>是一个<code>(int*)</code>类型的指针数组，p本质上是一个<strong>数组</strong>；</p>
<p><code>int (*p)[5]</code>：<code>()</code>的优先级高于<code>[]</code>，所以p先与<code>*</code>结合，是一个指针，指针的类型是一个<code>int[]</code>数组，<code>int (*p)[]</code>是一个数组指针，p本质上是一个<strong>指针</strong>。</p>
<p><strong>???</strong></p>
<p><img src="/2023/12/15/c/image-20240228003021496.png" alt="image-20240228003021496"></p>
<p><img src="/2023/12/15/c/image-20240228004935994.png" alt="image-20240228004935994"></p>
<h3 id="调用约定"><a href="#调用约定" class="headerlink" title="调用约定"></a>调用约定</h3><table>
<thead>
<tr>
<th>调用约定</th>
<th>参数压栈顺序</th>
<th>平衡堆栈方式</th>
</tr>
</thead>
<tbody><tr>
<td>__cdecl</td>
<td>从右至左入栈</td>
<td>调用者清理栈</td>
</tr>
<tr>
<td>__stdcall</td>
<td>从右至左入栈</td>
<td>自身清理堆栈</td>
</tr>
<tr>
<td>__fastcall</td>
<td>ECX&#x2F;EDX传递前两个参数，剩下还多的，从右至左入栈</td>
<td>自身清理堆栈</td>
</tr>
</tbody></table>
<h3 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h3><p><strong>定义函数指针变量：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> (__cdecl *pFun)(<span class="type">int</span>, <span class="type">int</span>);</span><br></pre></td></tr></table></figure>

<p><strong>为指针变量赋值：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">pFun = (<span class="type">int</span> (__cdecl *)(<span class="type">int</span>, <span class="type">int</span>))<span class="number">10</span>;		<span class="comment">// 这里随便赋了一个10，使用时应该赋一个函数的地址</span></span><br></pre></td></tr></table></figure>

<p><strong>使用函数指针变量：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> r = pFun(<span class="number">1</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>汇编</tag>
      </tags>
  </entry>
  <entry>
    <title>汇编</title>
    <url>/2023/12/10/compilation/</url>
    <content><![CDATA[<h1 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h1><h2 id="汇编基础"><a href="#汇编基础" class="headerlink" title="汇编基础"></a>汇编基础</h2><h3 id="二进制与十六进制"><a href="#二进制与十六进制" class="headerlink" title="二进制与十六进制"></a>二进制与十六进制</h3><p>十六进制相当于二进制的简写，可以看成二进制的另一种形式</p>
<table>
<thead>
<tr>
<th>二进制</th>
<th>十六进制</th>
</tr>
</thead>
<tbody><tr>
<td>0000</td>
<td>0</td>
</tr>
<tr>
<td>0001</td>
<td>1</td>
</tr>
<tr>
<td>0010</td>
<td>2</td>
</tr>
<tr>
<td>0011</td>
<td>3</td>
</tr>
<tr>
<td>0100</td>
<td>4</td>
</tr>
<tr>
<td>0101</td>
<td>5</td>
</tr>
<tr>
<td>0110</td>
<td>6</td>
</tr>
<tr>
<td>0111</td>
<td>7</td>
</tr>
<tr>
<td>1000</td>
<td>8</td>
</tr>
<tr>
<td>1001</td>
<td>9</td>
</tr>
<tr>
<td>1010</td>
<td>A</td>
</tr>
<tr>
<td>1011</td>
<td>B</td>
</tr>
<tr>
<td>1100</td>
<td>C</td>
</tr>
<tr>
<td>1101</td>
<td>D</td>
</tr>
<tr>
<td>1110</td>
<td>E</td>
</tr>
<tr>
<td>1111</td>
<td>F</td>
</tr>
</tbody></table>
<h3 id="数据宽度"><a href="#数据宽度" class="headerlink" title="数据宽度"></a>数据宽度</h3><h4 id="数据宽度-1"><a href="#数据宽度-1" class="headerlink" title="数据宽度"></a>数据宽度</h4><span id="more"></span>

<p>  数学上的数字，是没有大小限制的，可以无限的大。但在计算机中，由于受硬件的制约，数据都是有长度限制的（称为数据宽度），超过最多宽度的数据会被丢弃</p>
<h4 id="计算机中常见的数据宽度"><a href="#计算机中常见的数据宽度" class="headerlink" title="计算机中常见的数据宽度"></a>计算机中常见的数据宽度</h4><p>(1)位(BIT) 在计算机中存储数据的最小单位 能存一个1或一个0</p>
<p>(2)字节(Byte) 一个字节能存储8个0或1 范围从00000000<del>11111111 即0</del>0xFF</p>
<p>(3)字(Word) 能存16个0或1 0~0xFFFF</p>
<p>(4)双字(Doubleword) 存储32个0或1 0~0xFFFFFFFF</p>
<p><strong>如果要存储的数据超过最大宽度，那么多余的数据将被丢弃</strong></p>
<h3 id="无符号数"><a href="#无符号数" class="headerlink" title="无符号数"></a>无符号数</h3><p>无符号数的编码规则：数是多少就存多少</p>
<p>1001 1010 &#x3D;&gt; 9A</p>
<p>有符号数的编码规则：最高位是0，则该数为正数；最高位是1，则该数为负数</p>
<p>当该数为正时，编码规则与无符号数相同</p>
<!--more-->

<h3 id="原码，反码，补码"><a href="#原码，反码，补码" class="headerlink" title="原码，反码，补码"></a>原码，反码，补码</h3><h4 id="正数："><a href="#正数：" class="headerlink" title="正数："></a>正数：</h4><p><strong>原码：</strong>最高位为0，其余位为数值本身</p>
<p><strong>反码：</strong>正数的反码与原码相同</p>
<p><strong>补码：</strong>正数的补码与原码相同</p>
<p>6： 0000 0110</p>
<h4 id="负数："><a href="#负数：" class="headerlink" title="负数："></a>负数：</h4><p><strong>原码：</strong>最高位是1，其余位为数值本身的绝对值<br>​	-7： 1000 0111<br><strong>反码：</strong>除最高位，其他位1变0,0变1（除最高位取反）<br>​	-7： 1111 1000<br><strong>补码：</strong>负数的补码为反码+1<br>​	-7： 1111 1001</p>
<h4 id="假设数据宽度为1BYTE（8BIT）"><a href="#假设数据宽度为1BYTE（8BIT）" class="headerlink" title="假设数据宽度为1BYTE（8BIT）"></a>假设数据宽度为1BYTE（8BIT）</h4><p>无符号数：0 1 2 3 4   …………    FF（10进制255）</p>
<p>有符号数：<br>​	正数：0  ……7F</p>
<p>​	负数：FF……80</p>
<h4 id="假设数据宽度为Doubleword（32BIT）"><a href="#假设数据宽度为Doubleword（32BIT）" class="headerlink" title="假设数据宽度为Doubleword（32BIT）"></a>假设数据宽度为Doubleword（32BIT）</h4><p>无符号数：0 1 2 3 4 …… FFFFFFFF</p>
<p>有符号数：<br>​	正数：0 …… 7FFFFFFF</p>
<p>​	负数：FFFFFFFF …… 80000000</p>
<h3 id="计算机如何运算-位运算"><a href="#计算机如何运算-位运算" class="headerlink" title="计算机如何运算 &#x3D;&gt; 位运算"></a>计算机如何运算 &#x3D;&gt; 位运算</h3><p>计算机只认识0和1，计算机只能对0和1做运算（通常称为位运算）</p>
<h4 id="1-与运算"><a href="#1-与运算" class="headerlink" title="1.与运算"></a>1.与运算</h4><p>当两个位都为1时，结果才为1	比如：</p>
<p>​						1011 0001<br>​and(&amp;)		 	1101 1000<br>​———————————-<br>​						1001 0000</p>
<h4 id="2-或运算"><a href="#2-或运算" class="headerlink" title="2.或运算"></a>2.或运算</h4><p>只要有一个为1就是1</p>
<p>​						1011 0001<br>​or(|)			 	1101 1000<br>​———————————-<br>​						1111 1001</p>
<h4 id="3-异或运算"><a href="#3-异或运算" class="headerlink" title="3.异或运算"></a>3.异或运算</h4><p>不一样的时候是1</p>
<p>​						1011 0001<br>​xor(^)			   1101 1000<br>​———————————-<br>​						0110 1001</p>
<h4 id="4-非运算"><a href="#4-非运算" class="headerlink" title="4.非运算"></a>4.非运算</h4><p>0就是1 1就是0</p>
<p>not(~)			   1101 1000<br>​———————————-<br>​				 		0010 0111</p>
<h4 id="5-左移"><a href="#5-左移" class="headerlink" title="5.左移"></a>5.左移</h4><p>各二进位全部左移若干位，高位丢弃，低位补0</p>
<p>shl(&lt;&lt;)		1101 1000 左移2位为：0110 0000</p>
<h4 id="6-右移"><a href="#6-右移" class="headerlink" title="6.右移"></a>6.右移</h4><p>各二进位全部右移若干位，低位丢弃，高位补0或者补符号位</p>
<h5 id="shr"><a href="#shr" class="headerlink" title="shr"></a><strong>shr</strong></h5><p>1101 0101	&#x3D;右移2位&gt;	 0011 0101<br>对应C语言(&gt;&gt;)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, a&gt;&gt;<span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<h5 id="sar"><a href="#sar" class="headerlink" title="sar"></a><strong>sar</strong></h5><p>1101 0101	&#x3D;&gt; 	1111 0101<br>对应C语言(&gt;&gt;)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, a&gt;&gt;<span class="number">2</span>);</span><br></pre></td></tr></table></figure>



<h3 id="通过位运算实现四则运算"><a href="#通过位运算实现四则运算" class="headerlink" title="通过位运算实现四则运算"></a>通过位运算实现四则运算</h3><h4 id="加"><a href="#加" class="headerlink" title="加"></a>加</h4><p>如：4+5的运算过程</p>
<p><strong>1）异或</strong></p>
<p>​				0000 0100<br>​				0000 0101<br>异或———————<br>​				0000 0001</p>
<p><strong>2）判断是否有进位</strong></p>
<p>​				0000 0100<br>​				0000 0101<br>与————————<br>​				0000 0100</p>
<p><strong>3）进位不为零 &#x3D;&gt; 左移</strong></p>
<p>​				0000 0100<br>左移———————-<br>​				0000 1000</p>
<p><strong>4）异或 &#x3D;&gt; 将第一次异或的值与进位后得到的值再异或</strong></p>
<p>​				0000 0001<br>​				0000 1000<br>异或———————-<br>​				0000 1001</p>
<p><strong>5）判断是否有进位</strong></p>
<p>​				0000 0001<br>​				0000 1000<br>与————————<br>​				0000 0000</p>
<p><strong>没有进位，就是加的结果</strong></p>
<h4 id="减"><a href="#减" class="headerlink" title="减"></a>减</h4><p>4-5的运算过程</p>
<p>4-5即4+(-5)</p>
<p><strong>1）异或</strong></p>
<p>​				0000 0100<br>​				1111 1011<br>异或———————-<br>​				1111 1111</p>
<p><strong>2）判断是否有进位</strong></p>
<p>​				0000 0100<br>​				1111 1011<br>与————————<br>​				0000 0000</p>
<p><strong>所以4-5的结果就为1111 1111 &#x3D; FF &#x3D; -1</strong></p>
<h4 id="乘"><a href="#乘" class="headerlink" title="乘"></a>乘</h4><p>X * Y 即X个Y相加</p>
<h4 id="除"><a href="#除" class="headerlink" title="除"></a>除</h4><p>X &#x2F; Y 本质为减法  X能减去多少个Y</p>
<h2 id="汇编-1"><a href="#汇编-1" class="headerlink" title="汇编"></a>汇编</h2><p><img src="/2023/12/10/compilation/image-20231212151255758.png" alt="image-20231212151255758"></p>
<h3 id="1-寄存器"><a href="#1-寄存器" class="headerlink" title="1.寄存器"></a>1.寄存器</h3><p>存储数据  CPU &gt; 内存 &gt; 硬盘</p>
<p>32位CPU：8  16  32<br>64位CPU：8  16  32  64</p>
<h3 id="2-通用寄存器"><a href="#2-通用寄存器" class="headerlink" title="2.通用寄存器"></a>2.通用寄存器</h3><p>32位寄存器：</p>
<p>EAX</p>
<p>ECX</p>
<p>EDX</p>
<p>EBX</p>
<p>ESP</p>
<p>EBP</p>
<p>ESI</p>
<p>EDI</p>
<h3 id="3-MOV指令"><a href="#3-MOV指令" class="headerlink" title="3.MOV指令"></a>3.MOV指令</h3><p>（1）MOV立即数到寄存器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov eax, 1</span><br></pre></td></tr></table></figure>

<p>MOV寄存器到寄存器（将eax存的值赋值到ebx）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov ebx, eax </span><br></pre></td></tr></table></figure>

<img src="/2023/12/10/compilation/image-20231212185902221.png" alt="image-20231212185902221" style="zoom:50%;">





<h3 id="4-16位寄存器，8位寄存器"><a href="#4-16位寄存器，8位寄存器" class="headerlink" title="4.16位寄存器，8位寄存器"></a>4.16位寄存器，8位寄存器</h3><p><img src="/2023/12/10/compilation/image-20231212191059169.png" alt="image-20231212191059169"><br><img src="/2023/12/10/compilation/image-20231212191212571.png" alt="image-20231212191212571" style="zoom:100%;"><br><img src="/2023/12/10/compilation/image-20231212191247696.png" alt="image-20231212191247696"><br><img src="/2023/12/10/compilation/image-20231212191318028.png" alt="image-20231212191318028"><br><img src="/2023/12/10/compilation/image-20231212191335820.png" alt="image-20231212191335820"></p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th>通用寄存器</th>
</tr>
</thead>
<tbody><tr>
<td>32位</td>
<td>16位</td>
<td>8位</td>
</tr>
<tr>
<td>EAX</td>
<td>AX</td>
<td>AL</td>
</tr>
<tr>
<td>ECX</td>
<td>CX</td>
<td>CL</td>
</tr>
<tr>
<td>EDX</td>
<td>DX</td>
<td>DL</td>
</tr>
<tr>
<td>EBX</td>
<td>BX</td>
<td>BL</td>
</tr>
<tr>
<td>ESP</td>
<td>SP</td>
<td>AH</td>
</tr>
<tr>
<td>EBP</td>
<td>BP</td>
<td>CH</td>
</tr>
<tr>
<td>ESI</td>
<td>SI</td>
<td>DH</td>
</tr>
<tr>
<td>EDI</td>
<td>DI</td>
<td>BH</td>
</tr>
</tbody></table>
<p><img src="/2023/12/10/compilation/image-20231212192419732.png" alt="image-20231212192419732"></p>
<p><img src="/2023/12/10/compilation/image-20231212192619129.png" alt="image-20231212192619129"></p>
<p>8位寄存器</p>
<img src="/2023/12/10/compilation/image-20231212192939039.png" alt="image-20231212192939039" style="zoom:50%;">

<img src="/2023/12/10/compilation/image-20231212193232979.png" alt="image-20231212193232979" style="zoom:50%;">

<h3 id="5-内存"><a href="#5-内存" class="headerlink" title="5.内存"></a>5.内存</h3><h4 id="1-每个应用层序都会有自己的独立的4GB内存空间"><a href="#1-每个应用层序都会有自己的独立的4GB内存空间" class="headerlink" title="1.每个应用层序都会有自己的独立的4GB内存空间"></a>1.每个应用层序都会有自己的独立的4GB内存空间</h4><img src="/2023/12/10/compilation/image-20231212194824981.png" alt="image-20231212194824981" style="zoom:50%;">

<h4 id="2-内存地址"><a href="#2-内存地址" class="headerlink" title="2.内存地址"></a>2.内存地址</h4><p>(1)内存太大没法起名字，所以只能用编号。当我们想要向内存中存储数据，或者从内存读取数据时，必须用到这个编号。</p>
<p>(2)这个编号又称为内存地址（32位，前面0可以省略）[0x00000000]</p>
<h5 id="使用内存"><a href="#使用内存" class="headerlink" title="使用内存"></a>使用内存</h5><p><strong>1.存立即数到内存</strong></p>
<p>ptr ds:[   ]   里面写地址编号</p>
<p>地址和通用寄存器不一样，每个应用程序有4GB的内存，但是使用内存之前要先申请，不是可以随便用，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov byte ptr ds:[0xFFFFFFFF], 1</span><br></pre></td></tr></table></figure>

<p><img src="/2023/12/10/compilation/image-20231212210545890.png" alt="image-20231212210545890"></p>
<p>指令中的byte是数据大小，byte只有1字节，如果要写满数据，需要使用双字宽度dword，占4字节</p>
<p>使用word，可以存储2字节</p>
<p><strong>2.将寄存器中的值到内存</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov dword ptr ds:[0x012FB000], eax</span><br></pre></td></tr></table></figure>

<p><img src="/2023/12/10/compilation/image-20231212215444670.png" alt="image-20231212215444670"></p>
<p><strong>3.将内存中的值存到寄存器</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov eax, dword ptr ds:[0x012FAFFC]</span><br></pre></td></tr></table></figure>

<p><img src="/2023/12/10/compilation/image-20231212221448664.png" alt="image-20231212221448664"></p>
<h4 id="3-内存地址的五种形式"><a href="#3-内存地址的五种形式" class="headerlink" title="3.内存地址的五种形式"></a>3.内存地址的五种形式</h4><h5 id="1-形式一：-立即数"><a href="#1-形式一：-立即数" class="headerlink" title="1.形式一：[立即数]"></a>1.形式一：[立即数]</h5><p>读取内存的值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov eax,dword pyr ds:[0x012FAFFC]</span><br></pre></td></tr></table></figure>

<p>向内存中写入数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov dword ptr ds:[0x012FAFFC]</span><br></pre></td></tr></table></figure>

<h5 id="2-形式二：-reg-reg-寄存器"><a href="#2-形式二：-reg-reg-寄存器" class="headerlink" title="2.形式二：[reg] reg &#x3D;&gt; 寄存器"></a>2.形式二：[reg] reg &#x3D;&gt; 寄存器</h5><p>reg代表寄存器，可以是8个通用寄存器中的任意一个</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov dword ptr ds:[eax],ebx</span><br></pre></td></tr></table></figure>

<p>此处，EAX指向一个内存地址”0x012FFCF8”，EBX的值为FFFFFFFF</p>
<p><img src="/2023/12/10/compilation/image-20231212224535417.png" alt="image-20231212224535417"></p>
<h5 id="3-形式三：-reg-立即数"><a href="#3-形式三：-reg-立即数" class="headerlink" title="3.形式三：[reg+立即数]"></a>3.形式三：[reg+立即数]</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov dword ptr ds:[ecx+4],eax</span><br></pre></td></tr></table></figure>

<p>此处ECX指向内存地址DBB000，+4后，[ECX+4]指向DBB004，然后将EAX中的值传到DBB004内存地址</p>
<p><img src="/2023/12/10/compilation/image-20231212230144179.png" alt="image-20231212230144179"></p>
<h5 id="4-形式四：-reg-reg-1-2-4-8"><a href="#4-形式四：-reg-reg-1-2-4-8" class="headerlink" title="4.形式四：[reg + reg * {1,2,4,8} ]"></a>4.形式四：[reg + reg * {1,2,4,8} ]</h5><p>寄存器加寄存器乘1,2,4,8中的一个数，一般C语言中数组生成的汇编语言是这样的</p>
<p>读取内存的值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov eax, 0x13FFc4</span><br><span class="line">mov ebx, 2</span><br><span class="line">mov edx, dword ptr ds:[eax+ebx*2]</span><br></pre></td></tr></table></figure>

<p>向内存中写入数据：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov eax, 0x137B000</span><br><span class="line">mov ecx, 2</span><br><span class="line">mov dword ptr ds:[eax+ecx*4], FFFF0001</span><br></pre></td></tr></table></figure>

<p><img src="/2023/12/10/compilation/image-20231212232344040.png" alt="image-20231212232344040"></p>
<p><img src="/2023/12/10/compilation/image-20231212232757738.png" alt="image-20231212232757738"></p>
<h5 id="5-形式五：-reg-reg-1-2-4-8-立即数"><a href="#5-形式五：-reg-reg-1-2-4-8-立即数" class="headerlink" title="5.形式五：[reg + reg * {1,2,4,8} + 立即数 ]"></a>5.形式五：[reg + reg * {1,2,4,8} + 立即数 ]</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov eax, 0x13FFc4</span><br><span class="line">mov ebx, 2</span><br><span class="line">mov edx, dword ptr ds:[eax+ebx*2+4]</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov eax, 0x137B000</span><br><span class="line">mov ecx, 2</span><br><span class="line">mov dword ptr ds:[eax+ecx*4+4], FFFF0001</span><br></pre></td></tr></table></figure>

<p><img src="/2023/12/10/compilation/image-20231213141111995.png" alt="image-20231213141111995"></p>
<h3 id="6-数据的存储模式"><a href="#6-数据的存储模式" class="headerlink" title="6.数据的存储模式"></a>6.数据的存储模式</h3><p>1.大端模式：数据高位在低位，数据低位在高位</p>
<p>2.小端模式：数据低位在低位，数据高位在高位</p>
<p><img src="/2023/12/10/compilation/image-20231213142908404.png" alt="image-20231213142908404"></p>
<p>大端模式：1A	0x00000000</p>
<p>​				  2C	0x00000001</p>
<p><img src="/2023/12/10/compilation/image-20231213143809023.png" alt="image-20231213143809023"></p>
<p><img src="/2023/12/10/compilation/image-20231213143923697.png" alt="image-20231213143923697"></p>
<p>大端存储或小端存储受编译器影响，可以改成大端或小端</p>
<h3 id="7-常用的汇编指令"><a href="#7-常用的汇编指令" class="headerlink" title="7.常用的汇编指令"></a>7.常用的汇编指令</h3><h4 id="1-MOV指令"><a href="#1-MOV指令" class="headerlink" title="1.MOV指令"></a>1.MOV指令</h4><p>指令格式：<br>1、MOV r&#x2F;m8,r8<br>2、MOV r&#x2F;m16,r16	将寄存器的值存到寄存器或内存<br>3、MOV r&#x2F;m32,r32<br>4、MOV r8,r&#x2F;m8<br>5、MOV r16,r&#x2F;m16<br>6、MOV r32,r&#x2F;m32<br>7、MOV r8,imm8<br>8、MOV r16,imm16<br>9、MOV r32,imm32</p>
<p>r代表通用寄存器，r8代表8位寄存器<br>m代表内存，m8代表8位内存<br>imm代表立即数，imm8代表8位立即数</p>
<h4 id="2-ADD指令（加法指令）"><a href="#2-ADD指令（加法指令）" class="headerlink" title="2.ADD指令（加法指令）"></a>2.ADD指令（加法指令）</h4><p>ADD r&#x2F;m8,imm8<br>ADD r&#x2F;m16,imm16<br>ADD r&#x2F;m32,imm32<br>ADD r&#x2F;m16,imm8<br>ADD r&#x2F;m32,imm8<br>ADD r&#x2F;m8,r8<br>ADD r&#x2F;m16,r16<br>ADD r&#x2F;m32,r32<br>ADD r8,r&#x2F;m8<br>ADD r16,r&#x2F;m16<br>ADD r32,r&#x2F;m32</p>
<h4 id="3-SUB指令（减法指令）"><a href="#3-SUB指令（减法指令）" class="headerlink" title="3.SUB指令（减法指令）"></a>3.SUB指令（减法指令）</h4><p>SUB r&#x2F;m8,imm8<br>SUB r&#x2F;m16,imm16<br>SUB r&#x2F;m32,imm32<br>SUB r&#x2F;m16,imm8<br>SUB r&#x2F;m32,imm8<br>SUB r&#x2F;m8,r8<br>SUB r&#x2F;m16,r16<br>SUB r&#x2F;m32,r32<br>SUB r8,r&#x2F;m8<br>SUB r16,r&#x2F;m16<br>SUB r32,r&#x2F;m32</p>
<h4 id="4-AND指令（与运算）"><a href="#4-AND指令（与运算）" class="headerlink" title="4.AND指令（与运算）"></a>4.AND指令（与运算）</h4><p>AND r&#x2F;m8,imm8<br>AND r&#x2F;m16,imm16<br>AND r&#x2F;m32.imm32<br>AND r&#x2F;m16,imm8<br>AND r&#x2F;m32.imm8<br>AND r&#x2F;m8,r8<br>AND r&#x2F;m16,r16<br>AND r&#x2F;m32.,r32<br>AND r8,r&#x2F;m8<br>AND r16,r&#x2F;m16<br>AND r32,r&#x2F;m32</p>
<h4 id="5-XOR指令（异或运算）"><a href="#5-XOR指令（异或运算）" class="headerlink" title="5.XOR指令（异或运算）"></a>5.XOR指令（异或运算）</h4><p>XOR r&#x2F;m8,imm8<br>XOR r&#x2F;m16,imm16<br>XOR r&#x2F;m32.imm32<br>XOR r&#x2F;m16,imm8<br>XOR r&#x2F;m32,imm8<br>XOR r&#x2F;m8,r8<br>XOR r&#x2F;m16,r16<br>XOR r&#x2F;m32,r32<br>XOR r8,r&#x2F;m8<br>XOR r16.r&#x2F;m16<br>XOR r32,r&#x2F;m32</p>
<h4 id="6-NOT指令（非运算）"><a href="#6-NOT指令（非运算）" class="headerlink" title="6.NOT指令（非运算）"></a>6.NOT指令（非运算）</h4><p>NOT r&#x2F;m8<br>NOT r&#x2F;m16<br>NOT r&#x2F;m32</p>
<h4 id="7-MOVS指令-移动数据从内存到内存"><a href="#7-MOVS指令-移动数据从内存到内存" class="headerlink" title="7.MOVS指令 移动数据从内存到内存"></a>7.MOVS指令 移动数据从内存到内存</h4><p>MOVS BYTE PTR ES:[EDI],BYTE PTR DS:[ESI]	简写为：MOVSB<br>MOVS WORD PTR ES:[EDI],BYTE PTR DS:[ESI]	简写为：MOVSW<br>MOVS DWORD PTR ES:[EDI],BYTE PTR DS:[ESI]	简写为：MOVSD</p>
<p>ESI存储的是一个地址，是一个内存编号，就是要复制的数据在哪里</p>
<p>EDI存储的是一个地址，是要把数据复制到哪里去</p>
<p><strong>标志寄存器 EFL</strong></p>
<p>00000204</p>
<img src="/2023/12/10/compilation/image-20231213214453116.png" alt="image-20231213214453116" style="zoom: 67%;">

<p>第十位为DF位，当DF位为0时，使用MOVS等指令，MOVS完之后，地址会自动递增（从低地址向高地址处理串）</p>
<p>​						当DF位为1时，使用MOVS等指令，MOVS完之后，地址会自动递减（从高地址向低地址处理串）</p>
<img src="/2023/12/10/compilation/20231213215254-1702475722564-2.png" alt="20231213215254" style="zoom:150%;">

<p>地址自动递增（递减）时，移动的长度取决于移动了一个字节、两个字节还是四个字节。</p>
<h4 id="8-STOS指令"><a href="#8-STOS指令" class="headerlink" title="8.STOS指令"></a>8.STOS指令</h4><p>将<strong>al&#x2F;ax&#x2F;eax</strong>的值存储到[EDI]指定的内存单元</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">STOS BYTE PTR ES:[EDI]	每次存一个字节</span><br><span class="line">STOS WORD PTR ES:[EDI]	每次存两个字节</span><br><span class="line">STOS DWORD PTR ES:[EDI]	每次存四个字节</span><br></pre></td></tr></table></figure>

<h4 id="9-REP指令"><a href="#9-REP指令" class="headerlink" title="9.REP指令"></a>9.REP指令</h4><p>按照计数寄存器（ECX）中指定的次数重复执行字符串指令</p>
<p>计数寄存器是ECX，不是别的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MOV ECX,10</span><br><span class="line">REP MOVSD</span><br><span class="line"></span><br><span class="line">MOV STOSD</span><br></pre></td></tr></table></figure>

<p>首先在ECX中存一个数，这个数是十六进制的，如果ECX中存10，则执行16次，每执行一次减一</p>
<h3 id="8-堆栈相关的指令"><a href="#8-堆栈相关的指令" class="headerlink" title="8.堆栈相关的指令"></a>8.堆栈相关的指令</h3><h4 id="1-堆栈"><a href="#1-堆栈" class="headerlink" title="1.堆栈"></a>1.堆栈</h4><p>1）就是一块内存，操作系统在程序启动时已经分配好的，供程序执行时使用。<br>2）和数据结构的堆栈无关<br>3）查看堆栈</p>
<h3 id="2-ESP寄存器（栈指针寄存器）"><a href="#2-ESP寄存器（栈指针寄存器）" class="headerlink" title="2.ESP寄存器（栈指针寄存器）"></a>2.ESP寄存器（栈指针寄存器）</h3><h3 id="3-PUSH指令"><a href="#3-PUSH指令" class="headerlink" title="3.PUSH指令"></a>3.PUSH指令</h3><p>功能： &lt; 1 &gt; 向堆栈中压入数据<br>            &lt; 2 &gt;修改栈顶指针ESP寄存器</p>
<p><img src="/2023/12/10/compilation/image-20231214001525192.png" alt="image-20231214001525192"></p>
<p>执行PUSH指令后：</p>
<p><img src="/2023/12/10/compilation/image-20231214001641026.png" alt="image-20231214001641026"></p>
<p>4被存储在了0x0053FF14中，并且ESP指向了当前的地址，因此PUSH指令是将MOV DWORD PTR DS:[]指令和SUB ESP,0x4简化了</p>
<p>除了PUSH立即数，还能PUSH寄存器</p>
<p><img src="/2023/12/10/compilation/image-20231214002210231.png" alt="image-20231214002210231"></p>
<h3 id="9-EIP寄存器"><a href="#9-EIP寄存器" class="headerlink" title="9.EIP寄存器"></a>9.EIP寄存器</h3><h4 id="JMP"><a href="#JMP" class="headerlink" title="JMP"></a>JMP</h4><p>EIP寄存器不能使用MOV进行修改</p>
<p>使用JMP指令修改EIP寄存器，EIP寄存器存储的是CPU下一次要执行的地址</p>
<p><img src="/2023/12/10/compilation/image-20231214150746795.png" alt="image-20231214150746795"></p>
<p>JUM指令可以跟立即数，也可以跟其他寄存器或内存</p>
<h4 id="CALL"><a href="#CALL" class="headerlink" title="CALL"></a>CALL</h4><p>1.将CALL后面的值存到EIP里<br>2.将CALL的下一行地址存到了堆栈中<br>3.ESP中的地址减0x4</p>
<p><img src="/2023/12/10/compilation/image-20231214155227379.png" alt="image-20231214155227379"></p>
<p><img src="/2023/12/10/compilation/image-20231214155540532.png" alt="image-20231214155540532"></p>
<h4 id="RET（return）"><a href="#RET（return）" class="headerlink" title="RET（return）"></a>RET（return）</h4><p>1.将当前栈顶指针ESP的值放到EIP里<br>2.将ESP加0x4</p>
<p>相当于：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ADD ESP,4</span><br><span class="line">MOV EIP, [ESP-4]</span><br></pre></td></tr></table></figure>

<h3 id="10-函数"><a href="#10-函数" class="headerlink" title="10.函数"></a>10.函数</h3><h4 id="1-函数的执行与调用"><a href="#1-函数的执行与调用" class="headerlink" title="1.函数的执行与调用"></a>1.函数的执行与调用</h4><p><strong>调用函数时一般使用CALL指令：</strong>因为通过CALL指令，会把CALL的下一行地址压到堆栈中，此时执行完函数之后只需要使用RET指令，即可返回到CALL指令的下一行</p>
<p><img src="/2023/12/10/compilation/image-20231214200005208.png" alt="image-20231214200005208"></p>
<p>执行函数后：</p>
<p><img src="/2023/12/10/compilation/image-20231214200601922.png" alt="image-20231214200601922"></p>
<p><strong>在调用函数传参时，如果有10个参数怎么办，</strong>如果使用通用寄存器只有8个，则使用<strong>堆栈传参</strong></p>
<p>用过PUSH指令，向堆栈中压入参数，需要调用的时候，在函数中使用ESP寻找参数</p>
<p><img src="/2023/12/10/compilation/image-20231214203450368.png" alt="image-20231214203450368"></p>
<p><img src="/2023/12/10/compilation/image-20231214204753323.png" alt="image-20231214204753323"></p>
<p>因为CALL函数后，ESP会-4操作并寄存CALL的下一行的地址，所以使用ADD EAX, DWORD PTR DS:[ESP+立即数] 即可找到之前PUSH的参数</p>
<h4 id="2-堆栈平衡"><a href="#2-堆栈平衡" class="headerlink" title="2.堆栈平衡"></a>2.堆栈平衡</h4><p>在函数调用的时候，执行完CALL指令，会将下一行地址压入堆栈，此时进入了函数体，当函数在执行时，可能会PUSH一些值到堆栈中，此时ESP指向的地址就不是CALL的下一行地址，如果此时使用了RET指令，那么返回的地址错误，程序就会出错，也就是堆栈不平衡。</p>
<p>所以在函数执行完毕执行RET指令时，要保证ESP指向的地址是之前CALL指令执行后的下一行地址。</p>
<p><img src="/2023/12/10/compilation/image-20231214210900748.png" alt="image-20231214210900748"></p>
<h3 id="11-寻址"><a href="#11-寻址" class="headerlink" title="11.寻址"></a>11.寻址</h3><h4 id="1-ESP寻址"><a href="#1-ESP寻址" class="headerlink" title="1.ESP寻址"></a>1.ESP寻址</h4><p>当使用ESP寻址之前在函数体中又向堆栈中PUSH了值，就会使ESP寻址更加困难，而且在堆栈中暂存寄存器的值还需要POP，所以使用ESP寻址较繁琐。</p>
<p><img src="/2023/12/10/compilation/image-20231215160655838.png" alt="image-20231215160655838"></p>
<p><img src="/2023/12/10/compilation/image-20231215164449175.png" alt="image-20231215164449175"></p>
<h4 id="2-EBP寻址"><a href="#2-EBP寻址" class="headerlink" title="2.EBP寻址"></a>2.EBP寻址</h4><p>先将EBP保存起来，然后让EBP指向ESP的位置，将现在的ESP提升一块，也就划分出了一块新的堆栈，供当前程序(函数)使用。</p>
<p>当CALL函数时，继续向堆栈中压入数据，ESP会上下浮动，但是不会影响从EBP到ESP提升后的位置。从EBP到ESP提升的这一段空间就可以放置参数，那么参数就可以使用EBP来寻址。</p>
<h5 id="1-保存EBP"><a href="#1-保存EBP" class="headerlink" title="1.保存EBP"></a>1.保存EBP</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">call 0x000000AA</span><br><span class="line"></span><br><span class="line">000000AA:  PUSH EBP // 将EBP之前的值存储起来</span><br></pre></td></tr></table></figure>

<p>此时，堆栈就会变成这样</p>
<img src="/2023/12/10/compilation/image-20231215162924185.png" alt="image-20231215162924185" style="zoom:67%;">

<h5 id="2-将EBP提升到ESP"><a href="#2-将EBP提升到ESP" class="headerlink" title="2.将EBP提升到ESP"></a>2.将EBP提升到ESP</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov ebp, esp</span><br></pre></td></tr></table></figure>

<p>此时堆栈和栈指针变成这样：</p>
<img src="/2023/12/10/compilation/image-20231215163246352.png" alt="image-20231215163246352" style="zoom:67%;">

<h5 id="3-提升ESP栈顶指针"><a href="#3-提升ESP栈顶指针" class="headerlink" title="3.提升ESP栈顶指针"></a>3.提升ESP栈顶指针</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sub esp 4*0x4</span><br></pre></td></tr></table></figure>

<p>使用sub就是将ESP指针向上移，使EBP向上到ESP腾出了一部分空间</p>
<p><img src="/2023/12/10/compilation/image-20231215164021815.png" alt="image-20231215164021815" style="zoom:67%;"><img src="/2023/12/10/compilation/image-20231215164146109.png" alt="image-20231215164146109"></p>
<h5 id="4-使用内存"><a href="#4-使用内存" class="headerlink" title="4.使用内存"></a>4.使用内存</h5><p>可以使用EBP栈指针寻找参数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov eax dword ptr ss:[ebp+0x8]</span><br><span class="line">add eax dword ptr ss:[ebp+0xC]</span><br></pre></td></tr></table></figure>

<h5 id="5-恢复内存"><a href="#5-恢复内存" class="headerlink" title="5.恢复内存"></a>5.恢复内存</h5><p>将ESP返回到EBP的位置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MOV ESP, EBP</span><br></pre></td></tr></table></figure>

<img src="/2023/12/10/compilation/image-20231215163246352.png" alt="image-20231215163246352" style="zoom:67%;">

<p>此时EBP不用了，就把EBP取回</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POP EBP</span><br></pre></td></tr></table></figure>

<p>弹出后EBP后ESP会指向之前存EBP的内存地址</p>
<p>此时堆栈就恢复到了EBP寻址前的样子</p>
<h5 id="6-RET-立即数"><a href="#6-RET-立即数" class="headerlink" title="6.RET 立即数"></a>6.RET 立即数</h5><p>因为CALL之前压入了参数，所以用RET 立即数  进行堆栈平衡</p>
<p><strong>EBP寻址总过程：</strong></p>
<p><img src="/2023/12/10/compilation/image-20231215171758535.png" alt="image-20231215171758535"></p>
<h3 id="12-JCC"><a href="#12-JCC" class="headerlink" title="12.JCC"></a>12.JCC</h3><h4 id="1-标志寄存器EFLAGS"><a href="#1-标志寄存器EFLAGS" class="headerlink" title="1.标志寄存器EFLAGS"></a>1.标志寄存器EFLAGS</h4><p> <img src="/2023/12/10/compilation/image-20231215205900615.png" alt="image-20231215205900615"></p>
<h3 id="13-硬编码"><a href="#13-硬编码" class="headerlink" title="13.硬编码"></a>13.硬编码</h3><h4 id="1-指令编码（硬编码）的结构"><a href="#1-指令编码（硬编码）的结构" class="headerlink" title="1.指令编码（硬编码）的结构"></a>1.指令编码（硬编码）的结构</h4><p><img src="/2023/12/10/compilation/image-20231216230528497.png" alt="image-20231216230528497"> </p>
<h4 id="2-反汇编引擎（x32dbg-DTDebug"><a href="#2-反汇编引擎（x32dbg-DTDebug" class="headerlink" title="2.反汇编引擎（x32dbg , DTDebug"></a>2.反汇编引擎（x32dbg , DTDebug</h4><p>将硬编码转换成汇编语言，或将汇编语言转换成硬编码</p>
<p><img src="/2023/12/10/compilation/image-20231216231259394.png" alt="image-20231216231259394"></p>
<h4 id="3-前缀指令"><a href="#3-前缀指令" class="headerlink" title="3.前缀指令"></a>3.前缀指令</h4><img src="/2023/12/10/compilation/image-20231218140943554.png" alt="image-20231218140943554" style="zoom:50%;">

<p>看上面的结构图，最后面有一个(optional)，说明指令前缀是可选的。CPU判断一个指令是前缀还是OPcode，通过值来判断。</p>
<p>反汇编引擎会在前缀指令后面加一个冒号来区分。但是，实际上在exe中并没有这个冒号</p>
<p><img src="/2023/12/10/compilation/image-20231218141423898.png" alt="image-20231218141423898"></p>
<p>前缀指令是分组的，前缀指令最多四个，每组最多一个</p>
<img src="/2023/12/10/compilation/image-20231218141946019.png" alt="image-20231218141946019" style="zoom:50%;">

<h5 id="（1）LOCK和REPEAT前缀指令"><a href="#（1）LOCK和REPEAT前缀指令" class="headerlink" title="（1）LOCK和REPEAT前缀指令"></a>（1）LOCK和REPEAT前缀指令</h5><p><strong>LOCK</strong>					F0，用来锁地址总线，如果在一个地址上加上LOCK，如果在同一时刻有多个CPU核执行这条指令，只能有一个核可以读取这个地址，其他核不能读取这个地址。这条指令在多核下才有用，单核没有什么作用</p>
<p><strong>REPNE&#x2F;REPNZ</strong>	F2<br>                                   这两个指令，当EFLAGS寄存器的ZF位为0的时候执行上面的ZF位为1时执行下面的<br><strong>REP&#x2F;REPZ</strong>			F3</p>
<h5 id="（2）段（段寄存器）前缀指令-操作系统、内核程序"><a href="#（2）段（段寄存器）前缀指令-操作系统、内核程序" class="headerlink" title="（2）段（段寄存器）前缀指令  &#x3D;&gt; 操作系统、内核程序"></a>（2）段（段寄存器）前缀指令  &#x3D;&gt; 操作系统、内核程序</h5><p>CS(2E)、SS(36)、DS(3E)、ES(26)、FS(64)、GS(65)</p>
<p>如果不指定哪个段寄存器，则使用DS段寄存器；当寻址时出现了EBP、ESP时，默认使用的段寄存器是SS段寄存器</p>
<p>段寄存器就是指定寻址时，使用的段寄存器是谁</p>
<p>比如，当加上了前缀指令65，那么后面就会使用GS段寄存器</p>
<p><img src="/2023/12/10/compilation/image-20231218143744957.png" alt="image-20231218143744957"></p>
<h5 id="操作数宽度前缀指令-66"><a href="#操作数宽度前缀指令-66" class="headerlink" title="操作数宽度前缀指令 66"></a>操作数宽度前缀指令 66</h5><p>66</p>
<p>比如，当硬编码55 PUSH EBP 时，默认的是32位的EBP寄存器，如果想用16位的BP寄存器，则在前面加上前缀指令 66，用来改变操作数宽度。而如果当前CPU默认处于16位状态下，如果加上66前缀，那么操作数就会变成32位的EBP寄存器</p>
<p><img src="/2023/12/10/compilation/image-20231218145121846.png" alt="image-20231218145121846"></p>
<h5 id="地址宽度前缀指令-67"><a href="#地址宽度前缀指令-67" class="headerlink" title="地址宽度前缀指令 67"></a>地址宽度前缀指令 67</h5><p>当当前的寻址方式是32位的，当加上地址宽度前缀时，32位的寻址方式会变成16位寻址方式</p>
<p><img src="/2023/12/10/compilation/image-20231218151101155.png" alt="image-20231218151101155"></p>
<p><strong>总结：</strong>前缀指令最多四个，每组一个，一行指令可以添加多个前缀指令，前缀指令的顺序没有要求。</p>
<h4 id="4-定长指令与变长指令"><a href="#4-定长指令与变长指令" class="headerlink" title="4.定长指令与变长指令"></a>4.定长指令与变长指令</h4><p>Opcode：在硬编码结构中，其他的结构可以没有，但是opcode必须要有，opcode 可以是1byte 2byte 3byte<br>Opcode是一条指令中最重要的组成部分，后面的ModR&#x2F;M有没有由Opcode决定，SIB有没有由ModR&#x2F;M决定。</p>
<p>定长指令：当Opcode确定了，指令长度就确定了</p>
<p>变长指令：仅仅通过Opcode是无法确定长度的</p>
<h5 id="定长指令"><a href="#定长指令" class="headerlink" title="定长指令"></a>定长指令</h5><p><strong>经典定长指令：修改ERX（通用寄存器）</strong></p>
<p>1.PUSH&#x2F;POP  50<del>57,58</del>5F</p>
<img src="/2023/12/10/compilation/image-20231218193139403.png" alt="image-20231218193139403" style="zoom:67%;">

<p>2.INC&#x2F;DEC  40<del>47,48</del>4F</p>
<p>INC加一，DEC减一</p>
<img src="/2023/12/10/compilation/image-20231218193607613.png" alt="image-20231218193607613" style="zoom: 67%;">

<p>3.mov 寄存器, 立即数</p>
<img src="/2023/12/10/compilation/image-20231218195643211.png" alt="image-20231218195643211" style="zoom:67%;">

<p>4.XCHG 两个寄存器的值交换</p>
<img src="/2023/12/10/compilation/image-20231218201054537.png" alt="image-20231218201054537" style="zoom:67%;">

<p><strong>经典定长指令：修改EIP（CPU执行地址）</strong></p>
<p><img src="/2023/12/10/compilation/image-20231218205916589.png" alt="image-20231218205916589"></p>
<p><img src="/2023/12/10/compilation/image-20231218205936389.png" alt="image-20231218205936389"></p>
<p><img src="/2023/12/10/compilation/image-20231218210027620.png" alt="image-20231218210027620"></p>
<p><img src="/2023/12/10/compilation/image-20231218211305524.png" alt="image-20231218211305524"></p>
<h5 id="变长指令"><a href="#变长指令" class="headerlink" title="变长指令"></a>变长指令</h5><p>当opcode 后面有ModR&#x2F;M结构时，就是变长指令<br>重要的变长指令</p>
<p><img src="/2023/12/10/compilation/image-20231218220233910.png" alt="image-20231218220233910"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x88  MOV Eb, Gb</span><br><span class="line">0x89  MOV Ev, Gv</span><br><span class="line">0x8A  MOV Gb, Eb</span><br><span class="line">0x8B  MOV Gv, Ev</span><br><span class="line"></span><br><span class="line">G:通用寄存器 E:寄存器/内存</span><br><span class="line">b:字节	  v:Word, doubleword or quaword</span><br></pre></td></tr></table></figure>


<p>ModR&#x2F;M占一个字节，该字节的8个位被分成了三部分使用</p>
<p><img src="/2023/12/10/compilation/image-20231218220029004.png" alt="image-20231218220029004"></p>
<p>Mod(6,7位)和R&#x2F;M(0、1、2位) 共同描述指令中的E部分即寄存器或内存</p>
<p><img src="/2023/12/10/compilation/image-20231218222947497.png" alt="image-20231218222947497"></p>
<p>ModR&#x2F;M中间部分第3、4、5位，用来描述Reg&#x2F;Opcode也就是指令中的G部分，即寄存器</p>
<p><img src="/2023/12/10/compilation/image-20231218220731549.png" alt="image-20231218220731549"></p>
<p>比如一个硬编码 <strong>88 01</strong></p>
<p>88：MOV Eb, Gb</p>
<p>01：00 000 001 第3、4、5位是000，查表能得到EAX&#x2F;AL。因为G后面跟的b，所以是8位的AL。		现在的指令就是MOV Eb, AL</p>
<p>再查表，Mod：00，R&#x2F;M：001，对应的寄存器是ECX						所以，指令就变成了	<strong>MOV BYTE PTR DS:[ECX], AL</strong></p>
<h5 id="ModR-M结构"><a href="#ModR-M结构" class="headerlink" title="ModR&#x2F;M结构"></a>ModR&#x2F;M结构</h5><p><img src="/2023/12/10/compilation/image-20231218223845586.png" alt="image-20231218223845586"></p>
<p>1.Mod与R&#x2F;M共同描述E的意义（内存或者通用寄存器）</p>
<p>2、Reg&#x2F;Opcode描述了G的意义（通用寄存器）。但3-5字段，并不仅仅用来标识寄存器，有些时候，用来标识Opcode。</p>
<p>拆一个编码 80 65</p>
<p>65：   01   					100 					  101<br>       Mod:01		Reg&#x2F;Opencode			R&#x2F;M:101</p>
<p>根据Mod R&#x2F;M查出byte ptr ds:[ebp+dis8], Ib</p>
<p>当查表时看到Grp，就要去查Table A-6</p>
<p><img src="/2023/12/10/compilation/image-20231218231619393.png" alt="image-20231218231619393"></p>
<p>Table A-6：</p>
<p><img src="/2023/12/10/compilation/image-20231218235421168.png" alt="image-20231218235421168"></p>
<p>查表A-2能得到100对应的是AND指令，所以，80 65对应的汇编就是AND byte ptr ds:[ebp+dis8], Ib</p>
<p>但是发现这条指令里面还有一个8位的地址偏移DIS8，一个立即数Ib，所以后面还应该有两个值。</p>
<p><img src="/2023/12/10/compilation/image-20231219140855744.png" alt="image-20231219140855744"></p>
<h5 id="定长指令-SIB"><a href="#定长指令-SIB" class="headerlink" title="定长指令 SIB"></a>定长指令 SIB</h5><img src="/2023/12/10/compilation/image-20231219141132169.png" alt="image-20231219141132169" style="zoom:67%;">

<p>如一个指令 88 84 48</p>
<p>通过查表，88是MOV Eb, Gb		那么84就是ModR&#x2F;M。10      000       100<br>                                                                                        Mod     Reg      R&#x2F;M</p>
<p>Reg：AL		查表得Mod为00，01，10时，R&#x2F;M对应的是 [ – ] [ – ] 或 [ – ] [ – ] +disp8 或 [ – ] [ – ] +disp32</p>
<p>那么这里的[ – ] [ – ]就是由SIB决定的，因此48就是SIB。</p>
<p><strong>SIB的指令结构：</strong><br><img src="/2023/12/10/compilation/image-20231219142642622.png" alt="image-20231219142642622"></p>
<p><img src="/2023/12/10/compilation/image-20231219142743116.png" alt="image-20231219142743116"></p>
<p>48： 01         001       000			&#x3D;&gt; 	<strong>查Table2-3</strong><br>       scale	 index	 base</p>
<p><img src="/2023/12/10/compilation/image-20231219143038753.png" alt="image-20231219143038753"></p>
<p><img src="/2023/12/10/compilation/image-20231219143145855.png" alt="image-20231219143145855"></p>
<p>查base是000，所以是[EAX]</p>
<p>再找scale 和 index ，是[ECX * 2]</p>
<img src="/2023/12/10/compilation/image-20231219143700233.png" alt="image-20231219143700233" style="zoom:50%;">

<p>所以48对应的SIB就是[ EAX + ECX * 2 ]</p>
<p>因此，88 84 48对应的汇编代码就是MOV BYTE PTR DS:[ EAX + ECX * 2 + DIS32], AL</p>
<p>因为还有一个32位的地址偏移，所以88 84 48后面还会跟着四个字节</p>
<p><img src="/2023/12/10/compilation/image-20231219144356636.png" alt="image-20231219144356636"></p>
<h3 id="堆栈"><a href="#堆栈" class="headerlink" title="堆栈"></a>堆栈</h3><p>堆栈的本质就是一块内存，在程序启动之初就分配好了，给程序执行的之后使用。任何一个程序用到的关键数据都存在堆栈里。</p>
<p>栈是一种<strong>后进先出</strong>的数据结构</p>
<h4 id="1-ESP和EBP"><a href="#1-ESP和EBP" class="headerlink" title="1.ESP和EBP"></a>1.ESP和EBP</h4><p>ESP栈顶指针，它表示当前这块堆栈用到哪里了。ESP上面的堆栈是还未使用的堆栈。</p>
<p>EBP是栈底指针，这个栈底指针不是指堆栈的最底部，而是当前这一段代码(函数)的栈底（本层call的栈底）</p>
<h4 id="2-PUSH、POP-堆栈操作指令"><a href="#2-PUSH、POP-堆栈操作指令" class="headerlink" title="2.PUSH、POP  堆栈操作指令"></a>2.PUSH、POP  堆栈操作指令</h4><p>PUSH就是把数据传入到堆栈，POP就是把数据从堆栈中取出来</p>
<p>PUSH是压栈，POP是从栈顶取出一个值</p>
<h4 id="3-PUSHAD和POPAD"><a href="#3-PUSHAD和POPAD" class="headerlink" title="3.PUSHAD和POPAD"></a>3.PUSHAD和POPAD</h4><p>PUSHAD：将所有寄存器压入堆栈<br>POPAD：将所有寄存器从堆栈中还原</p>
<h4 id="4-堆栈平衡"><a href="#4-堆栈平衡" class="headerlink" title="4.堆栈平衡"></a>4.堆栈平衡</h4><p>  在函数调用的时候，执行完CALL指令，会将下一行地址压入堆栈，此时进入了函数体，当函数在执行时，可能会PUSH一些值到堆栈中，此时ESP指向的地址就不是CALL的下一行地址，如果此时使用了RET指令，那么返回的地址错误，程序就会出错，也就是堆栈不平衡。</p>
<p>  所以在函数执行完毕执行RET指令时，要保证ESP指向的地址是之前CALL指令执行后的下一行地址。</p>
<p>  还有一种情况就是当在函数调用中向堆栈中PUSH了数据（如：PUSH 1，PUSH 2），但是调用完函数之后，0x00000001和0x00000002没有用了，占了两个堆栈空间，这也是堆栈不平衡。</p>
<p>  在CALL函数之后，内平栈或外平栈</p>
<h3 id="调用约定"><a href="#调用约定" class="headerlink" title="调用约定"></a>调用约定</h3><p>调用约定规定了两个东西：</p>
<ol>
<li>函数的参数入栈顺序(从左到右还是从右到左)</li>
<li>参数平栈的方式(内平栈外平栈)</li>
</ol>
<h2 id="汇编指令"><a href="#汇编指令" class="headerlink" title="汇编指令"></a>汇编指令</h2><h3 id="1-MOV指令-1"><a href="#1-MOV指令-1" class="headerlink" title="1.MOV指令"></a>1.MOV指令</h3><p>MOV 寄存器, 寄存器<br>MOV 寄存器, 内存<br>MOV [内存地址], 寄存器<br>MOV [内存地址], 立即数<br>MOV 寄存器, 立即数</p>
<h3 id="2-MOVZX指令"><a href="#2-MOVZX指令" class="headerlink" title="2.MOVZX指令"></a>2.MOVZX指令</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MOV EAX, 0xFFFFFFFF</span><br><span class="line">MOV AL, 0x11</span><br><span class="line">MOVZX EAX, AL</span><br></pre></td></tr></table></figure>

<p>1.将AL赋值给EAX，EAX的值就等于FFFFFF11<br>2.零扩展，其他位清零</p>
<p>所以EAX最后等于 0x00000011</p>
<h3 id="3-LEA指令"><a href="#3-LEA指令" class="headerlink" title="3.LEA指令"></a>3.LEA指令</h3><p>取地址		LEA 寄存器, [内存地址]</p>
<p><img src="/2023/12/10/compilation/image-20231220200534314.png" alt="image-20231220200534314"></p>
<h3 id="4-XCHG指令-交换指令"><a href="#4-XCHG指令-交换指令" class="headerlink" title="4.XCHG指令  交换指令"></a>4.XCHG指令  交换指令</h3><p>交换两个数据</p>
<p>XCHG EAX, EBX	&#x3D;&gt;	交换EAX和EBX中的值</p>
<p><img src="/2023/12/10/compilation/image-20231220201144745.png" alt="image-20231220201144745"></p>
<h3 id="5-运算指令"><a href="#5-运算指令" class="headerlink" title="5.运算指令"></a>5.运算指令</h3><h4 id="1-ADD指令-加法指令"><a href="#1-ADD指令-加法指令" class="headerlink" title="1.ADD指令  加法指令"></a>1.ADD指令  加法指令</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ADD 操作数1, 操作数2</span><br><span class="line">操作数1 += 操作数2</span><br></pre></td></tr></table></figure>

<p>将操作数2加到操作数1</p>
<p>ADD指令不能使用 内存+内存；ADD会影响到进位标志位CF位：无符号整数发生溢出时被置1</p>
<p><img src="/2023/12/10/compilation/image-20231220202709803.png" alt="image-20231220202709803"></p>
<h4 id="2-ADC指令-进位加指令"><a href="#2-ADC指令-进位加指令" class="headerlink" title="2.ADC指令  进位加指令"></a>2.ADC指令  进位加指令</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ADC 操作数1, 操作数2</span><br></pre></td></tr></table></figure>

<p>将操作数2加到操作数1，再加上进位标志位</p>
<p><img src="/2023/12/10/compilation/image-20231220203846632.png" alt="image-20231220203846632"></p>
<h4 id="3-SUB指令-减法指令"><a href="#3-SUB指令-减法指令" class="headerlink" title="3.SUB指令  减法指令"></a>3.SUB指令  减法指令</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SUB 操作数1, 操作数2</span><br><span class="line">操作数1 -= 操作数2</span><br></pre></td></tr></table></figure>

<p>SUB指令也会影响到CF进位标志位，当SUB借位时，CF位也会被置1</p>
<h4 id="4-SBB指令-进位减指令"><a href="#4-SBB指令-进位减指令" class="headerlink" title="4.SBB指令  进位减指令"></a>4.SBB指令  进位减指令</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SBB 操作数1, 操作数2</span><br></pre></td></tr></table></figure>

<p>将操作数1减去操作数2，再减去CF进位标志位</p>
<h4 id="5-INC指令-自增指令"><a href="#5-INC指令-自增指令" class="headerlink" title="5.INC指令  自增指令"></a>5.INC指令  自增指令</h4><p>自增指令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MOV EAX, 0x0</span><br><span class="line">INC EAX ----------&gt; EAX=0x1</span><br></pre></td></tr></table></figure>

<h4 id="6-DEC指令-自减指令"><a href="#6-DEC指令-自减指令" class="headerlink" title="6.DEC指令  自减指令"></a>6.DEC指令  自减指令</h4><p>自减指令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MOV EAX, 0x1</span><br><span class="line">DEC EAX ----------&gt; EAX=0x0</span><br></pre></td></tr></table></figure>

<h4 id="7-MUL指令-无符号乘法指令"><a href="#7-MUL指令-无符号乘法指令" class="headerlink" title="7.MUL指令  无符号乘法指令"></a>7.MUL指令  无符号乘法指令</h4><p>MUL是单操作数指令	隐藏乘数时EAX</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MOV EAX, 0x1234</span><br><span class="line">MOV EBX, 0x10</span><br><span class="line">MUL EBX ----------&gt; EAX = 0x12340</span><br></pre></td></tr></table></figure>

<p><img src="/2023/12/10/compilation/image-20231220205507636.png" alt="image-20231220205507636"></p>
<h4 id="8-IMUL指令-有符号乘法指令"><a href="#8-IMUL指令-有符号乘法指令" class="headerlink" title="8.IMUL指令  有符号乘法指令"></a>8.IMUL指令  有符号乘法指令</h4><p>IMUL是双操作数指令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MOV EAX, 0x20</span><br><span class="line">MOB EBX, 0x2</span><br><span class="line">IMUL EAX, EBX ----------&gt; EAX = 0x40</span><br></pre></td></tr></table></figure>

<p><img src="/2023/12/10/compilation/image-20231220205751946.png" alt="image-20231220205751946"></p>
<p>会影响到OF溢出标志位：有符号数产生溢出时，OF位被置1</p>
<h4 id="9-DIV指令-无符号除法指令"><a href="#9-DIV指令-无符号除法指令" class="headerlink" title="9.DIV指令  无符号除法指令"></a>9.DIV指令  无符号除法指令</h4><p>除法的概念</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5 / 3 = 1 ... 2</span><br></pre></td></tr></table></figure>

<p>5是被除数，3是除数，1是商，2是余数</p>
<p><img src="/2023/12/10/compilation/image-20231220211810092.png" alt="image-20231220211810092"></p>
<h4 id="10-IDIV指令-有符号除法指令"><a href="#10-IDIV指令-有符号除法指令" class="headerlink" title="10.IDIV指令  有符号除法指令"></a>10.IDIV指令  有符号除法指令</h4><p>与无符号除法基本一样</p>
<h3 id="6-位运算"><a href="#6-位运算" class="headerlink" title="6.位运算"></a>6.位运算</h3><h4 id="1-AND指令-与运算指令"><a href="#1-AND指令-与运算指令" class="headerlink" title="1.AND指令  与运算指令"></a>1.AND指令  与运算指令</h4><p>操作数1,：reg&#x2F;mem<br>操作数2：reg&#x2F;mem&#x2F;imm</p>
<p>操作：将操作数1与操作数2进行按位与运算，结果存到操作数1中</p>
<h4 id="2-OR指令-或运算指令"><a href="#2-OR指令-或运算指令" class="headerlink" title="2.OR指令 或运算指令"></a>2.OR指令 或运算指令</h4><p>操作数1,：reg&#x2F;mem<br>操作数2：reg&#x2F;mem&#x2F;imm</p>
<p>操作：将操作数1与操作数2进行按位或运算，结果存到操作数1中</p>
<h4 id="3-XOR指令-异或运算指令"><a href="#3-XOR指令-异或运算指令" class="headerlink" title="3.XOR指令  异或运算指令"></a>3.XOR指令  异或运算指令</h4><p>操作数1,：reg&#x2F;mem<br>操作数2：reg&#x2F;mem&#x2F;imm</p>
<p>操作：将操作数1与操作数2进行按位异或运算，结果存到操作数1中</p>
<h4 id="4-NOT指令-非运算指令"><a href="#4-NOT指令-非运算指令" class="headerlink" title="4.NOT指令  非运算指令"></a>4.NOT指令  非运算指令</h4><p>操作数1,：reg&#x2F;mem<br>操作数2：reg&#x2F;mem&#x2F;imm</p>
<p>操作：将操作数1与操作数2进行按位非运算，结果存到操作数1中</p>
<h4 id="5-SHL指令-左移-LEFT-指令"><a href="#5-SHL指令-左移-LEFT-指令" class="headerlink" title="5.SHL指令  左移(LEFT)指令"></a>5.SHL指令  左移(LEFT)指令</h4><p>操作数1：reg<br>操作数2：imm&#x2F;CL</p>
<p>操作：左移 （乘2^n）</p>
<h4 id="6-SHR指令-右移-RIGHT-指令"><a href="#6-SHR指令-右移-RIGHT-指令" class="headerlink" title="6.SHR指令  右移(RIGHT)指令"></a>6.SHR指令  右移(RIGHT)指令</h4><p>操作数1：reg<br>操作数2：imm&#x2F;CL</p>
<p>操作：右移（除以2^n）</p>
<h3 id="7-比较指令"><a href="#7-比较指令" class="headerlink" title="7.比较指令"></a>7.比较指令</h3><p>逻辑运算都不会得到运算结果，仅仅设置标志寄存器中的相应标志位，同行&#x3D;&#x3D;通常都是配合跳转指令，实现汇编中的选择或者循环结构</p>
<h4 id="1-CMP指令"><a href="#1-CMP指令" class="headerlink" title="1.CMP指令"></a>1.CMP指令</h4><p>CMP用于比较两个数的大小</p>
<p>操作数1：reg<br>操作数2：reg&#x2F;mem&#x2F;imm<br>指令结构：CMP 操作数1，操作数2<br>执行操作：用操作数1减去操作数2，并根据结果设置EFLAGS寄存器中的状态标志<br>                  不会设置结果，只会根据结果设置标志寄存器中的值</p>
<p>SF符号位（第七位）：设置成结果的最高位，也就是带符号位中的符号位（0表示正数，1表示负数）</p>
<p>ZF零标志位（第六位）：当运算结果为0时，该标志位被置1</p>
<p>PF奇偶标志位（第二位）：当结果的最低字节中1的个数为偶数（最后的运算结果为偶数）时置1，否则置0</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MOV EAX, 0x1</span><br><span class="line">CMP EAX, 0x1</span><br></pre></td></tr></table></figure>

<p>执行CMP指令，EAX会被减1，但是运算后的值不会赋值给EAX<br>执行后，EAX运算的值是0，因此，ZF位被置1</p>
<p>当两数相等时，CMP两个数，ZF位和PF位都会被置1。<br>当EAX中的值小于后面的数时，EAX-IMM为负数，所以SF符号位会被置1</p>
<h4 id="2-TEXT指令"><a href="#2-TEXT指令" class="headerlink" title="2.TEXT指令"></a>2.TEXT指令</h4><p>最常用的功能就是测试某个寄存器的值是不是0</p>
<p>操作数1：reg<br>操作数2：reg&#x2F;mem&#x2F;imm<br>指令结构 TEST 操作数1，操作数2<br>执行操作：将操作数1和操作数2进行按位与运算，并根据结果设置SF ZF PF状态标志，然后丢弃结果</p>
<p>一般会写：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">TEST EDX, EDX</span><br><span class="line">TEST EAX, EAX</span><br><span class="line">TEST ECX, ECX</span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<p>用来判断某个寄存器中的值是否为0。当某个寄存器中的值为0时，ZF位会被置1</p>
<h3 id="8-串操作指令"><a href="#8-串操作指令" class="headerlink" title="8.串操作指令"></a>8.串操作指令</h3><h4 id="1-MOVS指令-将ESI地址指向的内存复制到EDI指向的内存中"><a href="#1-MOVS指令-将ESI地址指向的内存复制到EDI指向的内存中" class="headerlink" title="1.MOVS指令  将ESI地址指向的内存复制到EDI指向的内存中"></a>1.MOVS指令  将ESI地址指向的内存复制到EDI指向的内存中</h4><p>之前的MOV指令不允许MOV内存到内存；MOVS指令可以从一个内存地址移动到另一个内存地址</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MOVS BYTE PTR ES:[EDI], BYTE PTR DS:[ESI] ----------&gt; 简写:MOVSB</span><br><span class="line">MOVS WORD PTR ES:[EDI], WORD PTR DS:[ESI] ----------&gt; 简写:MOVSW</span><br><span class="line">MOVS DWORD PTR ES:[EDI], DWPRD PTR DS:[ESI] ----------&gt; 简写:MOVSD</span><br></pre></td></tr></table></figure>

<p>前面是目的操作数dest（ [EDI] ），后面是源操作数src（ [ESI] ）</p>
<p>当DF位方向标志位置1时，执行完串操作指令，串操作指令地址会自动自减（高地址向低地址）<br>当DF位方向标志位置0时，执行完串操作指令，串操作指令地址会自动自增（低地址向高地址）<br>当MOVSB时，EDI ESI自减(增)一个字节；MOVSW时自减(增)两个字节；MOVSD时自减(增)四个字节</p>
<p>串操作指令用到的寄存器都是EDI和ESI，不能用其他的寄存器。</p>
<p>以C语言为例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">strcpy</span>(dest, src, size)</span><br></pre></td></tr></table></figure>

<p>EDI就相当于dest，ESI就相当于src，BYTE&#x2F;WORD&#x2F;DWORD就相当于size</p>
<h4 id="2-STOS指令-将EAX的值复制到EDI指向的内存地址中"><a href="#2-STOS指令-将EAX的值复制到EDI指向的内存地址中" class="headerlink" title="2.STOS指令  将EAX的值复制到EDI指向的内存地址中"></a>2.STOS指令  将EAX的值复制到EDI指向的内存地址中</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">STOS BYTE PTR ES:[EDI] ----------&gt; 简写为STOSB</span><br><span class="line">STOS WORD PTR ES:[EDI] ----------&gt; 简写为STOSW</span><br><span class="line">STOS DWORD PTR ES:[EDI] ---------&gt; 简写为SWOSD</span><br></pre></td></tr></table></figure>

<p>STOS指令是将AL&#x2F;AX&#x2F;EAX中的值存储到EDI里。<br>执行完之后，EDI的值也会自增(减)，也取决于DF标志位和操作数宽度</p>
<p><img src="/2023/12/10/compilation/image-20231221212906571.png" alt="image-20231221212906571"></p>
<h4 id="3-REP重复执行指令"><a href="#3-REP重复执行指令" class="headerlink" title="3.REP重复执行指令"></a>3.REP重复执行指令</h4><p>按ECX寄存器中指定的次数重复执行字符串指令，并且每执行一次ECX中的数值就会减一。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MOV ECX, 0x10</span><br><span class="line">REP MOVSD</span><br><span class="line">REP STOSD</span><br></pre></td></tr></table></figure>

<p><img src="/2023/12/10/compilation/image-20231221214114019.png" alt="image-20231221214114019"></p>
<p><img src="/2023/12/10/compilation/image-20231221214706745.png" alt="image-20231221214706745"></p>
<h3 id="9-修改EIP指令"><a href="#9-修改EIP指令" class="headerlink" title="9.修改EIP指令"></a>9.修改EIP指令</h3><h4 id="1-JMP指令"><a href="#1-JMP指令" class="headerlink" title="1.JMP指令"></a>1.JMP指令</h4><p>当要修改EIP指针时，不能使用mov eip, 0xFFFFFFFF直接修改EIP的值</p>
<p>但是可以通过JMP指令间接修改EIP。JMP指令表示需要跳转到哪个内存地址</p>
<p>JMP可以直接跟地址，或者跟一个寄存器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JMP 0x00000000</span><br><span class="line">		|</span><br><span class="line">		|</span><br><span class="line">		v</span><br><span class="line">MOV EAX, 0x00000000</span><br><span class="line">JMP EAX</span><br></pre></td></tr></table></figure>

<h4 id="2-CALL指令"><a href="#2-CALL指令" class="headerlink" title="2.CALL指令"></a>2.CALL指令</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CALL 0x00000000</span><br><span class="line">		|</span><br><span class="line">		|</span><br><span class="line">		v</span><br><span class="line">PUSH 0x00000004</span><br><span class="line">JMP 0x00000000</span><br></pre></td></tr></table></figure>

<h3 id="10-EFLAGS寄存器"><a href="#10-EFLAGS寄存器" class="headerlink" title="10.EFLAGS寄存器"></a>10.EFLAGS寄存器</h3><h4 id="1、进位标志CF-Carry-Flag"><a href="#1、进位标志CF-Carry-Flag" class="headerlink" title="1、进位标志CF(Carry Flag)"></a>1、进位标志CF(Carry Flag)</h4><p>进位标志CF主要用来反映运算是否产生进位或借位。如果运算结果的最高位产生了一个进位或借位，那么，其值为1，否则其值为0。</p>
<p>使用该标志位的情况有：多字(字节)数的加减运算，无符号数的大小比较运算，移位操作，字(字节)之间移位，专门改变CF值的指令等。</p>
<h4 id="2、奇偶标志PF-Parity-Flag"><a href="#2、奇偶标志PF-Parity-Flag" class="headerlink" title="2、奇偶标志PF(Parity Flag)"></a>2、奇偶标志PF(Parity Flag)</h4><p>奇偶标志PF用于反映运算结果中“1”的个数的奇偶性。如果“1”的个数为偶数，则PF的值为1，否则其值为0。</p>
<p>利用PF可进行奇偶校验检查，或产生奇偶校验位。在数据传送过程中，为了提供传送的可靠性，如果采用奇偶校验的方法，就可使用该标志位。</p>
<h4 id="3、辅助进位标志AF-Auxiliary-Carry-Flag"><a href="#3、辅助进位标志AF-Auxiliary-Carry-Flag" class="headerlink" title="3、辅助进位标志AF(Auxiliary Carry Flag)"></a>3、辅助进位标志AF(Auxiliary Carry Flag)</h4><p>在发生下列情况时，辅助进位标志AF的值被置为1，否则其值为0：<br>(1)、在字操作时，发生低字节向高字节进位或借位时；<br>(2)、在字节操作时，发生低4位向高4位进位或借位时。</p>
<p>对以上6个运算结果标志位，在一般编程情况下，标志位CF、ZF、SF和OF的使用频率较高，而标志位PF和AF的使用频率较低。</p>
<h4 id="4、零标志ZF-Zero-Flag"><a href="#4、零标志ZF-Zero-Flag" class="headerlink" title="4、零标志ZF(Zero Flag)"></a>4、零标志ZF(Zero Flag)</h4><p>零标志ZF用来反映运算结果是否为0。如果运算结果为0，则其值为1，否则其值为0。在判断运算结果是否为0时，可使用此标志位。</p>
<h4 id="5、符号标志SF-Sign-Flag"><a href="#5、符号标志SF-Sign-Flag" class="headerlink" title="5、符号标志SF(Sign Flag)"></a>5、符号标志SF(Sign Flag)</h4><p>符号标志SF用来反映运算结果的符号位，它与运算结果的最高位相同。在微机系统中，有符号数采用补码表示法，所以，SF也就反映运算结果的正负号。运算结果为正数时，SF的值为0，否则其值为1。</p>
<h4 id="6、溢出标志OF-Overflow-Flag"><a href="#6、溢出标志OF-Overflow-Flag" class="headerlink" title="6、溢出标志OF(Overflow Flag)"></a>6、溢出标志OF(Overflow Flag)</h4><p>溢出标志OF用于反映有符号数加减运算所得结果是否溢出。如果运算结果超过当前运算位数所能表示的范围，则称为溢出，OF的值被置为1，否则，OF的值被清为0。</p>
<h4 id="7、追踪标志TF-Trap-Flag"><a href="#7、追踪标志TF-Trap-Flag" class="headerlink" title="7、追踪标志TF(Trap Flag)"></a>7、追踪标志TF(Trap Flag)</h4><p>当追踪标志TF被置为1时，CPU进入单步执行方式，即每执行一条指令，产生一个单步中断请求。这种方式主要用于程序的调试。</p>
<p>指令系统中没有专门的指令来改变标志位TF的值，但程序员可用其它办法来改变其值。</p>
<h4 id="8、中断允许标志IF-Interrupt-enable-Flag"><a href="#8、中断允许标志IF-Interrupt-enable-Flag" class="headerlink" title="8、中断允许标志IF(Interrupt-enable Flag)"></a>8、中断允许标志IF(Interrupt-enable Flag)</h4><p>中断允许标志IF是用来决定CPU是否响应CPU外部的可屏蔽中断发出的中断请求。但不管该标志为何值，CPU都必须响应CPU外部的不可屏蔽中断所发出的中断请求，以及CPU内部产生的中断请求。具体规定如下：</p>
<ul>
<li>(1)、当IF&#x3D;1时，CPU可以响应CPU外部的可屏蔽中断发出的中断请求；</li>
<li>(2)、当IF&#x3D;0时，CPU不响应CPU外部的可屏蔽中断发出的中断请求。</li>
</ul>
<p>CPU的指令系统中也有专门的指令来改变标志位IF的值。</p>
<h4 id="9、方向标志DF-Direction-Flag"><a href="#9、方向标志DF-Direction-Flag" class="headerlink" title="9、方向标志DF(Direction Flag)"></a>9、方向标志DF(Direction Flag)</h4><p>方向标志DF用来决定在串操作指令执行时有关指针寄存器发生调整的方向。在微机的指令系统中，还提供了专门的指令来改变标志位DF的值。</p>
<h3 id="11-JCC指令"><a href="#11-JCC指令" class="headerlink" title="11.JCC指令"></a>11.JCC指令</h3><img src="/2023/12/10/compilation/image-20231222144942623.png" alt="image-20231222144942623" style="zoom:67%;">

]]></content>
      <categories>
        <category>汇编</category>
      </categories>
      <tags>
        <tag>汇编</tag>
      </tags>
  </entry>
  <entry>
    <title>微信小程序加载网络字体</title>
    <url>/2023/11/26/wxxcxwlzt/</url>
    <content><![CDATA[<h1 id="关于微信小程序字体更换问题"><a href="#关于微信小程序字体更换问题" class="headerlink" title="关于微信小程序字体更换问题"></a>关于微信小程序字体更换问题</h1><p>在制作微信小程序换字体时，如果直接使用</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">text</span> <span class="attr">decode</span> <span class="attr">class</span>=<span class="string">&quot;SwiperTitle&quot;</span> <span class="attr">style</span>=<span class="string">&quot;font-family:宋体 ;&quot;</span>&gt;</span>宋体宋体宋体<span class="tag">&lt;/<span class="name">text</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在电脑预览时，字体确实会变成宋体（下图</p>
<p><img src="/2023/11/26/wxxcxwlzt/image-20240705105411286.png" alt="image-20240705105411286"></p>
<p>但是当在手机上预览时，因为手机并没有“宋体”这个预制的字体，所以手机并不会将字体改成宋体</p>
<span id="more"></span>

<img src="/2023/11/26/wxxcxwlzt/image-20240705105517167.png" alt="image-20240705105517167" style="zoom: 50%;">

<p>因此，采用网络字体的方式对字体进行更新</p>
<h1 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h1><p>一个字体文件起码好几兆，所以肯定不能放到本地然后编译进去，只能从网络获取</p>
<p>首先获取一个字体的.ttf文件，然后将这个.ttf文件上传为网络直链地址，最后在小程序里调用这个网络直<br>链地址就完成了对字体的更改。</p>
<h1 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h1><h2 id="1-获取一个字体-ttf文件"><a href="#1-获取一个字体-ttf文件" class="headerlink" title="1.获取一个字体.ttf文件"></a>1.获取一个字体.ttf文件</h2><p>这里使用.ttf .otf等字体文件都可以</p>
<p>我采用的方法是从字体管家下载字体，因为比较靠谱</p>
<p><img src="/2023/11/26/wxxcxwlzt/image-20240705105630877.png" alt="image-20240705105630877"></p>
<p>打开之后是这样子的</p>
<p><img src="/2023/11/26/wxxcxwlzt/image-20240705105642530.png" alt="image-20240705105642530"></p>
<p>首先我下载了几个字体，大小最好是10M以内的。</p>
<p><img src="/2023/11/26/wxxcxwlzt/image-20240705105659354.png" alt="image-20240705105659354"></p>
<p>然后打开字体备份，对想要的字体进行备份</p>
<p><img src="/2023/11/26/wxxcxwlzt/image-20240705105709932.png" alt="image-20240705105709932"></p>
<p>然后打开备份文件夹，直接备份后在备份文件夹中就能直接找到下载的字体了（这种找.ttf文件的方法比<br>较方便）</p>
<p><img src="/2023/11/26/wxxcxwlzt/image-20240705105725191.png" alt="image-20240705105725191"></p>
<h2 id="2-将-ttf文件上传为网络直链地址"><a href="#2-将-ttf文件上传为网络直链地址" class="headerlink" title="2.将.ttf文件上传为网络直链地址"></a>2.将.ttf文件上传为网络直链地址</h2><p>如果我们有服务器的话可以直接上传到我们的服务器进行访问，但是没有服务器的话我们可以使用Gitee<br>个人仓库上传字体文件————<a href="https://gitee.com/">Gitee</a> (因为Gitee访问起来比较快，所以没用github)</p>
<p>刚登录进去应该就是创建一个仓库，如果没有的话就右上角有个加好，点击创建仓库就可以</p>
<p><img src="/2023/11/26/wxxcxwlzt/image-20240705105854907.png" alt="image-20240705105854907"></p>
<p>然后在仓库中上传字体文件，下载字体的时候别下超过10M的，因为传不上去</p>
<p><img src="/2023/11/26/wxxcxwlzt/image-20240705105943876.png" alt="image-20240705105943876"></p>
<p>点进这个文件，下面有个下载，这个下载就是一个直链的下载地址了</p>
<p><img src="/2023/11/26/wxxcxwlzt/image-20240705105956298.png" alt="image-20240705105956298"></p>
<p>右键下载，复制链接</p>
<img src="/2023/11/26/wxxcxwlzt/image-20240705110007315.png" alt="image-20240705110007315" style="zoom:50%;">

<h2 id="3-在微信开发者工具中添加网络字体"><a href="#3-在微信开发者工具中添加网络字体" class="headerlink" title="3.在微信开发者工具中添加网络字体"></a>3.在微信开发者工具中添加网络字体</h2><p>在要添加的页面的.js文件中的生命周期函数–监听页面加载onLoad函数中添加一个获取字体，页面加载<br>时就会获取这个.ttf文件</p>
<p>在.js的onLoad函数中添加：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">wx.<span class="title function_">loadFontFace</span>(&#123;</span><br><span class="line">    <span class="attr">family</span>: <span class="string">&#x27;abcabcabc&#x27;</span>,</span><br><span class="line">    <span class="attr">source</span>: <span class="string">&#x27;url(&quot;url&quot;)&#x27;</span>,</span><br><span class="line">    <span class="attr">success</span>: <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(e, <span class="string">&#x27;动态加载字体成功&#x27;</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">fail</span>: <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(e, <span class="string">&#x27;动态加载字体失败&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>source字段后面的url填写上面获取的文件直链地址</p>
<p>family中填写字体的名字，起个名就可以。</p>
<p>在wxss中添加</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@font-face</span> &#123;</span><br><span class="line">    <span class="attribute">font-family</span>:<span class="string">&#x27;abcabcabc&#x27;</span>;</span><br><span class="line">    <span class="attribute">src</span>:<span class="built_in">url</span>(<span class="string">&#x27;url&#x27;</span>) <span class="built_in">format</span>(<span class="string">&#x27;opentype&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>url同样填写字体文件直链地址</p>
<p>此时，网络字体就添加好了，然后在我们需要修改字体的text上添加一个style</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">text</span> <span class="attr">style</span>=<span class="string">&quot;font-family: abcabcabc &quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">text</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="/2023/11/26/wxxcxwlzt/image-20240705110215808.png" alt="image-20240705110215808"></p>
<p>但这只是在电脑上显示出来了，还要在真机上显示出来，因此到手机上预览</p>
<img src="/2023/11/26/wxxcxwlzt/image-20240705110236259.png" alt="image-20240705110236259" style="zoom:33%;">

<p>这样第三方网络字库就加载完成了</p>
]]></content>
      <categories>
        <category>Study Essay</category>
      </categories>
      <tags>
        <tag>微信小程序</tag>
      </tags>
  </entry>
</search>
